'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var _ = require('lodash');
var ___default = _interopDefault(_);
var fs = _interopDefault(require('fs'));
var hash = _interopDefault(require('hash-sum'));
var env = _interopDefault(require('std-env'));
var consola = _interopDefault(require('consola'));
var Vue = _interopDefault(require('vue'));
var VueMeta = _interopDefault(require('vue-meta'));
var vueServerRenderer = require('vue-server-renderer');
var LRU = _interopDefault(require('lru-cache'));
var Youch = _interopDefault(require('@nuxtjs/youch'));
var fsExtra = _interopDefault(require('fs-extra'));
var generateETag = _interopDefault(require('etag'));
var fresh = _interopDefault(require('fresh'));
var crypto = _interopDefault(require('crypto'));
var serialize = _interopDefault(require('serialize-javascript'));
var serveStatic = _interopDefault(require('serve-static'));
var compression = _interopDefault(require('compression'));
var connect = _interopDefault(require('connect'));
var launchMiddleware = _interopDefault(require('launch-editor-middleware'));
var Module = _interopDefault(require('module'));
var enableDestroy = _interopDefault(require('server-destroy'));
var Chalk = _interopDefault(require('chalk'));
var esm = _interopDefault(require('esm'));
var threadLoader = require('thread-loader');
var createResolver = _interopDefault(require('postcss-import-resolver'));
var MiniCssExtractPlugin = _interopDefault(require('mini-css-extract-plugin'));
var TimeFixPlugin = _interopDefault(require('time-fix-plugin'));
var VueLoader = _interopDefault(require('vue-loader'));
var WebpackBar = _interopDefault(require('webpackbar'));
var webpack = _interopDefault(require('webpack'));
var HTMLPlugin = _interopDefault(require('html-webpack-plugin'));
var BundleAnalyzer = _interopDefault(require('webpack-bundle-analyzer'));
var UglifyJsWebpackPlugin = _interopDefault(require('uglifyjs-webpack-plugin'));
var FriendlyErrorsWebpackPlugin = _interopDefault(require('@nuxtjs/friendly-errors-webpack-plugin'));
var nodeExternals = _interopDefault(require('webpack-node-externals'));
var pify = _interopDefault(require('pify'));
var chokidar = _interopDefault(require('chokidar'));
var MFS = _interopDefault(require('memory-fs'));
var webpackDevMiddleware = _interopDefault(require('webpack-dev-middleware'));
var webpackHotMiddleware = _interopDefault(require('webpack-hot-middleware'));
var Glob = _interopDefault(require('glob'));
var upath = _interopDefault(require('upath'));
var htmlMinifier = _interopDefault(require('html-minifier'));

const encodeHtml = function encodeHtml(str) {
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;')
};

const getContext = function getContext(req, res) {
  return { req, res }
};

const waitFor = function waitFor(ms) {
  return new Promise(resolve => setTimeout(resolve, ms || 0))
};

async function promiseFinally(fn, finalFn) {
  let result;
  try {
    if (typeof fn === 'function') {
      result = await fn();
    } else {
      result = await fn;
    }
  } finally {
    finalFn();
  }
  return result
}

const timeout = function timeout(fn, ms, msg) {
  let timerId;
  const warpPromise = promiseFinally(fn, () => clearTimeout(timerId));
  const timerPromise = new Promise((resolve, reject) => {
    timerId = setTimeout(() => reject(new Error(msg)), ms);
  });
  return Promise.race([warpPromise, timerPromise])
};

const urlJoin = function urlJoin() {
  return [].slice
    .call(arguments)
    .join('/')
    .replace(/\/+/g, '/')
    .replace(':/', '://')
};

const isUrl = function isUrl(url) {
  return url.indexOf('http') === 0 || url.indexOf('//') === 0
};

const promisifyRoute = function promisifyRoute(fn, ...args) {
  // If routes is an array
  if (Array.isArray(fn)) {
    return Promise.resolve(fn)
  }
  // If routes is a function expecting a callback
  if (fn.length === arguments.length) {
    return new Promise((resolve, reject) => {
      fn((err, routeParams) => {
        if (err) {
          reject(err);
        }
        resolve(routeParams);
      }, ...args);
    })
  }
  let promise = fn(...args);
  if (
    !promise ||
    (!(promise instanceof Promise) && typeof promise.then !== 'function')
  ) {
    promise = Promise.resolve(promise);
  }
  return promise
};

const sequence = function sequence(tasks, fn) {
  return tasks.reduce(
    (promise, task) => promise.then(() => fn(task)),
    Promise.resolve()
  )
};

const parallel = function parallel(tasks, fn) {
  return Promise.all(tasks.map(task => fn(task)))
};

const chainFn = function chainFn(base, fn) {
  /* istanbul ignore if */
  if (typeof fn !== 'function') {
    return base
  }
  return function () {
    if (typeof base !== 'function') {
      return fn.apply(this, arguments)
    }
    let baseResult = base.apply(this, arguments);
    // Allow function to mutate the first argument instead of returning the result
    if (baseResult === undefined) {
      baseResult = arguments[0];
    }
    let fnResult = fn.call(
      this,
      baseResult,
      ...Array.prototype.slice.call(arguments, 1)
    );
    // Return mutated argument if no result was returned
    if (fnResult === undefined) {
      return baseResult
    }
    return fnResult
  }
};

const isPureObject = function isPureObject(o) {
  return !Array.isArray(o) && typeof o === 'object'
};

const isWindows = /^win/.test(process.platform);

const wp = function wp(p = '') {
  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\\/g, '\\\\')
  }
  return p
};

const wChunk = function wChunk(p = '') {
  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\//g, '_')
  }
  return p
};

const reqSep = /\//g;
const sysSep = ___default.escapeRegExp(path.sep);
const normalize = string => string.replace(reqSep, sysSep);

const r = function r() {
  let args = Array.prototype.slice.apply(arguments);
  let lastArg = ___default.last(args);

  if (lastArg.indexOf('@') === 0 || lastArg.indexOf('~') === 0) {
    return wp(lastArg)
  }

  return wp(path.resolve(...args.map(normalize)))
};

const relativeTo = function relativeTo() {
  let args = Array.prototype.slice.apply(arguments);
  let dir = args.shift();

  // Keep webpack inline loader intact
  if (args[0].indexOf('!') !== -1) {
    const loaders = args.shift().split('!');

    return loaders.concat(relativeTo(dir, loaders.pop(), ...args)).join('!')
  }

  // Resolve path
  let _path = r(...args);

  // Check if path is an alias
  if (_path.indexOf('@') === 0 || _path.indexOf('~') === 0) {
    return _path
  }

  // Make correct relative path
  let rp = path.relative(dir, _path);
  if (rp[0] !== '.') {
    rp = './' + rp;
  }

  return wp(rp)
};

const flatRoutes = function flatRoutes(router, _path = '', routes = []) {
  router.forEach(r => {
    if (!r.path.includes(':') && !r.path.includes('*')) {
      /* istanbul ignore if */
      if (r.children) {
        if (_path === '' && r.path === '/') {
          routes.push('/');
        }
        flatRoutes(r.children, _path + r.path + '/', routes);
      } else {
        _path = _path.replace(/^\/+$/, '/');
        routes.push(
          (r.path === '' && _path[_path.length - 1] === '/'
            ? _path.slice(0, -1)
            : _path) + r.path
        );
      }
    }
  });
  return routes
};

function cleanChildrenRoutes(routes, isChild = false) {
  let start = -1;
  let routesIndex = [];
  routes.forEach(route => {
    if (/-index$/.test(route.name) || route.name === 'index') {
      // Save indexOf 'index' key in name
      let res = route.name.split('-');
      let s = res.indexOf('index');
      start = start === -1 || s < start ? s : start;
      routesIndex.push(res);
    }
  });
  routes.forEach(route => {
    route.path = isChild ? route.path.replace('/', '') : route.path;
    if (route.path.indexOf('?') > -1) {
      let names = route.name.split('-');
      let paths = route.path.split('/');
      if (!isChild) {
        paths.shift();
      } // clean first / for parents
      routesIndex.forEach(r => {
        let i = r.indexOf('index') - start; //  children names
        if (i < paths.length) {
          for (let a = 0; a <= i; a++) {
            if (a === i) {
              paths[a] = paths[a].replace('?', '');
            }
            if (a < i && names[a] !== r[a]) {
              break
            }
          }
        }
      });
      route.path = (isChild ? '' : '/') + paths.join('/');
    }
    route.name = route.name.replace(/-index$/, '');
    if (route.children) {
      if (route.children.find(child => child.path === '')) {
        delete route.name;
      }
      route.children = cleanChildrenRoutes(route.children, true);
    }
  });
  return routes
}

const createRoutes = function createRoutes(files, srcDir, pagesDir) {
  let routes = [];
  files.forEach(file => {
    let keys = file
      .replace(RegExp(`^${pagesDir}`), '')
      .replace(/\.(vue|js)$/, '')
      .replace(/\/{2,}/g, '/')
      .split('/')
      .slice(1);
    let route = { name: '', path: '', component: r(srcDir, file) };
    let parent = routes;
    keys.forEach((key, i) => {
      // remove underscore only, if its the prefix
      const sanatizedKey = key.indexOf('_') === 0
        ? key.replace('_', '')
        : key;
      route.name = route.name
        ? route.name + '-' + sanatizedKey
        : sanatizedKey;
      route.name += key === '_' ? 'all' : '';
      route.chunkName = file.replace(/\.(vue|js)$/, '');
      let child = ___default.find(parent, { name: route.name });
      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = '';
      } else {
        if (key === 'index' && i + 1 === keys.length) {
          route.path += i > 0 ? '' : '/';
        } else {
          route.path += '/' +
            (key === '_'
              ? '*'
              : key.indexOf('_') === 0
                ? key.replace('_', ':')
                : key);
          if (key !== '_' && key.indexOf('_') === 0) {
            route.path += '?';
          }
        }
      }
    });
    // Order Routes path
    parent.push(route);
    parent.sort((a, b) => {
      if (!a.path.length) {
        return -1
      }
      if (!b.path.length) {
        return 1
      }
      // Order: /static, /index, /:dynamic
      // Match exact route before index: /login before /index/_slug
      if (a.path === '/') {
        return /^\/(:|\*)/.test(b.path) ? -1 : 1
      }
      if (b.path === '/') {
        return /^\/(:|\*)/.test(a.path) ? 1 : -1
      }
      let i = 0;
      let res = 0;
      let y = 0;
      let z = 0;
      const _a = a.path.split('/');
      const _b = b.path.split('/');
      for (i = 0; i < _a.length; i++) {
        if (res !== 0) {
          break
        }
        y = _a[i] === '*' ? 2 : _a[i].indexOf(':') > -1 ? 1 : 0;
        z = _b[i] === '*' ? 2 : _b[i].indexOf(':') > -1 ? 1 : 0;
        res = y - z;
        // If a.length >= b.length
        if (i === _b.length - 1 && res === 0) {
          // change order if * found
          res = _a[i] === '*' ? -1 : 1;
        }
      }
      return res === 0 ? (_a[i - 1] === '*' && _b[i] ? 1 : -1) : res
    });
  });
  return cleanChildrenRoutes(routes)
};

var Utils = /*#__PURE__*/Object.freeze({
  encodeHtml: encodeHtml,
  getContext: getContext,
  waitFor: waitFor,
  timeout: timeout,
  urlJoin: urlJoin,
  isUrl: isUrl,
  promisifyRoute: promisifyRoute,
  sequence: sequence,
  parallel: parallel,
  chainFn: chainFn,
  isPureObject: isPureObject,
  isWindows: isWindows,
  wp: wp,
  wChunk: wChunk,
  r: r,
  relativeTo: relativeTo,
  flatRoutes: flatRoutes,
  createRoutes: createRoutes
});

class ModuleContainer {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.requiredModules = {};
  }

  async ready() {
    // Call before hook
    await this.nuxt.callHook('modules:before', this, this.options.modules);

    // Load every module in sequence
    await sequence(this.options.modules, this.addModule.bind(this));

    // Call done hook
    await this.nuxt.callHook('modules:done', this);
  }

  addVendor(vendor) {
    // Make it silent for backward compability with nuxt 1.x
  }

  addTemplate(template) {
    /* istanbul ignore if */
    if (!template) {
      throw new Error('Invalid template:' + JSON.stringify(template))
    }

    // Validate & parse source
    const src = template.src || template;
    const srcPath = path.parse(src);
    /* istanbul ignore if */
    if (!src || typeof src !== 'string' || !fs.existsSync(src)) {
      throw new Error('Template src not found:' + src)
    }

    // Generate unique and human readable dst filename
    const dst =
      template.fileName ||
      path.basename(srcPath.dir) + `.${srcPath.name}.${hash(src)}` + srcPath.ext;

    // Add to templates list
    const templateObj = {
      src,
      dst,
      options: template.options
    };

    this.options.build.templates.push(templateObj);
    return templateObj
  }

  addPlugin(template) {
    const { dst } = this.addTemplate(template);

    // Add to nuxt plugins
    this.options.plugins.unshift({
      src: path.join(this.options.buildDir, dst),
      ssr: template.ssr
    });
  }

  addLayout(template, name) {
    const { dst, src } = this.addTemplate(template);

    // Add to nuxt layouts
    this.options.layouts[name || path.parse(src).name] = `./${dst}`;
  }

  addServerMiddleware(middleware) {
    this.options.serverMiddleware.push(middleware);
  }

  extendBuild(fn) {
    this.options.build.extend = chainFn(this.options.build.extend, fn);
  }

  extendRoutes(fn) {
    this.options.router.extendRoutes = chainFn(
      this.options.router.extendRoutes,
      fn
    );
  }

  requireModule(moduleOpts) {
    return this.addModule(moduleOpts, true /* require once */)
  }

  async addModule(moduleOpts, requireOnce) {
    let src;
    let options;
    let handler;

    // Type 1: String
    if (typeof moduleOpts === 'string') {
      src = moduleOpts;
    } else if (Array.isArray(moduleOpts)) {
      // Type 2: Babel style array
      src = moduleOpts[0];
      options = moduleOpts[1];
    } else if (typeof moduleOpts === 'object') {
      // Type 3: Pure object
      src = moduleOpts.src;
      options = moduleOpts.options;
      handler = moduleOpts.handler;
    }

    // Resolve handler
    if (!handler) {
      handler = this.nuxt.requireModule(src, { esm: false });
    }

    // Validate handler
    /* istanbul ignore if */
    if (typeof handler !== 'function') {
      throw new Error('Module should export a function: ' + src)
    }

    // Resolve module meta
    const key = (handler.meta && handler.meta.name) || handler.name || src;

    // Update requiredModules
    if (typeof key === 'string') {
      if (requireOnce && this.requiredModules[key]) {
        return
      }
      this.requiredModules[key] = { src, options, handler };
    }

    // Default module options to empty object
    if (options === undefined) {
      options = {};
    }

    return new Promise((resolve, reject) => {
      // Call module with `this` context and pass options
      const result = handler.call(this, options);

      // If module send back a promise
      if (result && result.then) {
        return resolve(result)
      }

      // synchronous
      return resolve()
    })
  }
}

var modes = {
  universal: {
    build: {
      ssr: true
    },
    render: {
      ssr: true
    }
  },
  spa: {
    build: {
      ssr: false
    },
    render: {
      ssr: false
    }
  }
}

const nuxtDir = fs.existsSync(path.resolve(__dirname, '..', 'package.json'))
  ? path.resolve(__dirname, '..') // dist
  : path.resolve(__dirname, '..', '..'); // src

var defaults = {
  // Information about running environment
  dev: Boolean(env.dev),
  debug: undefined, // = dev

  // Mode
  mode: 'universal',

  // Dirs
  buildDir: '.nuxt',
  nuxtDir,
  nuxtAppDir: path.resolve(nuxtDir, 'lib', 'app'),
  modulesDir: ['node_modules'], // ~> relative to options.rootDir

  // Ignore
  ignorePrefix: '-',
  ignore: [
    '**/*.test.*'
  ],

  extensions: [],

  build: {
    analyze: false,
    profile: process.argv.includes('--profile'),
    maxChunkSize: false,
    extractCSS: false,
    cssSourceMap: undefined,
    ssr: undefined,
    parallel: false,
    cache: false,
    publicPath: '/_nuxt/',
    filenames: {
      app: '[name].[contenthash].js',
      chunk: '[name].[contenthash].js',
      css: '[name].[contenthash].css'
    },
    styleResources: {},
    plugins: [],
    optimization: {
      splitChunks: {
        chunks: 'all',
        automaticNameDelimiter: '.',
        name: undefined,
        cacheGroups: {}
      }
    },
    splitChunks: {
      layouts: false,
      pages: true,
      commons: true
    },
    babel: {
      babelrc: false,
      cacheDirectory: undefined
    },
    transpile: [], // Name of NPM packages to be transpiled
    vueLoader: {},
    postcss: {},
    templates: [],
    watch: [],
    devMiddleware: {},
    hotMiddleware: {},
    stats: {
      chunks: false,
      children: false,
      modules: false,
      colors: true,
      warnings: true,
      errors: true,
      excludeAssets: [
        /.map$/,
        /index\..+\.html$/,
        /vue-ssr-client-manifest.json/
      ]
    }
  },
  generate: {
    dir: 'dist',
    routes: [],
    concurrency: 500,
    interval: 0,
    subFolders: true,
    fallback: '200.html',
    minify: {
      collapseBooleanAttributes: true,
      collapseWhitespace: false,
      decodeEntities: true,
      minifyCSS: true,
      minifyJS: true,
      processConditionalComments: true,
      removeAttributeQuotes: false,
      removeComments: false,
      removeEmptyAttributes: true,
      removeOptionalTags: true,
      removeRedundantAttributes: true,
      removeScriptTypeAttributes: false,
      removeStyleLinkTypeAttributes: false,
      removeTagWhitespace: false,
      sortAttributes: true,
      sortClassName: false,
      trimCustomFragments: true,
      useShortDoctype: true
    }
  },
  env: {},
  head: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  plugins: [],
  css: [],
  modules: [],
  layouts: {},
  serverMiddleware: [],
  ErrorPage: null,
  loading: {
    color: 'black',
    failedColor: 'red',
    height: '2px',
    duration: 5000,
    rtl: false
  },
  loadingIndicator: 'default',
  transition: {
    name: 'page',
    mode: 'out-in',
    appear: false,
    appearClass: 'appear',
    appearActiveClass: 'appear-active',
    appearToClass: 'appear-to'
  },
  layoutTransition: {
    name: 'layout',
    mode: 'out-in'
  },
  dir: {
    assets: 'assets',
    layouts: 'layouts',
    middleware: 'middleware',
    pages: 'pages',
    static: 'static',
    store: 'store'
  },
  router: {
    mode: 'history',
    base: '/',
    routes: [],
    middleware: [],
    linkActiveClass: 'nuxt-link-active',
    linkExactActiveClass: 'nuxt-link-exact-active',
    extendRoutes: null,
    scrollBehavior: null,
    parseQuery: false,
    stringifyQuery: false,
    fallback: false
  },
  render: {
    bundleRenderer: {
      shouldPrefetch: () => false
    },
    resourceHints: true,
    ssr: undefined,
    http2: {
      push: false,
      shouldPush: null
    },
    static: {
      prefix: true
    },
    gzip: {
      threshold: 0
    },
    etag: {
      weak: false
    },
    csp: false
  },
  watchers: {
    webpack: {},
    chokidar: {}
  },
  editor: undefined,
  hooks: null,
  messages: {
    loading: 'Loading...',
    error_404: 'This page could not be found',
    server_error: 'Server error',
    nuxtjs: 'Nuxt.js',
    back_to_home: 'Back to the home page',
    server_error_details:
      'An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.',
    client_error: 'Error',
    client_error_details:
      'An error occurred while rendering the page. Check developer tools console for details.'
  }
}

const Options = {};

Options.from = function (_options) {
  // Clone options to prevent unwanted side-effects
  const options = Object.assign({}, _options);

  // Normalize options
  if (options.loading === true) {
    delete options.loading;
  }
  if (
    options.router &&
    options.router.middleware &&
    !Array.isArray(options.router.middleware)
  ) {
    options.router.middleware = [options.router.middleware];
  }
  if (options.router && typeof options.router.base === 'string') {
    options._routerBaseSpecified = true;
  }
  if (typeof options.transition === 'string') {
    options.transition = { name: options.transition };
  }
  if (typeof options.layoutTransition === 'string') {
    options.layoutTransition = { name: options.layoutTransition };
  }
  if (typeof options.extensions === 'string') {
    options.extensions = [options.extensions];
  }

  const hasValue = v => typeof v === 'string' && v;
  options.rootDir = hasValue(options.rootDir) ? options.rootDir : process.cwd();

  // Apply defaults by ${buildDir}/dist/build.config.js
  // TODO: Unsafe operation.
  // const buildDir = options.buildDir || defaults.buildDir
  // const buildConfig = resolve(options.rootDir, buildDir, 'build.config.js')
  // if (existsSync(buildConfig)) {
  //   _.defaultsDeep(options, require(buildConfig))
  // }

  // Apply defaults
  ___default.defaultsDeep(options, defaults);

  // Resolve dirs
  options.srcDir = hasValue(options.srcDir)
    ? path.resolve(options.rootDir, options.srcDir)
    : options.rootDir;
  options.buildDir = path.resolve(options.rootDir, options.buildDir);

  // Populate modulesDir
  options.modulesDir = []
    .concat(options.modulesDir)
    .concat(path.join(options.nuxtDir, 'node_modules'))
    .filter(dir => hasValue(dir))
    .map(dir => path.resolve(options.rootDir, dir));

  // Sanitize extensions
  if (options.extensions.indexOf('js') === -1) {
    options.extensions.unshift('js');
  }

  if (options.extensions.indexOf('mjs') === -1) {
    options.extensions.unshift('mjs');
  }

  // If app.html is defined, set the template path to the user template
  options.appTemplatePath = path.resolve(options.buildDir, 'views/app.template.html');
  if (fs.existsSync(path.join(options.srcDir, 'app.html'))) {
    options.appTemplatePath = path.join(options.srcDir, 'app.html');
  }

  // Ignore publicPath on dev
  /* istanbul ignore if */
  if (options.dev && isUrl(options.build.publicPath)) {
    options.build.publicPath = defaults.build.publicPath;
  }

  // If store defined, update store options to true unless explicitly disabled
  if (
    options.store !== false &&
    fs.existsSync(path.join(options.srcDir, options.dir.store)) &&
    fs.readdirSync(path.join(options.srcDir, options.dir.store))
      .find(filename => filename !== 'README.md' && filename[0] !== '.')
  ) {
    options.store = true;
  }

  // SPA loadingIndicator
  if (options.loadingIndicator) {
    // Normalize loadingIndicator
    if (!isPureObject(options.loadingIndicator)) {
      options.loadingIndicator = { name: options.loadingIndicator };
    }

    // Apply defaults
    options.loadingIndicator = Object.assign(
      {
        name: 'default',
        color: (options.loading && options.loading.color) || '#D3D3D3',
        color2: '#F5F5F5',
        background: (options.manifest && options.manifest.theme_color) || 'white',
        dev: options.dev,
        loading: options.messages.loading
      },
      options.loadingIndicator
    );
  }

  // Debug errors
  if (options.debug === undefined) {
    options.debug = options.dev;
  }

  // Apply default hash to CSP option
  const csp = options.render.csp;
  const cspDefaults = {
    hashAlgorithm: 'sha256',
    allowedSources: undefined,
    policies: undefined
  };
  if (csp) {
    options.render.csp = ___default.defaults(___default.isObject(csp) ? csp : {}, cspDefaults);
  }

  // cssSourceMap
  if (options.build.cssSourceMap === undefined) {
    options.build.cssSourceMap = options.dev;
  }

  // babel cacheDirectory
  if (options.build.babel.cacheDirectory === undefined) {
    options.build.babel.cacheDirectory = options.dev;
  }

  // Normalize ignore
  options.ignore = options.ignore ? [].concat(options.ignore) : [];

  // Append ignorePrefix glob to ignore
  if (typeof options.ignorePrefix === 'string') {
    options.ignore.push(`**/${options.ignorePrefix}*.*`);
  }

  // Apply mode preset
  const modePreset = modes[options.mode || 'universal'] || modes['universal'];
  ___default.defaultsDeep(options, modePreset);

  // If no server-side rendering, add appear true transition
  /* istanbul ignore if */
  if (options.render.ssr === false && options.transition) {
    options.transition.appear = true;
  }

  // We assume the SPA fallback path is 404.html (for GitHub Pages, Surge, etc.)
  if (options.generate.fallback === true) {
    options.generate.fallback = '404.html';
  }

  // Enable [name] when analyze or dev mode
  if (options.build.optimization.splitChunks.name === undefined &&
    (options.dev || options.build.analyze)) {
    options.build.optimization.splitChunks.name = true;
  }

  if (options.build.stats === 'none') {
    options.build.stats = false;
  }

  // Vendor backward compatibility with nuxt 1.x
  if (typeof options.build.vendor !== 'undefined') {
    delete options.build.vendor;
    consola.warn('vendor has been deprecated due to webpack4 optimization');
  }

  // TODO: remove when mini-css-extract-plugin supports HMR
  if (options.dev) {
    options.build.extractCSS = false;
  }

  // include SFCs in node_modules
  options.build.transpile = [/\.vue\.js/].concat(options.build.transpile || []);

  return options
};

var name = "nuxt";
var version = "2.0.0";
var description = "A minimalistic framework for server-rendered Vue.js applications (inspired by Next.js)";
var contributors = [
	{
		name: "Sebastien Chopin (@Atinux)"
	},
	{
		name: "Alexandre Chopin (@alexchopin)"
	},
	{
		name: "Pooya Parsa (@pi0)"
	},
	{
		name: "Clark Du (@clarkdo)"
	}
];
var main = "index.js";
var module$1 = "./lib/nuxt.js";
var license = "MIT";
var repository = {
	type: "git",
	url: "git+https://github.com/nuxt/nuxt.js"
};
var files = [
	"bin",
	"lib",
	"dist",
	"index.js"
];
var keywords = [
	"nuxt",
	"nuxt.js",
	"nuxtjs",
	"vue",
	"vue.js",
	"vuejs",
	"vue universal",
	"vue ssr",
	"vue isomorphic",
	"vue versatile"
];
var homepage = "https://github.com/nuxt/nuxt.js#readme";
var bin = {
	nuxt: "./bin/nuxt"
};
var scripts = {
	build: "yarn build:nuxt && yarn build:nuxt-start && yarn build:nuxt-legacy",
	"build:nuxt": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt.js",
	"build:nuxt-legacy": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt-legacy.js",
	"build:nuxt-start": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt-start.js",
	"build:make-start": "node scripts/make-start",
	clean: "rimraf dist",
	coverage: "codecov",
	lint: "eslint --ext .js,.mjs,.vue bin lib test examples",
	postinstall: "opencollective postinstall || exit 0",
	prebuild: "yarn clean",
	security: "nsp check || true",
	test: "yarn test:fixtures && yarn test:unit",
	"test:fixtures": "jest --maxWorkers=4 --forceExit --detectOpenHandles --coverage -e test/fixtures",
	"test:e2e": "jest --maxWorkers=1 --forceExit --detectOpenHandles test/e2e",
	"test:lint": "yarn lint && yarn security",
	"test:unit": "jest --maxWorkers=4 --forceExit --detectOpenHandles --coverage -e test/unit"
};
var engines = {
	node: ">=8.0.0",
	npm: ">=5.0.0"
};
var dependencies = {
	"@nuxtjs/friendly-errors-webpack-plugin": "^2.0.2",
	"@nuxtjs/youch": "^4.2.3",
	autoprefixer: "^8.6.4",
	"babel-core": "^6.26.3",
	"babel-loader": "^7.1.4",
	"babel-preset-vue-app": "^2.0.0",
	"cache-loader": "^1.2.2",
	"caniuse-lite": "^1.0.30000862",
	chalk: "^2.4.1",
	chokidar: "^2.0.3",
	compression: "^1.7.1",
	connect: "^3.6.5",
	consola: "^1.4.1",
	"css-loader": "^0.28.11",
	"es6-promise": "^4.2.4",
	esm: "^3.0.62",
	etag: "^1.8.1",
	"file-loader": "^1.1.11",
	fresh: "^0.5.2",
	"fs-extra": "^6.0.1",
	glob: "^7.1.2",
	"hash-sum": "^1.0.2",
	"html-minifier": "^3.5.16",
	"html-webpack-plugin": "^3.2.0",
	"launch-editor-middleware": "^2.2.1",
	lodash: "^4.17.10",
	"lru-cache": "^4.1.3",
	"memory-fs": "^0.4.1",
	"mini-css-extract-plugin": "^0.4.1",
	minimist: "^1.2.0",
	opencollective: "^1.0.3",
	pify: "^3.0.0",
	postcss: "^6.0.22",
	"postcss-import": "^11.1.0",
	"postcss-import-resolver": "^1.1.0",
	"postcss-loader": "^2.1.5",
	"postcss-preset-env": "^5.1.0",
	"postcss-url": "^7.3.2",
	semver: "^5.5.0",
	"serialize-javascript": "^1.5.0",
	"serve-static": "^1.13.2",
	"server-destroy": "^1.0.1",
	"std-env": "^1.3.0",
	"style-resources-loader": "^1.1.0",
	"thread-loader": "^1.1.5",
	"time-fix-plugin": "^2.0.3",
	"uglifyjs-webpack-plugin": "^1.2.7",
	upath: "^1.1.0",
	"url-loader": "^1.0.1",
	vue: "^2.5.16",
	"vue-loader": "^15.2.2",
	"vue-meta": "^1.5.2",
	"vue-router": "^3.0.1",
	"vue-server-renderer": "^2.5.16",
	"vue-template-compiler": "^2.5.16",
	vuex: "^3.0.1",
	webpack: "^4.14.0",
	"webpack-bundle-analyzer": "^2.13.1",
	"webpack-dev-middleware": "^3.1.3",
	"webpack-hot-middleware": "^2.22.2",
	"webpack-node-externals": "^1.7.2",
	webpackbar: "^2.6.1"
};
var devDependencies = {
	"babel-eslint": "^8.2.1",
	"babel-jest": "^23.0.1",
	"babel-plugin-external-helpers": "^6.22.0",
	"babel-polyfill": "^6.26.0",
	"babel-preset-env": "^1.7.0",
	codecov: "^3.0.2",
	"cross-env": "^5.2.0",
	eslint: "^4.19.1",
	"eslint-config-standard": "^11.0.0",
	"eslint-config-standard-jsx": "^5.0.0",
	"eslint-plugin-import": "^2.12.0",
	"eslint-plugin-jest": "^21.17.0",
	"eslint-plugin-node": "^6.0.0",
	"eslint-plugin-promise": "^3.8.0",
	"eslint-plugin-react": "^7.8.2",
	"eslint-plugin-standard": "^3.1.0",
	"eslint-plugin-vue": "^4.5.0",
	express: "^4.16.2",
	finalhandler: "^1.1.1",
	"get-port": "^3.2.0",
	jest: "^23.1.0",
	jsdom: "^11.11.0",
	nsp: "^3.2.1",
	pug: "^2.0.3",
	"pug-plain-loader": "^1.0.0",
	puppeteer: "^1.5.0",
	request: "^2.87.0",
	"request-promise-native": "^1.0.5",
	rimraf: "^2.6.2",
	rollup: "^0.59.4",
	"rollup-plugin-babel": "^3.0.4",
	"rollup-plugin-commonjs": "^9.1.3",
	"rollup-plugin-json": "^3.0.0"
};
var collective = {
	type: "opencollective",
	url: "https://opencollective.com/nuxtjs",
	logo: "https://opencollective.com/nuxtjs/logo.txt?reverse=true&variant=variant2"
};
var packageJSON = {
	name: name,
	version: version,
	description: description,
	contributors: contributors,
	main: main,
	module: module$1,
	license: license,
	repository: repository,
	files: files,
	keywords: keywords,
	homepage: homepage,
	bin: bin,
	scripts: scripts,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	collective: collective
};

class MetaRenderer {
  constructor(nuxt, renderer) {
    this.nuxt = nuxt;
    this.renderer = renderer;
    this.options = nuxt.options;
    this.vueRenderer = vueServerRenderer.createRenderer();
    this.cache = LRU({});

    // Add VueMeta to Vue (this is only for SPA mode)
    // See lib/app/index.js
    Vue.use(VueMeta, {
      keyName: 'head',
      attribute: 'data-n-head',
      ssrAttribute: 'data-n-head-ssr',
      tagIDKeyName: 'hid'
    });
  }

  async getMeta(url) {
    const vm = new Vue({
      render: h => h(), // Render empty html tag
      head: this.options.head || {}
    });
    await this.vueRenderer.renderToString(vm);
    return vm.$meta().inject()
  }

  async render({ url = '/' }) {
    let meta = this.cache.get(url);

    if (meta) {
      return meta
    }

    meta = {
      HTML_ATTRS: '',
      BODY_ATTRS: '',
      HEAD: '',
      BODY_SCRIPTS: ''
    };

    // Get vue-meta context
    const m = await this.getMeta(url);

    // HTML_ATTRS
    meta.HTML_ATTRS = m.htmlAttrs.text();

    // BODY_ATTRS
    meta.BODY_ATTRS = m.bodyAttrs.text();

    // HEAD tags
    meta.HEAD =
      m.title.text() +
      m.meta.text() +
      m.link.text() +
      m.style.text() +
      m.script.text() +
      m.noscript.text();

    // BODY_SCRIPTS
    meta.BODY_SCRIPTS = m.script.text({ body: true }) + m.noscript.text({ body: true });

    // Resources Hints

    meta.resourceHints = '';

    const clientManifest = this.renderer.resources.clientManifest;

    const shouldPreload = this.options.render.bundleRenderer.shouldPreload || (() => true);
    const shouldPrefetch = this.options.render.bundleRenderer.shouldPrefetch || (() => true);

    if (this.options.render.resourceHints && clientManifest) {
      const publicPath = clientManifest.publicPath || '/_nuxt/';

      // Preload initial resources
      if (Array.isArray(clientManifest.initial)) {
        meta.resourceHints += clientManifest.initial
          .filter(file => shouldPreload(file))
          .map(
            r => `<link rel="preload" href="${publicPath}${r}" as="script" />`
          )
          .join('');
      }

      // Prefetch async resources
      if (Array.isArray(clientManifest.async)) {
        meta.resourceHints += clientManifest.async
          .filter(file => shouldPrefetch(file))
          .map(r => `<link rel="prefetch" href="${publicPath}${r}" />`)
          .join('');
      }

      // Add them to HEAD
      if (meta.resourceHints) {
        meta.HEAD += meta.resourceHints;
      }
    }

    // Emulate getPreloadFiles from vue-server-renderer (works for JS chunks only)
    meta.getPreloadFiles = () =>
      clientManifest.initial
        .filter(file => shouldPreload(file))
        .map(r => ({
          file: r,
          fileWithoutQuery: r,
          asType: 'script',
          extension: 'js'
        }));

    // Set meta tags inside cache
    this.cache.set(url, meta);

    return meta
  }
}

function errorMiddleware(err, req, res, next) {
  // ensure statusCode, message and name fields
  err.statusCode = err.statusCode || 500;
  err.message = err.message || 'Nuxt Server Error';
  err.name = !err.name || err.name === 'Error' ? 'NuxtServerError' : err.name;

  // We hide actual errors from end users, so show them on server logs
  if (err.statusCode !== 404) {
    consola.error(err);
  }

  const sendResponse = (content, type = 'text/html') => {
    // Set Headers
    res.statusCode = err.statusCode;
    res.statusMessage = err.name;
    res.setHeader('Content-Type', type + '; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(content));

    // Send Response
    res.end(content, 'utf-8');
  };

  // Check if request accepts JSON
  const hasReqHeader = (header, includes) =>
    req.headers[header] && req.headers[header].toLowerCase().includes(includes);
  const isJson =
    hasReqHeader('accept', 'application/json') ||
    hasReqHeader('user-agent', 'curl/');

  // Use basic errors when debug mode is disabled
  if (!this.options.debug) {
    // Json format is compatible with Youch json responses
    const json = {
      status: err.statusCode,
      message: err.message,
      name: err.name
    };
    if (isJson) {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
      return
    }
    const html = this.resources.errorTemplate(json);
    sendResponse(html);
    return
  }

  // Show stack trace
  const youch = new Youch(
    err,
    req,
    readSource.bind(this),
    this.options.router.base,
    true
  );
  if (isJson) {
    youch.toJSON().then(json => {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
    });
  } else {
    youch.toHTML().then(html => {
      sendResponse(html);
    });
  }
}

async function readSource(frame) {
  // Remove webpack:/// & query string from the end
  const sanitizeName = name =>
    name ? name.replace('webpack:///', '').split('?')[0] : null;
  frame.fileName = sanitizeName(frame.fileName);

  // Return if fileName is unknown
  /* istanbul ignore if */
  if (!frame.fileName) {
    return
  }

  // Possible paths for file
  const searchPath = [
    this.options.srcDir,
    this.options.rootDir,
    path.join(this.options.buildDir, 'dist'),
    this.options.buildDir,
    process.cwd()
  ];

  // Scan filesystem for real source
  for (let pathDir of searchPath) {
    let fullPath = path.resolve(pathDir, frame.fileName);
    let source = await fsExtra.readFile(fullPath, 'utf-8').catch(() => null);
    if (source) {
      frame.contents = source;
      frame.fullPath = fullPath;
      if (path.isAbsolute(frame.fileName)) {
        frame.fileName = path.relative(this.options.rootDir, fullPath);
      }
      return
    }
  }

  // Fallback: use server bundle
  // TODO: restore to if after https://github.com/istanbuljs/nyc/issues/595 fixed
  /* istanbul ignore next */
  if (!frame.contents) {
    frame.contents = this.resources.serverBundle.files[frame.fileName];
  }
}

async function nuxtMiddleware(req, res, next) {
  // Get context
  const context = getContext(req, res);

  res.statusCode = 200;
  try {
    const result = await this.renderRoute(req.url, context);
    await this.nuxt.callHook('render:route', req.url, result, context);
    const {
      html,
      cspScriptSrcHashes,
      error,
      redirected,
      getPreloadFiles
    } = result;

    if (redirected) {
      return html
    }
    if (error) {
      res.statusCode = context.nuxt.error.statusCode || 500;
    }

    // Add ETag header
    if (!error && this.options.render.etag) {
      const etag = generateETag(html, this.options.render.etag);
      if (fresh(req.headers, { etag })) {
        res.statusCode = 304;
        res.end();
        return
      }
      res.setHeader('ETag', etag);
    }

    // HTTP2 push headers for preload assets
    if (!error && this.options.render.http2.push) {
      // Parse resourceHints to extract HTTP.2 prefetch/push headers
      // https://w3c.github.io/preload/#server-push-http-2
      const pushAssets = [];
      const preloadFiles = getPreloadFiles();
      const { shouldPush } = this.options.render.http2;
      const { publicPath } = this.resources.clientManifest;

      preloadFiles.forEach(({ file, asType, fileWithoutQuery, extension }) => {
        // By default, we only preload scripts or css
        /* istanbul ignore if */
        if (!shouldPush && asType !== 'script' && asType !== 'style') {
          return
        }

        // User wants to explicitly control what to preload
        if (shouldPush && !shouldPush(fileWithoutQuery, asType)) {
          return
        }

        pushAssets.push(`<${publicPath}${file}>; rel=preload; as=${asType}`);
      });

      // Pass with single Link header
      // https://blog.cloudflare.com/http-2-server-push-with-multiple-assets-per-link-header
      // https://www.w3.org/Protocols/9707-link-header.html
      res.setHeader('Link', pushAssets.join(','));
    }

    if (this.options.render.csp) {
      const { allowedSources, policies } = this.options.render.csp;
      let cspStr = `script-src 'self'${this.options.dev ? " 'unsafe-eval'" : ''} ${(cspScriptSrcHashes).join(' ')}`;
      if (Array.isArray(allowedSources)) {
        // For compatible section
        cspStr += ' ' + allowedSources.join(' ');
      } else if (typeof policies === 'object' && policies !== null && !Array.isArray(policies)) {
        // Set default policy if necessary
        if (!policies['script-src'] || !Array.isArray(policies['script-src'])) {
          policies['script-src'] = [`'self'`].concat(cspScriptSrcHashes);
        } else {
          policies['script-src'] = cspScriptSrcHashes.concat(policies['script-src']);
          if (!policies['script-src'].includes(`'self'`)) {
            policies['script-src'] = [`'self'`].concat(policies['script-src']);
          }
        }

        // Make content-security-policy string
        let cspArr = [];
        Object.keys(policies).forEach((k) => {
          cspArr.push(`${k} ${policies[k].join(' ')}`);
        });
        cspStr = cspArr.join('; ');
      }
      res.setHeader('Content-Security-Policy', cspStr);
    }

    // Send response
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(html));
    res.end(html, 'utf8');
    return html
  } catch (err) {
    /* istanbul ignore if */
    if (context && context.redirected) {
      consola.error(err);
      return err
    }

    next(err);
  }
}

let jsdom = null;

class Renderer {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;

    // Will be set by createRenderer
    this.bundleRenderer = null;
    this.metaRenderer = null;

    // Will be available on dev
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;

    // Create new connect instance
    this.app = connect();

    // Renderer runtime resources
    this.resources = {
      clientManifest: null,
      serverBundle: null,
      ssrTemplate: null,
      spaTemplate: null,
      errorTemplate: parseTemplate('Nuxt.js Internal Server Error')
    };
  }

  async ready() {
    await this.nuxt.callHook('render:before', this, this.options.render);
    // Setup nuxt middleware
    await this.setupMiddleware();

    // Production: Load SSR resources from fs
    if (!this.options.dev) {
      await this.loadResources();
    }

    // Call done hook
    await this.nuxt.callHook('render:done', this);
  }

  async loadResources(_fs = fsExtra) {
    let distPath = path.resolve(this.options.buildDir, 'dist');
    let updated = [];

    resourceMap.forEach(({ key, fileName, transform }) => {
      let rawKey = '$$' + key;
      const _path = path.join(distPath, fileName);

      let rawData, data;
      if (!_fs.existsSync(_path)) {
        return // Resource not exists
      }
      rawData = _fs.readFileSync(_path, 'utf8');
      if (!rawData || rawData === this.resources[rawKey]) {
        return // No changes
      }
      this.resources[rawKey] = rawData;
      data = transform(rawData);
      /* istanbul ignore if */
      if (!data) {
        return // Invalid data ?
      }
      this.resources[key] = data;
      updated.push(key);
    });

    // Reload error template
    const errorTemplatePath = path.resolve(this.options.buildDir, 'views/error.html');
    if (fsExtra.existsSync(errorTemplatePath)) {
      this.resources.errorTemplate = parseTemplate(
        fsExtra.readFileSync(errorTemplatePath, 'utf8')
      );
    }

    // Load loading template
    const loadingHTMLPath = path.resolve(this.options.buildDir, 'loading.html');
    if (fsExtra.existsSync(loadingHTMLPath)) {
      this.resources.loadingHTML = fsExtra.readFileSync(loadingHTMLPath, 'utf8');
      this.resources.loadingHTML = this.resources.loadingHTML
        .replace(/\r|\n|[\t\s]{3,}/g, '');
    } else {
      this.resources.loadingHTML = '';
    }

    // Call resourcesLoaded plugin
    await this.nuxt.callHook('render:resourcesLoaded', this.resources);

    if (updated.length > 0) {
      this.createRenderer();
    }
  }

  get noSSR() {
    return this.options.render.ssr === false
  }

  get isReady() {
    if (this.noSSR) {
      return Boolean(this.resources.spaTemplate)
    }

    return Boolean(this.bundleRenderer && this.resources.ssrTemplate)
  }

  get isResourcesAvailable() {
    // Required for both
    /* istanbul ignore if */
    if (!this.resources.clientManifest) {
      return false
    }

    // Required for SPA rendering
    if (this.noSSR) {
      return Boolean(this.resources.spaTemplate)
    }

    // Required for bundle renderer
    return Boolean(this.resources.ssrTemplate && this.resources.serverBundle)
  }

  createRenderer() {
    // Ensure resources are available
    if (!this.isResourcesAvailable) {
      return
    }

    // Create Meta Renderer
    this.metaRenderer = new MetaRenderer(this.nuxt, this);

    // Skip following steps if noSSR mode
    if (this.noSSR) {
      return
    }

    // Create bundle renderer for SSR
    this.bundleRenderer = vueServerRenderer.createBundleRenderer(
      this.resources.serverBundle,
      Object.assign(
        {
          clientManifest: this.resources.clientManifest,
          runInNewContext: false,
          basedir: this.options.rootDir
        },
        this.options.render.bundleRenderer
      )
    );
  }

  useMiddleware(m) {
    // Resolve
    const $m = m;
    let src;
    if (typeof m === 'string') {
      m = this.nuxt.requireModule(m);
    }
    if (typeof m.handler === 'string') {
      m.handler = this.nuxt.requireModule(m.handler);
    }

    const handler = m.handler || m;
    const path$$1 = (
      (m.prefix !== false ? this.options.router.base : '') +
      (typeof m.path === 'string' ? m.path : '')
    ).replace(/\/\//g, '/');

    // Inject $src and $m to final handler
    if (src) handler.$src = src;
    handler.$m = $m;

    // Use middleware
    this.app.use(path$$1, handler);
  }

  get publicPath() {
    return isUrl(this.options.build.publicPath)
      ? defaults.build.publicPath
      : this.options.build.publicPath
  }

  async setupMiddleware() {
    // Apply setupMiddleware from modules first
    await this.nuxt.callHook('render:setupMiddleware', this.app);

    // Gzip middleware for production
    if (!this.options.dev && this.options.render.gzip) {
      this.useMiddleware(compression(this.options.render.gzip));
    }

    // Common URL checks
    this.useMiddleware((req, res, next) => {
      // Prevent access to SSR resources
      if (ssrResourceRegex.test(req.url)) {
        res.statusCode = 404;
        return res.end()
      }
      next();
    });

    // Add webpack middleware only for development
    if (this.options.dev) {
      this.useMiddleware(async (req, res, next) => {
        if (this.webpackDevMiddleware) {
          await this.webpackDevMiddleware(req, res);
        }
        if (this.webpackHotMiddleware) {
          await this.webpackHotMiddleware(req, res);
        }
        next();
      });
    }

    // open in editor for debug mode only
    if (this.options.debug && this.options.dev) {
      this.useMiddleware({
        path: '__open-in-editor',
        handler: launchMiddleware(this.options.editor)
      });
    }

    // For serving static/ files to /
    const staticMiddleware = serveStatic(
      path.resolve(this.options.srcDir, this.options.dir.static),
      this.options.render.static
    );
    staticMiddleware.prefix = this.options.render.static.prefix;
    this.useMiddleware(staticMiddleware);

    // Serve .nuxt/dist/ files only for production
    // For dev they will be served with devMiddleware
    if (!this.options.dev) {
      const distDir = path.resolve(this.options.buildDir, 'dist');
      this.useMiddleware({
        path: this.publicPath,
        handler: serveStatic(distDir, {
          index: false, // Don't serve index.html template
          maxAge: '1y' // 1 year in production
        })
      });
    }

    // Add User provided middleware
    this.options.serverMiddleware.forEach(m => {
      this.useMiddleware(m);
    });

    // Finally use nuxtMiddleware
    this.useMiddleware(nuxtMiddleware.bind(this));

    // Error middleware for errors that occurred in middleware that declared above
    // Middleware should exactly take 4 arguments
    // https://github.com/senchalabs/connect#error-middleware

    // Apply errorMiddleware from modules first
    await this.nuxt.callHook('render:errorMiddleware', this.app);

    // Apply errorMiddleware from Nuxt
    this.useMiddleware(errorMiddleware.bind(this));
  }

  renderTemplate(ssr, opts) {
    // Fix problem with HTMLPlugin's minify option (#3392)
    opts.html_attrs = opts.HTML_ATTRS;
    opts.body_attrs = opts.BODY_ATTRS;

    const fn = ssr ? this.resources.ssrTemplate : this.resources.spaTemplate;

    return fn(opts)
  }

  async renderRoute(url, context = {}) {
    /* istanbul ignore if */
    if (!this.isReady) {
      await waitFor(1000);
      return this.renderRoute(url, context)
    }

    // Log rendered url
    consola.debug(`Rendering url ${url}`);

    // Add url and isSever to the context
    context.url = url;

    // Basic response if SSR is disabled or spa data provided
    const spa = context.spa || (context.res && context.res.spa);
    const ENV = this.options.env;

    if (this.noSSR || spa) {
      const {
        HTML_ATTRS,
        BODY_ATTRS,
        HEAD,
        BODY_SCRIPTS,
        getPreloadFiles
      } = await this.metaRenderer.render(context);
      const APP =
        `<div id="__nuxt">${this.resources.loadingHTML}</div>` + BODY_SCRIPTS;

      // Detect 404 errors
      if (
        url.includes(this.options.build.publicPath) ||
        url.includes('__webpack')
      ) {
        const err = {
          statusCode: 404,
          message: this.options.messages.error_404,
          name: 'ResourceNotFound'
        };
        throw err
      }

      const html = this.renderTemplate(false, {
        HTML_ATTRS,
        BODY_ATTRS,
        HEAD,
        APP,
        ENV
      });

      return { html, getPreloadFiles }
    }

    // Call renderToString from the bundleRenderer and generate the HTML (will update the context as well)
    let APP = await this.bundleRenderer.renderToString(context);

    if (!context.nuxt.serverRendered) {
      APP = '<div id="__nuxt"></div>';
    }
    const m = context.meta.inject();
    let HEAD =
      m.title.text() +
      m.meta.text() +
      m.link.text() +
      m.style.text() +
      m.script.text() +
      m.noscript.text();
    if (this.options._routerBaseSpecified) {
      HEAD += `<base href="${this.options.router.base}">`;
    }

    if (this.options.render.resourceHints) {
      HEAD += context.renderResourceHints();
    }

    await this.nuxt.callHook('render:context', context.nuxt);

    const serializedSession = `window.__NUXT__=${serialize(context.nuxt, {
      isJSON: true
    })};`;

    const cspScriptSrcHashes = [];
    if (this.options.render.csp) {
      const { hashAlgorithm } = this.options.render.csp;
      let hash$$1 = crypto.createHash(hashAlgorithm);
      hash$$1.update(serializedSession);
      cspScriptSrcHashes.push(
        `'${hashAlgorithm}-${hash$$1.digest('base64')}'`
      );
    }

    APP += `<script>${serializedSession}</script>`;
    APP += context.renderScripts();
    APP += m.script.text({ body: true });
    APP += m.noscript.text({ body: true });

    HEAD += context.renderStyles();

    const html = this.renderTemplate(true, {
      HTML_ATTRS: 'data-n-head-ssr ' + m.htmlAttrs.text(),
      BODY_ATTRS: m.bodyAttrs.text(),
      HEAD,
      APP,
      ENV
    });

    return {
      html,
      cspScriptSrcHashes,
      getPreloadFiles: context.getPreloadFiles,
      error: context.nuxt.error,
      redirected: context.redirected
    }
  }

  async renderAndGetWindow(url, opts = {}) {
    /* istanbul ignore if */
    if (!jsdom) {
      try {
        jsdom = require('jsdom');
      } catch (e) /* istanbul ignore next */ {
        consola.error(`
         Fail when calling nuxt.renderAndGetWindow(url)
         jsdom module is not installed
         Please install jsdom with: npm install --save-dev jsdom
        `);
        throw e
      }
    }
    let options = {
      resources: 'usable', // load subresources (https://github.com/tmpvar/jsdom#loading-subresources)
      runScripts: 'dangerously',
      beforeParse(window) {
        // Mock window.scrollTo
        window.scrollTo = () => {};
      }
    };
    const jsdomErrHandler = err => { throw err };
    if (opts.virtualConsole !== false) {
      options.virtualConsole = new jsdom.VirtualConsole().sendTo(consola);
      // throw error when window creation failed
      options.virtualConsole.on('jsdomError', jsdomErrHandler);
    }
    url = url || 'http://localhost:3000';
    const { window } = await jsdom.JSDOM.fromURL(url, options);
    // If Nuxt could not be loaded (error from the server-side)
    const nuxtExists = window.document.body.innerHTML.includes(
      this.options.render.ssr ? 'window.__NUXT__' : '<div id="__nuxt">'
    );
    /* istanbul ignore if */
    if (!nuxtExists) {
      let error = new Error('Could not load the nuxt app');
      error.body = window.document.body.innerHTML;
      throw error
    }
    // Used by nuxt.js to say when the components are loaded and the app ready
    await timeout(new Promise(resolve => {
      window._onNuxtLoaded = () => resolve(window);
    }), 20000, 'Components loading in renderAndGetWindow was not completed in 20s');
    if (opts.virtualConsole !== false) {
      // after window initialized successfully
      options.virtualConsole.removeListener('jsdomError', jsdomErrHandler);
    }
    // Send back window object
    return window
  }
}

const parseTemplate = templateStr =>
  ___default.template(templateStr, {
    interpolate: /{{([\s\S]+?)}}/g
  });

const resourceMap = [
  {
    key: 'clientManifest',
    fileName: 'vue-ssr-client-manifest.json',
    transform: JSON.parse
  },
  {
    key: 'serverBundle',
    fileName: 'server-bundle.json',
    transform: JSON.parse
  },
  {
    key: 'ssrTemplate',
    fileName: 'index.ssr.html',
    transform: parseTemplate
  },
  {
    key: 'spaTemplate',
    fileName: 'index.spa.html',
    transform: parseTemplate
  }
];

// Protector utility against request to SSR bundle files
const ssrResourceRegex = new RegExp(
  resourceMap.map(resource => resource.fileName).join('|'),
  'i'
);

class Nuxt {
  constructor(options = {}) {
    this.options = Options.from(options);

    this.readyMessage = null;
    this.initialized = false;

    // Hooks
    this._hooks = {};
    this.hook = this.hook.bind(this);

    // Create instance of core components
    this.moduleContainer = new ModuleContainer(this);
    this.renderer = new Renderer(this);

    // Backward compatibility
    this.render = this.renderer.app;
    this.renderRoute = this.renderer.renderRoute.bind(this.renderer);
    this.renderAndGetWindow = this.renderer.renderAndGetWindow.bind(
      this.renderer
    );

    // ESM Loader
    this.esm = esm(module, {});

    this._ready = this.ready().catch(err => {
      consola.fatal(err);
    });
  }

  static get version() {
    return packageJSON.version
  }

  async ready() {
    if (this._ready) {
      return this._ready
    }

    // Add hooks
    if (___default.isPlainObject(this.options.hooks)) {
      this.addObjectHooks(this.options.hooks);
    } else if (typeof this.options.hooks === 'function') {
      this.options.hooks(this.hook);
    }

    // Await for modules
    await this.moduleContainer.ready();

    // Await for renderer to be ready
    await this.renderer.ready();

    this.initialized = true;

    // Call ready hook
    await this.callHook('ready', this);

    return this
  }

  hook(name$$1, fn) {
    if (!name$$1 || typeof fn !== 'function') {
      return
    }
    this._hooks[name$$1] = this._hooks[name$$1] || [];
    this._hooks[name$$1].push(fn);
  }

  async callHook(name$$1, ...args) {
    if (!this._hooks[name$$1]) {
      return
    }
    consola.debug(`Call ${name$$1} hooks (${this._hooks[name$$1].length})`);
    try {
      await sequence(this._hooks[name$$1], fn => fn(...args));
    } catch (err) {
      consola.error(err);
      this.callHook('error', err);
    }
  }

  addObjectHooks(hooksObj) {
    Object.keys(hooksObj).forEach(name$$1 => {
      let hooks = hooksObj[name$$1];
      hooks = Array.isArray(hooks) ? hooks : [hooks];

      hooks.forEach(hook => {
        this.hook(name$$1, hook);
      });
    });
  }

  showReady(clear = true) {
    if (!this.readyMessage) {
      return
    }

    consola.ready({
      message: this.readyMessage,
      badge: true,
      clear
    });
  }

  listen(port = 3000, host = 'localhost') {
    return this.ready().then(() => new Promise((resolve, reject) => {
      const server = this.renderer.app.listen(
        { port, host, exclusive: false },
        err => {
          /* istanbul ignore if */
          if (err) {
            return reject(err)
          }

          const listenURL = Chalk.underline.blue(`http://${host}:${port}`);
          this.readyMessage = `Listening on ${listenURL}`;

          // Close server on nuxt close
          this.hook(
            'close',
            () =>
              new Promise((resolve, reject) => {
                // Destroy server by forcing every connection to be closed
                server.destroy(err => {
                  consola.debug('server closed');
                  /* istanbul ignore if */
                  if (err) {
                    return reject(err)
                  }
                  resolve();
                });
              })
          );

          this.callHook('listen', server, { port, host }).then(resolve);
        }
      );

      // Add server.destroy(cb) method
      enableDestroy(server);
    }))
  }

  resolveAlias(_path) {
    if (_path.indexOf('@@') === 0 || _path.indexOf('~~') === 0) {
      return path.join(this.options.rootDir, _path.substr(2))
    }

    if (_path.indexOf('@') === 0 || _path.indexOf('~') === 0) {
      return path.join(this.options.srcDir, _path.substr(1))
    }

    return path.resolve(this.options.srcDir, _path)
  }

  resolvePath(_path) {
    // Try to resolve using NPM resolve path first
    try {
      const resolvedPath = Module._resolveFilename(_path, {
        paths: this.options.modulesDir
      });
      return resolvedPath
    } catch (error) {
      if (error.code !== 'MODULE_NOT_FOUND') {
        throw error
      }
    }

    let __path = this.resolveAlias(_path);

    if (fsExtra.existsSync(__path)) {
      return __path
    }

    for (let ext of this.options.extensions) {
      if (fsExtra.existsSync(__path + '.' + ext)) {
        return __path + '.' + ext
      }
    }

    throw new Error(`Cannot resolve "${_path}" from "${__path}"`)
  }

  requireModule(_path, opts = {}) {
    const _resovledPath = this.resolvePath(_path);
    const m = opts.esm === false ? require(_resovledPath) : this.esm(_resovledPath);
    return (m && m.default) || m
  }

  async close(callback) {
    await this.callHook('close', this);

    /* istanbul ignore if */
    if (typeof callback === 'function') {
      await callback();
    }
  }
}

var core = {
  Nuxt,
  Module: ModuleContainer,
  Renderer
}

// https://github.com/webpack-contrib/thread-loader
// https://github.com/webpack-contrib/cache-loader

class PerfLoader {
  constructor(options) {
    this.options = options;
    this.warmup = threadLoader.warmup;
    this.workerPools = {
      js: {
        name: 'js',
        poolTimeout: this.options.dev ? Infinity : 2000
      },
      css: {
        name: 'css',
        poolTimeout: this.options.dev ? Infinity : 2000
      }
    };
  }

  warmupAll() {
    this.warmup(this.workerPools.js, ['babel-loader', 'babel-preset-env']);
    this.warmup(this.workerPools.css, ['css-loader']);
  }

  pool(poolName, _loaders) {
    const loaders = [].concat(_loaders);

    if (this.options.build.parallel) {
      const pool = this.workerPools[poolName];
    }

    if (this.options.build.cache) {
      loaders.unshift({
        loader: 'cache-loader',
        options: {
          cacheDirectory: path.resolve('node_modules/.cache/cache-loader')
        }
      });
    }

    return loaders
  }

  poolOneOf(poolName, oneOfRules) {
    // disable css thread pool since vue-style-loader needs options like: target
    if (poolName === 'css' && !this.options.build.extractCSS) {
      return oneOfRules
    }
    return oneOfRules.map(rule => Object.assign({}, rule, {
      use: this.pool(poolName, rule.use)
    }))
  }
}

const prefix = `[vue-server-renderer-webpack-plugin]`;
const warn = msg => console.error(Chalk.red(`${prefix} ${msg}\n`)); // eslint-disable-line no-console
const tip = msg => console.log(Chalk.yellow(`${prefix} ${msg}\n`)); // eslint-disable-line no-console

const validate = compiler => {
  if (compiler.options.target !== 'node') {
    warn('webpack config `target` should be "node".');
  }

  if (compiler.options.output && compiler.options.output.libraryTarget !== 'commonjs2') {
    warn('webpack config `output.libraryTarget` should be "commonjs2".');
  }

  if (!compiler.options.externals) {
    tip(
      'It is recommended to externalize dependencies in the server build for ' +
      'better build performance.'
    );
  }
};

const onEmit = (compiler, name, hook) => {
  if (compiler.hooks) {
    // Webpack >= 4.0.0
    compiler.hooks.emit.tapAsync(name, hook);
  } else {
    // Webpack < 4.0.0
    compiler.plugin('emit', hook);
  }
};

const isJS = (file) => /\.js(\?[^.]+)?$/.test(file);

const isCSS = (file) => /\.css(\?[^.]+)?$/.test(file);

class VueSSRClientPlugin {
  constructor(options = {}) {
    this.options = Object.assign({
      filename: 'vue-ssr-client-manifest.json'
    }, options);
  }

  apply(compiler) {
    onEmit(compiler, 'vue-client-plugin', (compilation, cb) => {
      const stats = compilation.getStats().toJson();

      const allFiles = _.uniq(stats.assets
        .map(a => a.name));

      const initialFiles = _.uniq(Object.keys(stats.entrypoints)
        .map(name => stats.entrypoints[name].assets)
        .reduce((assets, all) => all.concat(assets), [])
        .filter((file) => isJS(file) || isCSS(file)));

      const asyncFiles = allFiles
        .filter((file) => isJS(file) || isCSS(file))
        .filter(file => initialFiles.indexOf(file) < 0);

      const manifest = {
        publicPath: stats.publicPath,
        all: allFiles,
        initial: initialFiles,
        async: asyncFiles,
        modules: { /* [identifier: string]: Array<index: number> */ }
      };

      const assetModules = stats.modules.filter(m => m.assets.length);
      const fileToIndex = file => manifest.all.indexOf(file);
      stats.modules.forEach(m => {
        // ignore modules duplicated in multiple chunks
        if (m.chunks.length === 1) {
          const cid = m.chunks[0];
          const chunk = stats.chunks.find(c => c.id === cid);
          if (!chunk || !chunk.files) {
            return
          }
          const id = m.identifier.replace(/\s\w+$/, ''); // remove appended hash
          const files = manifest.modules[hash(id)] = chunk.files.map(fileToIndex);
          // find all asset modules associated with the same chunk
          assetModules.forEach(m => {
            if (m.chunks.some(id => id === cid)) {
              files.push.apply(files, m.assets.map(fileToIndex));
            }
          });
        }
      });

      // const debug = (file, obj) => {
      //   require('fs').writeFileSync(__dirname + '/' + file, JSON.stringify(obj, null, 2))
      // }
      // debug('stats.json', stats)
      // debug('client-manifest.json', manifest)

      const json = JSON.stringify(manifest, null, 2);
      compilation.assets[this.options.filename] = {
        source: () => json,
        size: () => json.length
      };
      cb();
    });
  }
}

class PostcssConfig {
  constructor(options, nuxt) {
    this.nuxt = nuxt;
    this.postcss = options.build.postcss;
    this.srcDir = options.srcDir;
    this.rootDir = options.rootDir;
    this.cssSourceMap = options.build.cssSourceMap;
    this.modulesDir = options.modulesDir;
  }

  get defaultConfig() {
    return {
      useConfigFile: false,
      sourceMap: this.cssSourceMap,
      plugins: {
        // https://github.com/postcss/postcss-import
        'postcss-import': {
          resolve: createResolver({
            alias: {
              '~': path.join(this.srcDir),
              '~~': path.join(this.rootDir),
              '@': path.join(this.srcDir),
              '@@': path.join(this.rootDir)
            },
            modules: [
              this.srcDir,
              this.rootDir,
              ...this.modulesDir
            ]
          })
        },

        // https://github.com/postcss/postcss-url
        'postcss-url': {},

        // https://github.com/csstools/postcss-preset-env
        'postcss-preset-env': {
          // https://cssdb.org/#staging-process
          stage: 2
        }
      }
    }
  }

  configFromFile() {
    // Search for postCSS config file and use it if exists
    // https://github.com/michael-ciniawsky/postcss-load-config
    for (let dir of [this.srcDir, this.rootDir]) {
      for (let file of [
        'postcss.config.js',
        '.postcssrc.js',
        '.postcssrc',
        '.postcssrc.json',
        '.postcssrc.yaml'
      ]) {
        if (fs.existsSync(path.resolve(dir, file))) {
          const postcssConfigPath = path.resolve(dir, file);
          return {
            sourceMap: this.cssSourceMap,
            config: {
              path: postcssConfigPath
            }
          }
        }
      }
    }
  }

  normalize(config) {
    if (Array.isArray(config)) {
      config = { plugins: config };
    }
    return config
  }

  loadPlugins(config) {
    const plugins = config.plugins;
    if (isPureObject(plugins)) {
      // Map postcss plugins into instances on object mode once
      config.plugins = Object.keys(plugins)
        .map(p => {
          const plugin = require(p);
          const opts = plugins[p];
          if (opts === false) return // Disabled
          const instance = plugin(opts);
          return instance
        })
        .filter(e => e);
    }
  }

  config() {
    /* istanbul ignore if */
    if (!this.postcss) {
      return false
    }

    let config = this.configFromFile();
    if (config) {
      return config
    }

    config = this.normalize(___default.cloneDeep(this.postcss));

    // Apply default plugins
    if (isPureObject(config)) {
      ___default.defaults(config, this.defaultConfig);

      this.loadPlugins(config);
    }

    return config
  }
}

class StyleLoader {
  constructor(options, nuxt, { isServer }) {
    this.isServer = isServer;
    this.dev = options.dev;
    this.srcDir = options.srcDir;
    this.assetsDir = options.dir.assets;
    this.staticDir = options.dir.static;
    this.extractCSS = options.build.extractCSS;
    this.resources = options.build.styleResources;
    this.sourceMap = Boolean(options.build.cssSourceMap);

    if (options.build.postcss) {
      this.postcssConfig = new PostcssConfig(options, nuxt);
    }
  }

  normalize(loaders) {
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    return loaders.map(loader => Object.assign(
      { options: { sourceMap: this.sourceMap } },
      typeof loader === 'string' ? { loader } : loader
    ))
  }

  styleResource(ext) {
    const extResource = this.resources[ext];
    // style-resources-loader
    // https://github.com/yenshih/style-resources-loader
    if (extResource) {
      const patterns = Array.isArray(extResource)
        ? extResource
        : [extResource];

      return {
        loader: 'style-resources-loader',
        options: Object.assign(
          { patterns },
          this.resources.options || {}
        )
      }
    }
  }

  postcss() {
    // postcss-loader
    // https://github.com/postcss/postcss-loader
    if (this.postcssConfig) {
      const config = this.postcssConfig.config();
      if (config) {
        return {
          loader: 'postcss-loader',
          options: Object.assign({ sourceMap: this.sourceMap }, config)
        }
      }
    }
  }

  css(importLoaders, options) {
    // css-loader
    // https://github.com/webpack-contrib/css-loader
    const cssLoaderAlias = {
      [`/${this.assetsDir}`]: path.join(this.srcDir, this.assetsDir),
      [`/${this.staticDir}`]: path.join(this.srcDir, this.staticDir)
    };

    return {
      loader: (this.isServer && this.extractCSS) ? 'css-loader/locals' : 'css-loader',
      options: Object.assign({
        sourceMap: this.sourceMap,
        minimize: !this.dev,
        importLoaders: importLoaders,
        alias: cssLoaderAlias
      }, options)
    }
  }

  extract() {
    if (this.extractCSS && !this.isServer) {
      return MiniCssExtractPlugin.loader
    }
  }

  vueStyle() {
    // https://github.com/vuejs/vue-style-loader
    return {
      loader: 'vue-style-loader',
      options: { sourceMap: this.sourceMap }
    }
  }

  apply(ext, loaders = []) {
    const customLoaders = [].concat(
      this.postcss(loaders),
      this.normalize(loaders),
      this.styleResource(ext)
    ).filter(Boolean);

    const styleLoader = this.extract() || this.vueStyle();

    return [
      // This matches <style module>
      {
        resourceQuery: /module/,
        use: [].concat(
          styleLoader,
          this.css(customLoaders.length, {
            modules: true,
            localIdentName: '[local]_[hash:base64:5]'
          }),
          customLoaders
        )
      },
      // This matches plain <style> or <style scoped>
      {
        use: [].concat(
          styleLoader,
          this.css(customLoaders.length),
          customLoaders
        )
      }
    ]
  }
}

class WarnFixPlugin {
  apply(compiler) /* istanbul ignore next */ {
    compiler.hooks.done.tap('warnfix-plugin', stats => {
      stats.compilation.warnings = stats.compilation.warnings.filter(warn => {
        if (
          warn.name === 'ModuleDependencyWarning' &&
          warn.message.includes(`export 'default'`) &&
          warn.message.includes('nuxt_plugin_')
        ) {
          return false
        }
        return true
      });
    });
  }
}

class StatsPlugin {
  constructor(statsOptions) {
    this.statsOptions = statsOptions;
  }

  apply(compiler) {
    compiler.hooks.done.tap('stats-plugin', stats => {
      process.stdout.write(
        '\n' +
          stats.toString(this.statsOptions) +
          '\n'
      );
    });
  }
}

class WebpackBaseConfig {
  constructor(builder, options) {
    this.name = options.name;
    this.isServer = options.isServer;
    this.builder = builder;
    this.nuxt = this.builder.nuxt;
    this.isStatic = builder.isStatic;
    this.options = builder.options;
    this.spinner = builder.spinner;
  }

  getBabelOptions() {
    const options = ___default.clone(this.options.build.babel);

    if (typeof options.presets === 'function') {
      options.presets = options.presets({ isServer: this.isServer });
    }

    if (!options.babelrc && !options.presets) {
      options.presets = [
        [
          require.resolve('babel-preset-vue-app'),
          {
            targets: this.isServer ? { node: 'current' } : { ie: 9, uglify: true }
          }
        ]
      ];
    }

    return options
  }

  getFileName(name) {
    let fileName = this.options.build.filenames[name];

    // Don't use hashes when watching
    // https://github.com/webpack/webpack/issues/1914#issuecomment-174171709
    if (this.options.dev) {
      fileName = fileName.replace(/\[(chunkhash|contenthash|hash)\]\./g, '');
    }

    // Don't use [name] for production assets
    if (!this.options.dev && this.options.build.optimization.splitChunks.name !== true) {
      fileName = fileName.replace(/\[name\]\./g, '');
    }

    return fileName
  }

  env() {
    const env$$1 = {
      'process.mode': JSON.stringify(this.options.mode),
      'process.static': this.isStatic
    };
    ___default.each(this.options.env, (value, key) => {
      env$$1['process.env.' + key] =
        ['boolean', 'number'].indexOf(typeof value) !== -1
          ? value
          : JSON.stringify(value);
    });
    return env$$1
  }

  output() {
    return {
      path: path.resolve(this.options.buildDir, 'dist'),
      filename: this.getFileName('app'),
      chunkFilename: this.getFileName('chunk'),
      publicPath: isUrl(this.options.build.publicPath)
        ? this.options.build.publicPath
        : urlJoin(this.options.router.base, this.options.build.publicPath)
    }
  }

  alias() {
    return {
      '~': path.join(this.options.srcDir),
      '~~': path.join(this.options.rootDir),
      '@': path.join(this.options.srcDir),
      '@@': path.join(this.options.rootDir),
      [this.options.dir.assets]: path.join(
        this.options.srcDir,
        this.options.dir.assets
      ),
      [this.options.dir.static]: path.join(
        this.options.srcDir,
        this.options.dir.static
      )
    }
  }

  rules() {
    const styleLoader = new StyleLoader(
      this.options,
      this.builder.nuxt,
      { isServer: this.isServer }
    );

    const perfLoader = this.builder.perfLoader;

    return [
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: Object.assign({
          productionMode: !this.options.dev,
          transformAssetUrls: {
            video: 'src',
            source: 'src',
            object: 'src',
            embed: 'src'
          }
        }, this.options.build.vueLoader)
      },
      {
        test: /\.pug$/,
        oneOf: [
          {
            resourceQuery: /^\?vue/,
            use: ['pug-plain-loader']
          },
          {
            use: ['raw-loader', 'pug-plain-loader']
          }
        ]
      },
      {
        test: /\.jsx?$/,
        exclude: file => {
          // not exclude files outside node_modules
          if (/node_modules/.test(file)) {
            for (let pkg of this.options.build.transpile) {
              // item in transpile can be string or regex object
              if (new RegExp(pkg).test(file)) {
                return false
              }
            }
            return true
          }
        },
        use: perfLoader.pool('js', {
          loader: 'babel-loader',
          options: this.getBabelOptions()
        })
      },
      {
        test: /\.css$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('css'))
      },
      {
        test: /\.less$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('less', 'less-loader'))
      },
      {
        test: /\.sass$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('sass', {
          loader: 'sass-loader',
          options: { indentedSyntax: true }
        }))
      },
      {
        test: /\.scss$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('scss', 'sass-loader'))
      },
      {
        test: /\.styl(us)?$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('stylus', 'stylus-loader'))
      },
      {
        test: /\.(png|jpe?g|gif|svg)$/,
        use: perfLoader.pool('assets', {
          loader: 'url-loader',
          options: {
            limit: 1000, // 1KO
            name: 'img/[name].[hash:7].[ext]'
          }
        })
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        use: perfLoader.pool('assets', {
          loader: 'url-loader',
          options: {
            limit: 1000, // 1 KO
            name: 'fonts/[name].[hash:7].[ext]'
          }
        })
      },
      {
        test: /\.(webm|mp4)$/,
        use: perfLoader.pool('assets', {
          loader: 'file-loader',
          options: {
            name: 'videos/[name].[hash:7].[ext]'
          }
        })
      }
    ]
  }

  plugins() {
    const plugins = [ new VueLoader.VueLoaderPlugin() ];

    Array.prototype.push.apply(plugins, this.options.build.plugins || []);

    // Add timefix-plugin before others plugins
    if (this.options.dev) {
      plugins.unshift(new TimeFixPlugin());
    }

    // Hide warnings about plugins without a default export (#1179)
    plugins.push(new WarnFixPlugin());

    // Build progress indicator
    plugins.push(new WebpackBar({
      profile: this.options.build.profile,
      name: this.isServer ? 'server' : 'client',
      color: this.isServer ? 'orange' : 'green',
      compiledIn: false,
      done: (states) => {
        if (this.options.dev) {
          const hasErrors = Object.values(states).some(state => state.stats.hasErrors());

          if (!hasErrors) {
            this.nuxt.showReady();
          }
        }
      }
    }));

    // Add stats plugin
    if (!this.options.dev && this.options.build.stats) {
      plugins.push(new StatsPlugin(this.options.build.stats));
    }

    // CSS extraction
    // MiniCssExtractPlugin does not currently supports SSR
    // https://github.com/webpack-contrib/mini-css-extract-plugin/issues/48
    // So we use css-loader/locals as a fallback (utils/style-loader)
    if (this.options.build.extractCSS && !this.isServer) {
      plugins.push(new MiniCssExtractPlugin(Object.assign({
        filename: this.getFileName('css'),
        chunkFilename: this.getFileName('css')
      }, this.options.build.extractCSS)));
    }

    return plugins
  }

  config() {
    // Prioritize nested node_modules in webpack search path (#2558)
    const webpackModulesDir = ['node_modules'].concat(this.options.modulesDir);
    const config = {
      name: this.name,
      mode: this.options.dev ? 'development' : 'production',
      optimization: {},
      output: this.output(),
      performance: {
        maxEntrypointSize: 1000 * 1024,
        hints: this.options.dev ? false : 'warning'
      },
      resolve: {
        extensions: ['.wasm', '.mjs', '.js', '.json', '.vue', '.jsx'],
        alias: this.alias(),
        modules: webpackModulesDir
      },
      resolveLoader: {
        modules: webpackModulesDir
      },
      module: {
        noParse: /es6-promise\.js$/, // Avoid webpack shimming process
        rules: this.rules()
      },
      plugins: this.plugins()
    };

    // Clone deep avoid leaking config between Client and Server
    return ___default.cloneDeep(config)
  }
}

class WebpackClientConfig extends WebpackBaseConfig {
  constructor(builder) {
    super(builder, { name: 'client', isServer: false });
  }

  env() {
    return Object.assign(super.env(), {
      'process.env.VUE_ENV': JSON.stringify('client'),
      'process.browser': true,
      'process.client': true,
      'process.server': false
    })
  }

  plugins() {
    const plugins = super.plugins();

    // Generate output HTML for SSR
    if (this.options.build.ssr) {
      plugins.push(
        new HTMLPlugin({
          filename: 'index.ssr.html',
          template: this.options.appTemplatePath,
          minify: true,
          inject: false // Resources will be injected using bundleRenderer
        })
      );
    }

    plugins.push(
      new HTMLPlugin({
        filename: 'index.spa.html',
        template: this.options.appTemplatePath,
        minify: true,
        inject: true,
        chunksSortMode: 'dependency'
      }),
      new VueSSRClientPlugin({
        filename: 'vue-ssr-client-manifest.json'
      }),
      new webpack.DefinePlugin(this.env())
    );

    if (this.options.dev) {
      // TODO: webpackHotUpdate is not defined: https://github.com/webpack/webpack/issues/6693
      plugins.push(new webpack.HotModuleReplacementPlugin());
    }

    // Chunks size limit
    // https://webpack.js.org/plugins/aggressive-splitting-plugin/
    if (!this.options.dev && this.options.build.maxChunkSize) {
      plugins.push(
        new webpack.optimize.AggressiveSplittingPlugin({
          minSize: this.options.build.maxChunkSize,
          maxSize: this.options.build.maxChunkSize
        })
      );
    }

    // Webpack Bundle Analyzer
    // https://github.com/webpack-contrib/webpack-bundle-analyzer
    if (!this.options.dev && this.options.build.analyze) {
      const statsDir = path.resolve(this.options.buildDir, 'stats');

      plugins.push(new BundleAnalyzer.BundleAnalyzerPlugin(Object.assign({
        analyzerMode: 'static',
        defaultSizes: 'gzip',
        generateStatsFile: true,
        openAnalyzer: !(this.options.ci || this.options.test),
        reportFilename: path.resolve(statsDir, 'client.html'),
        statsFilename: path.resolve(statsDir, 'client.json')
      }, this.options.build.analyze)));
    }

    return plugins
  }

  config() {
    let config = super.config();

    // Entry points
    config.entry = path.resolve(this.options.buildDir, 'client.js');

    // -- Optimization --
    config.optimization = this.options.build.optimization;

    // Small, known and common modules which are usually used project-wise
    // Sum of them may not be more than 244 KiB
    if (
      this.options.build.splitChunks.commons === true &&
      config.optimization.splitChunks.cacheGroups.commons === undefined
    ) {
      config.optimization.splitChunks.cacheGroups.commons = {
        test: /node_modules[\\/](vue|vue-loader|vue-router|vuex|vue-meta|core-js|babel-runtime|es6-promise|axios|webpack|setimmediate|timers-browserify|process|regenerator-runtime|cookie|js-cookie|is-buffer|dotprop|nuxt\.js)[\\/]/,
        chunks: 'all',
        priority: 10,
        name: 'commons'
      };
    }

    // Make uglifyjs faster
    if (!this.options.dev && !config.optimization.minimizer) {
      // https://github.com/webpack-contrib/uglifyjs-webpack-plugin
      config.optimization.minimizer = [
        new UglifyJsWebpackPlugin({
          parallel: true,
          cache: this.options.build.cache,
          sourceMap: false,
          extractComments: {
            filename: 'LICENSES'
          },
          uglifyOptions: {
            output: {
              comments: /^\**!|@preserve|@license|@cc_on/
            }
          }
        })
      ];
    }

    // Add HMR support
    if (this.options.dev) {
      config.entry = [
        // https://github.com/glenjamin/webpack-hot-middleware#config
        `webpack-hot-middleware/client?name=client&reload=true&timeout=30000&path=${
          this.options.router.base
        }/__webpack_hmr`.replace(/\/\//g, '/'),
        config.entry
      ];
    }

    // Add friendly error plugin
    if (this.options.dev) {
      config.plugins.push(
        new FriendlyErrorsWebpackPlugin({
          clearConsole: true,
          logLevel: 'WARNING'
        })
      );
    }

    // Extend config
    if (typeof this.options.build.extend === 'function') {
      const isDev = this.options.dev;
      const extendedConfig = this.options.build.extend.call(this.builder, config, {
        isDev,
        isClient: true
      });

      // Only overwrite config when something is returned for backwards compatibility
      if (extendedConfig !== undefined) {
        config = extendedConfig;
      }
    }

    return config
  }
}

class VueSSRServerPlugin {
  constructor(options = {}) {
    this.options = Object.assign({
      filename: 'vue-ssr-server-bundle.json'
    }, options);
  }

  apply(compiler) {
    validate(compiler);

    onEmit(compiler, 'vue-server-plugin', (compilation, cb) => {
      const stats = compilation.getStats().toJson();
      const entryName = Object.keys(stats.entrypoints)[0];
      const entryInfo = stats.entrypoints[entryName];

      if (!entryInfo) {
        // #5553
        return cb()
      }

      const entryAssets = entryInfo.assets.filter(isJS);

      if (entryAssets.length > 1) {
        throw new Error(
          `Server-side bundle should have one single entry file. ` +
          `Avoid using CommonsChunkPlugin in the server config.`
        )
      }

      const entry = entryAssets[0];
      if (!entry || typeof entry !== 'string') {
        throw new Error(
          `Entry "${entryName}" not found. Did you specify the correct entry option?`
        )
      }

      const bundle = {
        entry,
        files: {},
        maps: {}
      };

      stats.assets.forEach(asset => {
        if (asset.name.match(/\.js$/)) {
          bundle.files[asset.name] = compilation.assets[asset.name].source();
        } else if (asset.name.match(/\.js\.map$/)) {
          bundle.maps[asset.name.replace(/\.map$/, '')] = JSON.parse(compilation.assets[asset.name].source());
        }
        // do not emit anything else for server
        delete compilation.assets[asset.name];
      });

      const json = JSON.stringify(bundle, null, 2);
      const filename = this.options.filename;

      compilation.assets[filename] = {
        source: () => json,
        size: () => json.length
      };

      cb();
    });
  }
}

class WebpackServerConfig extends WebpackBaseConfig {
  constructor(builder) {
    super(builder, { name: 'server', isServer: true });
  }

  env() {
    return Object.assign(super.env(), {
      'process.env.VUE_ENV': JSON.stringify('server'),
      'process.browser': false,
      'process.client': false,
      'process.server': true
    })
  }

  plugins() {
    const plugins = super.plugins();
    plugins.push(
      new VueSSRServerPlugin({
        filename: 'server-bundle.json'
      }),
      new webpack.DefinePlugin(this.env())
    );
    return plugins
  }

  config() {
    let config = super.config();

    // Config devtool
    config.devtool = 'cheap-source-map';

    Object.assign(config, {
      target: 'node',
      node: false,
      entry: path.resolve(this.options.buildDir, 'server.js'),
      output: Object.assign({}, config.output, {
        filename: 'server-bundle.js',
        libraryTarget: 'commonjs2'
      }),
      performance: {
        hints: false,
        maxAssetSize: Infinity
      },
      externals: [],
      optimization: {
        splitChunks: false,
        minimizer: []
      }
    });

    // https://webpack.js.org/configuration/externals/#externals
    // https://github.com/liady/webpack-node-externals
    // https://vue-loader.vuejs.org/migrating.html#ssr-externals
    this.options.modulesDir.forEach(dir => {
      if (fs.existsSync(dir)) {
        config.externals.push(
          nodeExternals({
            whitelist: [
              /es6-promise|\.(?!(?:js|json)$).{1,5}$/i,
              /\.css$/,
              /\?vue&type=style/
            ],
            modulesDir: dir
          })
        );
      }
    });

    // Extend config
    if (typeof this.options.build.extend === 'function') {
      const isDev = this.options.dev;
      const extendedConfig = this.options.build.extend.call(this.builder, config, {
        isDev,
        isServer: true
      });
      // Only overwrite config when something is returned for backwards compatibility
      if (extendedConfig !== undefined) {
        config = extendedConfig;
      }
    }

    return config
  }
}

const glob = pify(Glob);

class Builder {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.isStatic = false; // Flag to know if the build is for a generated app
    this.options = nuxt.options;

    // Fields that set on build
    this.compilers = [];
    this.compilersWatching = [];
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;
    this.filesWatcher = null;
    this.customFilesWatcher = null;
    this.perfLoader = null;

    // Helper to resolve build paths
    this.relativeToBuild = (...args) =>
      relativeTo(this.options.buildDir, ...args);

    this._buildStatus = STATUS.INITIAL;

    // Stop watching on nuxt.close()
    if (this.options.dev) {
      this.nuxt.hook('close', () => this.unwatch());
    }

    // Initialize shared FS and Cache
    if (this.options.dev) {
      this.mfs = new MFS();
    }

    // if(!this.options.dev) {
    // TODO: enable again when unsafe concern resolved.(common/options.js:42)
    // this.nuxt.hook('build:done', () => this.generateConfig())
    // }
  }

  get plugins() {
    return ___default.uniqBy(
      this.options.plugins.map((p, i) => {
        if (typeof p === 'string') p = { src: p };
        const pluginBaseName = path.basename(p.src, path.extname(p.src)).replace(
          /[^a-zA-Z?\d\s:]/g,
          ''
        );
        return {
          src: this.nuxt.resolveAlias(p.src),
          ssr: p.ssr !== false,
          name: 'nuxt_plugin_' + pluginBaseName + '_' + hash(p.src)
        }
      }),
      p => p.name
    )
  }

  forGenerate() {
    this.isStatic = true;
  }

  async build() {
    // Avoid calling build() method multiple times when dev:true
    /* istanbul ignore if */
    if (this._buildStatus === STATUS.BUILD_DONE && this.options.dev) {
      return this
    }
    // If building
    /* istanbul ignore if */
    if (this._buildStatus === STATUS.BUILDING) {
      await waitFor(1000);
      return this.build()
    }
    this._buildStatus = STATUS.BUILDING;

    consola.info({
      message: 'Building project',
      badge: true,
      clear: true
    });

    // Wait for nuxt ready
    await this.nuxt.ready();

    // Call before hook
    await this.nuxt.callHook('build:before', this, this.options.build);

    // Check if pages dir exists and warn if not
    this._nuxtPages = typeof this.options.build.createRoutes !== 'function';
    if (this._nuxtPages) {
      if (!fsExtra.existsSync(path.join(this.options.srcDir, this.options.dir.pages))) {
        let dir = this.options.srcDir;
        if (fsExtra.existsSync(path.join(this.options.srcDir, '..', this.options.dir.pages))) {
          throw new Error(
            `No \`${this.options.dir.pages}\` directory found in ${dir}. Did you mean to run \`nuxt\` in the parent (\`../\`) directory?`
          )
        } else {
          this._defaultPage = true;
        }
      }
    }

    consola.success('Builder initialized');

    consola.debug(`App root: ${this.options.srcDir}`);

    // Create .nuxt/, .nuxt/components and .nuxt/dist folders
    await fsExtra.remove(r(this.options.buildDir));
    await fsExtra.mkdirp(r(this.options.buildDir, 'components'));
    if (!this.options.dev) {
      await fsExtra.mkdirp(r(this.options.buildDir, 'dist'));
    }

    // Generate routes and interpret the template files
    await this.generateRoutesAndFiles();

    // Start webpack build
    await this.webpackBuild();

    // Flag to set that building is done
    this._buildStatus = STATUS.BUILD_DONE;

    // Call done hook
    await this.nuxt.callHook('build:done', this);

    return this
  }

  async generateRoutesAndFiles() {
    consola.debug(`Generating nuxt files`);

    // -- Templates --
    let templatesFiles = [
      'App.js',
      'client.js',
      'index.js',
      'middleware.js',
      'router.js',
      'server.js',
      'utils.js',
      'empty.js',
      'components/nuxt-error.vue',
      'components/nuxt-loading.vue',
      'components/nuxt-child.js',
      'components/nuxt-link.js',
      'components/nuxt.js',
      'components/no-ssr.js',
      'views/app.template.html',
      'views/error.html'
    ];
    const templateVars = {
      options: this.options,
      extensions: this.options.extensions
        .map(ext => ext.replace(/^\./, ''))
        .join('|'),
      messages: this.options.messages,
      splitChunks: this.options.build.splitChunks,
      uniqBy: ___default.uniqBy,
      isDev: this.options.dev,
      debug: this.options.debug,
      mode: this.options.mode,
      router: this.options.router,
      env: this.options.env,
      head: this.options.head,
      middleware: fsExtra.existsSync(path.join(this.options.srcDir, this.options.dir.middleware)),
      store: this.options.store,
      css: this.options.css,
      plugins: this.plugins,
      appPath: './App.js',
      ignorePrefix: this.options.ignorePrefix,
      layouts: Object.assign({}, this.options.layouts),
      loading:
        typeof this.options.loading === 'string'
          ? this.relativeToBuild(this.options.srcDir, this.options.loading)
          : this.options.loading,
      transition: this.options.transition,
      layoutTransition: this.options.layoutTransition,
      dir: this.options.dir,
      components: {
        ErrorPage: this.options.ErrorPage
          ? this.relativeToBuild(this.options.ErrorPage)
          : null
      }
    };

    // -- Layouts --
    if (fsExtra.existsSync(path.resolve(this.options.srcDir, this.options.dir.layouts))) {
      const layoutsFiles = await glob(`${this.options.dir.layouts}/**/*.{vue,js}`, {
        cwd: this.options.srcDir,
        ignore: this.options.ignore
      });
      let hasErrorLayout = false;
      layoutsFiles.forEach(file => {
        let name = file
          .split('/')
          .slice(1)
          .join('/')
          .replace(/\.(vue|js)$/, '');
        if (name === 'error') {
          hasErrorLayout = true;
          return
        }
        if (!templateVars.layouts[name] || /\.vue$/.test(file)) {
          templateVars.layouts[name] = this.relativeToBuild(
            this.options.srcDir,
            file
          );
        }
      });
      if (!templateVars.components.ErrorPage && hasErrorLayout) {
        templateVars.components.ErrorPage = this.relativeToBuild(
          this.options.srcDir,
          `${this.options.dir.layouts}/error.vue`
        );
      }
    }
    // If no default layout, create its folder and add the default folder
    if (!templateVars.layouts.default) {
      await fsExtra.mkdirp(r(this.options.buildDir, 'layouts'));
      templatesFiles.push('layouts/default.vue');
      templateVars.layouts.default = './layouts/default.vue';
    }

    // -- Routes --
    consola.debug('Generating routes...');

    if (this._defaultPage) {
      templateVars.router.routes = createRoutes(
        ['index.vue'],
        this.options.nuxtAppDir + '/pages'
      );
    } else if (this._nuxtPages) { // If user defined a custom method to create routes
      // Use nuxt.js createRoutes bases on pages/
      const files = {}
      ;(await glob(`${this.options.dir.pages}/**/*.{vue,js}`, {
        cwd: this.options.srcDir,
        ignore: this.options.ignore
      })).forEach(f => {
        const key = f.replace(/\.(js|vue)$/, '');
        if (/\.vue$/.test(f) || !files[key]) {
          files[key] = f.replace(/(['|"])/g, '\\$1');
        }
      });
      templateVars.router.routes = createRoutes(
        Object.values(files),
        this.options.srcDir,
        this.options.dir.pages
      );
    } else {
      templateVars.router.routes = this.options.build.createRoutes(
        this.options.srcDir
      );
    }

    await this.nuxt.callHook(
      'build:extendRoutes',
      templateVars.router.routes,
      r
    );

    // router.extendRoutes method
    if (typeof this.options.router.extendRoutes === 'function') {
      // let the user extend the routes
      const extendedRoutes = this.options.router.extendRoutes(
        templateVars.router.routes,
        r
      );
      // Only overwrite routes when something is returned for backwards compatibility
      if (extendedRoutes !== undefined) {
        templateVars.router.routes = extendedRoutes;
      }
    }

    // Make routes accessible for other modules and webpack configs
    this.routes = templateVars.router.routes;

    // -- Store --
    // Add store if needed
    if (this.options.store) {
      templatesFiles.push('store.js');
    }

    // Resolve template files
    const customTemplateFiles = this.options.build.templates.map(
      t => t.dst || path.basename(t.src || t)
    );

    templatesFiles = templatesFiles
      .map(file => {
        // Skip if custom file was already provided in build.templates[]
        if (customTemplateFiles.indexOf(file) !== -1) {
          return
        }
        // Allow override templates using a file with same name in ${srcDir}/app
        const customPath = r(this.options.srcDir, 'app', file);
        const customFileExists = fsExtra.existsSync(customPath);

        return {
          src: customFileExists ? customPath : r(this.options.nuxtAppDir, file),
          dst: file,
          custom: customFileExists
        }
      })
      .filter(i => !!i);

    // -- Custom templates --
    // Add custom template files
    templatesFiles = templatesFiles.concat(
      this.options.build.templates.map(t => {
        return Object.assign(
          {
            src: r(this.options.srcDir, t.src || t),
            dst: t.dst || path.basename(t.src || t),
            custom: true
          },
          t
        )
      })
    );

    // -- Loading indicator --
    if (this.options.loadingIndicator.name) {
      const indicatorPath1 = path.resolve(
        this.options.nuxtAppDir,
        'views/loading',
        this.options.loadingIndicator.name + '.html'
      );
      const indicatorPath2 = this.nuxt.resolveAlias(
        this.options.loadingIndicator.name
      );
      const indicatorPath = fsExtra.existsSync(indicatorPath1)
        ? indicatorPath1
        : fsExtra.existsSync(indicatorPath2) ? indicatorPath2 : null;
      if (indicatorPath) {
        templatesFiles.push({
          src: indicatorPath,
          dst: 'loading.html',
          options: this.options.loadingIndicator
        });
      } else {
        /* istanbul ignore next */
        // eslint-disable-next-line no-console
        console.error(
          `Could not fetch loading indicator: ${
            this.options.loadingIndicator.name
          }`
        );
      }
    }

    await this.nuxt.callHook('build:templates', {
      templatesFiles,
      templateVars,
      resolve: r
    });

    // Interpret and move template files to .nuxt/
    await Promise.all(
      templatesFiles.map(async ({ src, dst, options, custom }) => {
        // Add template to watchers
        this.options.build.watch.push(src);
        // Render template to dst
        const fileContent = await fsExtra.readFile(src, 'utf8');
        let content;
        try {
          const template = ___default.template(fileContent, {
            imports: {
              serialize,
              hash,
              r,
              wp,
              wChunk,
              resolvePath: this.nuxt.resolvePath.bind(this.nuxt),
              resolveAlias: this.nuxt.resolveAlias.bind(this.nuxt),
              relativeToBuild: this.relativeToBuild
            }
          });
          content = template(
            Object.assign({}, templateVars, {
              options: options || {},
              custom,
              src,
              dst
            })
          );
        } catch (err) {
          /* istanbul ignore next */
          throw new Error(`Could not compile template ${src}: ${err.message}`)
        }
        const _path = r(this.options.buildDir, dst);
        // Ensure parent dir exits
        await fsExtra.mkdirp(path.dirname(_path));
        // Write file
        await fsExtra.writeFile(_path, content, 'utf8');
      })
    );

    consola.success('Nuxt files generated');
  }

  async webpackBuild() {
    this.perfLoader = new PerfLoader(this.options);

    const compilersOptions = [];

    // Client
    const clientConfig = new WebpackClientConfig(this).config();
    compilersOptions.push(clientConfig);

    // Server
    let serverConfig = null;
    if (this.options.build.ssr) {
      serverConfig = new WebpackServerConfig(this).config();
      compilersOptions.push(serverConfig);
    }

    // Alias plugins to their real path
    this.plugins.forEach(p => {
      const src = this.relativeToBuild(p.src);

      // Client config
      if (!clientConfig.resolve.alias[p.name]) {
        clientConfig.resolve.alias[p.name] = src;
      }

      // Server config
      if (serverConfig && !serverConfig.resolve.alias[p.name]) {
        // Alias to noop for ssr:false plugins
        serverConfig.resolve.alias[p.name] = p.ssr ? src : './empty.js';
      }
    });

    // Configure compilers
    this.compilers = compilersOptions.map(compilersOption => {
      const compiler = webpack(compilersOption);

      // In dev, write files in memory FS
      if (this.options.dev) {
        compiler.outputFileSystem = this.mfs;
      }

      return compiler
    });

    // Warmup perfLoader before build
    if (this.options.build.parallel) {
      consola.info('Warming up worker pools');
      this.perfLoader.warmupAll();
      consola.success('Worker pools ready');
    }

    // Start Builds
    const runner = this.options.dev ? parallel : sequence;

    await runner(this.compilers, compiler => {
      return this.webpackCompile(compiler)
    });
  }

  webpackCompile(compiler) {
    return new Promise(async (resolve, reject) => {
      const name = compiler.options.name;

      await this.nuxt.callHook('build:compile', { name, compiler });

      // Load renderer resources after build
      compiler.hooks.done.tap('load-resources', async stats => {
        await this.nuxt.callHook('build:compiled', {
          name,
          compiler,
          stats
        });

        // Reload renderer if available
        this.nuxt.renderer.loadResources(this.mfs || fs);

        // Resolve on next tick
        process.nextTick(resolve);
      });

      if (this.options.dev) {
        // --- Dev Build ---
        // Client Build, watch is started by dev-middleware
        if (compiler.options.name === 'client') {
          return this.webpackDev(compiler)
        }
        // Server, build and watch for changes
        this.compilersWatching.push(
          compiler.watch(this.options.watchers.webpack, err => {
            /* istanbul ignore if */
            if (err) return reject(err)
          })
        );
      } else {
        // --- Production Build ---
        compiler.run((err, stats) => {
          /* istanbul ignore next */
          if (err) {
            return reject(err)
          } else if (stats.hasErrors()) {
            if (this.options.test) {
              err = stats.toString(this.options.build.stats);
            }

            return reject(err)
          }

          resolve();
        });
      }
    })
  }

  webpackDev(compiler) {
    consola.debug('Adding webpack middleware...');

    // Create webpack dev middleware
    this.webpackDevMiddleware = pify(
      webpackDevMiddleware(
        compiler,
        Object.assign(
          {
            publicPath: this.options.build.publicPath,
            stats: false,
            logLevel: 'silent',
            watchOptions: this.options.watchers.webpack
          },
          this.options.build.devMiddleware
        )
      )
    );

    this.webpackDevMiddleware.close = pify(this.webpackDevMiddleware.close);

    this.webpackHotMiddleware = pify(
      webpackHotMiddleware(
        compiler,
        Object.assign(
          {
            log: false,
            heartbeat: 10000
          },
          this.options.build.hotMiddleware
        )
      )
    );

    // Inject to renderer instance
    if (this.nuxt.renderer) {
      this.nuxt.renderer.webpackDevMiddleware = this.webpackDevMiddleware;
      this.nuxt.renderer.webpackHotMiddleware = this.webpackHotMiddleware;
    }

    // Start watching files
    this.watchFiles();
  }

  watchFiles() {
    const src = this.options.srcDir;
    let patterns = [
      r(src, this.options.dir.layouts),
      r(src, this.options.dir.store),
      r(src, this.options.dir.middleware),
      r(src, `${this.options.dir.layouts}/*.{vue,js}`),
      r(src, `${this.options.dir.layouts}/**/*.{vue,js}`)
    ];
    if (this._nuxtPages) {
      patterns.push(
        r(src, this.options.dir.pages),
        r(src, `${this.options.dir.pages}/*.{vue,js}`),
        r(src, `${this.options.dir.pages}/**/*.{vue,js}`)
      );
    }
    patterns = ___default.map(patterns, p => upath.normalizeSafe(p));

    const options = Object.assign({}, this.options.watchers.chokidar, {
      ignoreInitial: true
    });
    /* istanbul ignore next */
    const refreshFiles = ___default.debounce(() => this.generateRoutesAndFiles(), 200);

    // Watch for src Files
    this.filesWatcher = chokidar
      .watch(patterns, options)
      .on('add', refreshFiles)
      .on('unlink', refreshFiles);

    // Watch for custom provided files
    let customPatterns = ___default.concat(
      this.options.build.watch,
      ...___default.values(___default.omit(this.options.build.styleResources, ['options']))
    );
    customPatterns = ___default.map(___default.uniq(customPatterns), p =>
      upath.normalizeSafe(p)
    );
    this.customFilesWatcher = chokidar
      .watch(customPatterns, options)
      .on('change', refreshFiles);
  }

  async unwatch() {
    if (this.filesWatcher) {
      this.filesWatcher.close();
    }

    if (this.customFilesWatcher) {
      this.customFilesWatcher.close();
    }

    this.compilersWatching.forEach(watching => watching.close());

    // Stop webpack middleware
    if (this.webpackDevMiddleware) {
      await this.webpackDevMiddleware.close();
    }
  }

  // TODO: remove ignore when generateConfig enabled again
  async generateConfig() /* istanbul ignore next */ {
    const config = path.resolve(this.options.buildDir, 'build.config.js');
    const options = ___default.omit(this.options, Options.unsafeKeys);
    await fsExtra.writeFile(
      config,
      `export default ${JSON.stringify(options, null, '  ')}`,
      'utf8'
    );
  }
}

const STATUS = {
  INITIAL: 1,
  BUILD_DONE: 2,
  BUILDING: 3
};

class Generator {
  constructor(nuxt, builder) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.builder = builder;

    // Set variables
    this.staticRoutes = path.resolve(this.options.srcDir, this.options.dir.static);
    this.srcBuiltPath = path.resolve(this.options.buildDir, 'dist');
    this.distPath = path.resolve(this.options.rootDir, this.options.generate.dir);
    this.distNuxtPath = path.join(
      this.distPath,
      isUrl(this.options.build.publicPath) ? '' : this.options.build.publicPath
    );
  }

  async generate({ build = true, init = true } = {}) {
    consola.debug('Initializing generator...');

    await this.initiate({ build, init });

    consola.debug('Preparing routes for generate...');

    const routes = await this.initRoutes();

    consola.info({
      message: 'Generating pages',
      badge: true,
      clear: true
    });

    const errors = await this.generateRoutes(routes);

    await this.afterGenerate();

    // Done hook
    await this.nuxt.callHook('generate:done', this, errors);

    return { errors }
  }

  async initiate({ build = true, init = true } = {}) {
    // Wait for nuxt be ready
    await this.nuxt.ready();

    // Call before hook
    await this.nuxt.callHook('generate:before', this, this.options.generate);

    if (build) {
      // Add flag to set process.static
      this.builder.forGenerate();

      // Start build process
      await this.builder.build();
    }

    // Initialize dist directory
    if (init) {
      await this.initDist();
    }
  }

  async initRoutes(...args) {
    // Resolve config.generate.routes promises before generating the routes
    let generateRoutes = [];
    if (this.options.router.mode !== 'hash') {
      try {
        generateRoutes = await promisifyRoute(
          this.options.generate.routes || [],
          ...args
        );
      } catch (e) {
        consola.error('Could not resolve routes');
        throw e // eslint-disable-line no-unreachable
      }
    }
    // Generate only index.html for router.mode = 'hash'
    let routes =
      this.options.router.mode === 'hash'
        ? ['/']
        : flatRoutes(this.options.router.routes);
    routes = this.decorateWithPayloads(routes, generateRoutes);

    // extendRoutes hook
    await this.nuxt.callHook('generate:extendRoutes', routes);

    return routes
  }

  async generateRoutes(routes) {
    let errors = [];

    // Start generate process
    while (routes.length) {
      let n = 0;
      await Promise.all(
        routes
          .splice(0, this.options.generate.concurrency)
          .map(async ({ route, payload }) => {
            await waitFor(n++ * this.options.generate.interval);
            await this.generateRoute({ route, payload, errors });
          })
      );
    }

    // Improve string representation for errors
    errors.toString = () => this._formatErrors(errors);

    return errors
  }

  _formatErrors(errors) {
    return errors
      .map(({ type, route, error }) => {
        const isHandled = type === 'handled';
        const bgColor = isHandled ? 'bgYellow' : 'bgRed';
        const color = isHandled ? 'yellow' : 'red';

        let line =
          Chalk.black[bgColor](' GEN ERR ') + Chalk[color](` ${route}\n\n`);

        if (isHandled) {
          line += Chalk.grey(JSON.stringify(error, undefined, 2) + '\n');
        } else {
          line += Chalk.grey(error.stack);
        }

        return line
      })
      .join('\n')
  }

  async afterGenerate() {
    let { fallback } = this.options.generate;

    // Disable SPA fallback if value isn't true or a string
    if (fallback !== true && typeof fallback !== 'string') return

    const fallbackPath = path.join(this.distPath, fallback);

    // Prevent conflicts
    if (fsExtra.existsSync(fallbackPath)) {
      consola.warn(`SPA fallback was configured, but the configured path (${fallbackPath}) already exists.`);
      return
    }

    // Render and write the SPA template to the fallback path
    const { html } = await this.nuxt.renderRoute('/', { spa: true });
    await fsExtra.writeFile(fallbackPath, html, 'utf8');
  }

  async initDist() {
    // Clean destination folder
    await fsExtra.remove(this.distPath);

    await this.nuxt.callHook('generate:distRemoved', this);

    // Copy static and built files
    /* istanbul ignore if */
    if (fsExtra.existsSync(this.staticRoutes)) {
      await fsExtra.copy(this.staticRoutes, this.distPath);
    }
    await fsExtra.copy(this.srcBuiltPath, this.distNuxtPath);

    // Add .nojekyll file to let Github Pages add the _nuxt/ folder
    // https://help.github.com/articles/files-that-start-with-an-underscore-are-missing/
    const nojekyllPath = path.resolve(this.distPath, '.nojekyll');
    fsExtra.writeFile(nojekyllPath, '');

    // Cleanup SSR related files
    const extraFiles = [
      'index.spa.html',
      'index.ssr.html',
      'server-bundle.json',
      'vue-ssr-client-manifest.json'
    ].map(file => path.resolve(this.distNuxtPath, file));

    extraFiles.forEach(file => {
      if (fsExtra.existsSync(file)) {
        fsExtra.removeSync(file);
      }
    });

    await this.nuxt.callHook('generate:distCopied', this);
  }

  decorateWithPayloads(routes, generateRoutes) {
    let routeMap = {};
    // Fill routeMap for known routes
    routes.forEach(route => {
      routeMap[route] = {
        route,
        payload: null
      };
    });
    // Fill routeMap with given generate.routes
    generateRoutes.forEach(route => {
      // route is either a string or like { route : '/my_route/1', payload: {} }
      const path$$1 = ___default.isString(route) ? route : route.route;
      routeMap[path$$1] = {
        route: path$$1,
        payload: route.payload || null
      };
    });
    return ___default.values(routeMap)
  }

  async generateRoute({ route, payload = {}, errors = [] }) {
    let html;
    const pageErrors = [];

    try {
      const res = await this.nuxt.renderer.renderRoute(route, {
        _generate: true,
        payload
      });
      html = res.html;
      if (res.error) {
        pageErrors.push({ type: 'handled', route, error: res.error });
      }
    } catch (err) {
      /* istanbul ignore next */
      pageErrors.push({ type: 'unhandled', route, error: err });
      Array.prototype.push.apply(errors, pageErrors);

      await this.nuxt.callHook('generate:routeFailed', {
        route,
        errors: pageErrors
      });

      return false
    }

    if (this.options.generate.minify) {
      try {
        html = htmlMinifier.minify(html, this.options.generate.minify);
      } catch (err) /* istanbul ignore next */ {
        const minifyErr = new Error(
          `HTML minification failed. Make sure the route generates valid HTML. Failed HTML:\n ${html}`
        );
        pageErrors.push({ type: 'unhandled', route, error: minifyErr });
      }
    }

    let _path;

    if (this.options.generate.subFolders) {
      _path = path.join(route, path.sep, 'index.html'); // /about -> /about/index.html
      _path = _path === '/404/index.html' ? '/404.html' : _path; // /404 -> /404.html
    } else {
      _path = route.length > 1 ? path.join(path.sep, route + '.html') : path.join(path.sep, 'index.html');
    }

    // Call hook to let user update the path & html
    const page = { route, path: _path, html };
    await this.nuxt.callHook('generate:page', page);

    page.path = path.join(this.distPath, page.path);

    // Make sure the sub folders are created
    await fsExtra.mkdirp(path.dirname(page.path));
    await fsExtra.writeFile(page.path, page.html, 'utf8');

    await this.nuxt.callHook('generate:routeCreated', {
      route,
      path: page.path,
      errors: pageErrors
    });

    if (pageErrors.length) {
      consola.error('Error generating ' + route);
      Array.prototype.push.apply(errors, pageErrors);
    } else {
      consola.success('Generated ' + route);
    }

    return true
  }
}

var builder = {
  Builder,
  Generator
}

var nuxt = Object.assign({ Utils, Options }, core, builder)

module.exports = nuxt;
//# sourceMappingURL=nuxt.js.map
