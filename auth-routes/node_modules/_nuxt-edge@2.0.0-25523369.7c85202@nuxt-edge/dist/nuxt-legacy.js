'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var _ = require('lodash');
var ___default = _interopDefault(_);
var fs = _interopDefault(require('fs'));
var hash = _interopDefault(require('hash-sum'));
var env = _interopDefault(require('std-env'));
var consola = _interopDefault(require('consola'));
var Vue = _interopDefault(require('vue'));
var VueMeta = _interopDefault(require('vue-meta'));
var vueServerRenderer = require('vue-server-renderer');
var LRU = _interopDefault(require('lru-cache'));
var Youch = _interopDefault(require('@nuxtjs/youch'));
var fsExtra = _interopDefault(require('fs-extra'));
var generateETag = _interopDefault(require('etag'));
var fresh = _interopDefault(require('fresh'));
var crypto = _interopDefault(require('crypto'));
var serialize = _interopDefault(require('serialize-javascript'));
var serveStatic = _interopDefault(require('serve-static'));
var compression = _interopDefault(require('compression'));
var connect = _interopDefault(require('connect'));
var launchMiddleware = _interopDefault(require('launch-editor-middleware'));
var Module = _interopDefault(require('module'));
var enableDestroy = _interopDefault(require('server-destroy'));
var Chalk = _interopDefault(require('chalk'));
var esm = _interopDefault(require('esm'));
var threadLoader = require('thread-loader');
var createResolver = _interopDefault(require('postcss-import-resolver'));
var MiniCssExtractPlugin = _interopDefault(require('mini-css-extract-plugin'));
var TimeFixPlugin = _interopDefault(require('time-fix-plugin'));
var VueLoader = _interopDefault(require('vue-loader'));
var WebpackBar = _interopDefault(require('webpackbar'));
var webpack = _interopDefault(require('webpack'));
var HTMLPlugin = _interopDefault(require('html-webpack-plugin'));
var BundleAnalyzer = _interopDefault(require('webpack-bundle-analyzer'));
var UglifyJsWebpackPlugin = _interopDefault(require('uglifyjs-webpack-plugin'));
var FriendlyErrorsWebpackPlugin = _interopDefault(require('@nuxtjs/friendly-errors-webpack-plugin'));
var nodeExternals = _interopDefault(require('webpack-node-externals'));
var pify = _interopDefault(require('pify'));
var chokidar = _interopDefault(require('chokidar'));
var MFS = _interopDefault(require('memory-fs'));
var webpackDevMiddleware = _interopDefault(require('webpack-dev-middleware'));
var webpackHotMiddleware = _interopDefault(require('webpack-hot-middleware'));
var Glob = _interopDefault(require('glob'));
var upath = _interopDefault(require('upath'));
var htmlMinifier = _interopDefault(require('html-minifier'));
require('babel-polyfill');

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var promiseFinally = function () {
  var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fn, finalFn) {
    var result;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            result = void 0;
            _context.prev = 1;

            if (!(typeof fn === 'function')) {
              _context.next = 8;
              break;
            }

            _context.next = 5;
            return fn();

          case 5:
            result = _context.sent;
            _context.next = 11;
            break;

          case 8:
            _context.next = 10;
            return fn;

          case 10:
            result = _context.sent;

          case 11:
            _context.prev = 11;

            finalFn();
            return _context.finish(11);

          case 14:
            return _context.abrupt('return', result);

          case 15:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[1,, 11, 14]]);
  }));

  return function promiseFinally(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var encodeHtml = function encodeHtml(str) {
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
};

var getContext = function getContext(req, res) {
  return { req: req, res: res };
};

var waitFor = function waitFor(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms || 0);
  });
};

var timeout = function timeout(fn, ms, msg) {
  var timerId = void 0;
  var warpPromise = promiseFinally(fn, function () {
    return clearTimeout(timerId);
  });
  var timerPromise = new Promise(function (resolve, reject) {
    timerId = setTimeout(function () {
      return reject(new Error(msg));
    }, ms);
  });
  return Promise.race([warpPromise, timerPromise]);
};

var urlJoin = function urlJoin() {
  return [].slice.call(arguments).join('/').replace(/\/+/g, '/').replace(':/', '://');
};

var isUrl = function isUrl(url) {
  return url.indexOf('http') === 0 || url.indexOf('//') === 0;
};

var promisifyRoute = function promisifyRoute(fn) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  // If routes is an array
  if (Array.isArray(fn)) {
    return Promise.resolve(fn);
  }
  // If routes is a function expecting a callback
  if (fn.length === arguments.length) {
    return new Promise(function (resolve, reject) {
      fn.apply(undefined, [function (err, routeParams) {
        if (err) {
          reject(err);
        }
        resolve(routeParams);
      }].concat(args));
    });
  }
  var promise = fn.apply(undefined, args);
  if (!promise || !(promise instanceof Promise) && typeof promise.then !== 'function') {
    promise = Promise.resolve(promise);
  }
  return promise;
};

var sequence = function sequence(tasks, fn) {
  return tasks.reduce(function (promise, task) {
    return promise.then(function () {
      return fn(task);
    });
  }, Promise.resolve());
};

var parallel = function parallel(tasks, fn) {
  return Promise.all(tasks.map(function (task) {
    return fn(task);
  }));
};

var chainFn = function chainFn(base, fn) {
  /* istanbul ignore if */
  if (typeof fn !== 'function') {
    return base;
  }
  return function () {
    if (typeof base !== 'function') {
      return fn.apply(this, arguments);
    }
    var baseResult = base.apply(this, arguments);
    // Allow function to mutate the first argument instead of returning the result
    if (baseResult === undefined) {
      baseResult = arguments[0];
    }
    var fnResult = fn.call.apply(fn, [this, baseResult].concat(toConsumableArray(Array.prototype.slice.call(arguments, 1))));
    // Return mutated argument if no result was returned
    if (fnResult === undefined) {
      return baseResult;
    }
    return fnResult;
  };
};

var isPureObject = function isPureObject(o) {
  return !Array.isArray(o) && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object';
};

var isWindows = /^win/.test(process.platform);

var wp = function wp() {
  var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\\/g, '\\\\');
  }
  return p;
};

var wChunk = function wChunk() {
  var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\//g, '_');
  }
  return p;
};

var reqSep = /\//g;
var sysSep = ___default.escapeRegExp(path.sep);
var normalize = function normalize(string) {
  return string.replace(reqSep, sysSep);
};

var r = function r() {
  var args = Array.prototype.slice.apply(arguments);
  var lastArg = ___default.last(args);

  if (lastArg.indexOf('@') === 0 || lastArg.indexOf('~') === 0) {
    return wp(lastArg);
  }

  return wp(path.resolve.apply(path, toConsumableArray(args.map(normalize))));
};

var relativeTo = function relativeTo() {
  var args = Array.prototype.slice.apply(arguments);
  var dir = args.shift();

  // Keep webpack inline loader intact
  if (args[0].indexOf('!') !== -1) {
    var loaders = args.shift().split('!');

    return loaders.concat(relativeTo.apply(undefined, [dir, loaders.pop()].concat(toConsumableArray(args)))).join('!');
  }

  // Resolve path
  var _path = r.apply(undefined, toConsumableArray(args));

  // Check if path is an alias
  if (_path.indexOf('@') === 0 || _path.indexOf('~') === 0) {
    return _path;
  }

  // Make correct relative path
  var rp = path.relative(dir, _path);
  if (rp[0] !== '.') {
    rp = './' + rp;
  }

  return wp(rp);
};

var flatRoutes = function flatRoutes(router) {
  var _path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var routes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  router.forEach(function (r) {
    if (!r.path.includes(':') && !r.path.includes('*')) {
      /* istanbul ignore if */
      if (r.children) {
        if (_path === '' && r.path === '/') {
          routes.push('/');
        }
        flatRoutes(r.children, _path + r.path + '/', routes);
      } else {
        _path = _path.replace(/^\/+$/, '/');
        routes.push((r.path === '' && _path[_path.length - 1] === '/' ? _path.slice(0, -1) : _path) + r.path);
      }
    }
  });
  return routes;
};

function cleanChildrenRoutes(routes) {
  var isChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var start = -1;
  var routesIndex = [];
  routes.forEach(function (route) {
    if (/-index$/.test(route.name) || route.name === 'index') {
      // Save indexOf 'index' key in name
      var res = route.name.split('-');
      var s = res.indexOf('index');
      start = start === -1 || s < start ? s : start;
      routesIndex.push(res);
    }
  });
  routes.forEach(function (route) {
    route.path = isChild ? route.path.replace('/', '') : route.path;
    if (route.path.indexOf('?') > -1) {
      var names = route.name.split('-');
      var paths = route.path.split('/');
      if (!isChild) {
        paths.shift();
      } // clean first / for parents
      routesIndex.forEach(function (r) {
        var i = r.indexOf('index') - start; //  children names
        if (i < paths.length) {
          for (var a = 0; a <= i; a++) {
            if (a === i) {
              paths[a] = paths[a].replace('?', '');
            }
            if (a < i && names[a] !== r[a]) {
              break;
            }
          }
        }
      });
      route.path = (isChild ? '' : '/') + paths.join('/');
    }
    route.name = route.name.replace(/-index$/, '');
    if (route.children) {
      if (route.children.find(function (child) {
        return child.path === '';
      })) {
        delete route.name;
      }
      route.children = cleanChildrenRoutes(route.children, true);
    }
  });
  return routes;
}

var createRoutes = function createRoutes(files, srcDir, pagesDir) {
  var routes = [];
  files.forEach(function (file) {
    var keys = file.replace(RegExp('^' + pagesDir), '').replace(/\.(vue|js)$/, '').replace(/\/{2,}/g, '/').split('/').slice(1);
    var route = { name: '', path: '', component: r(srcDir, file) };
    var parent = routes;
    keys.forEach(function (key, i) {
      // remove underscore only, if its the prefix
      var sanatizedKey = key.indexOf('_') === 0 ? key.replace('_', '') : key;
      route.name = route.name ? route.name + '-' + sanatizedKey : sanatizedKey;
      route.name += key === '_' ? 'all' : '';
      route.chunkName = file.replace(/\.(vue|js)$/, '');
      var child = ___default.find(parent, { name: route.name });
      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = '';
      } else {
        if (key === 'index' && i + 1 === keys.length) {
          route.path += i > 0 ? '' : '/';
        } else {
          route.path += '/' + (key === '_' ? '*' : key.indexOf('_') === 0 ? key.replace('_', ':') : key);
          if (key !== '_' && key.indexOf('_') === 0) {
            route.path += '?';
          }
        }
      }
    });
    // Order Routes path
    parent.push(route);
    parent.sort(function (a, b) {
      if (!a.path.length) {
        return -1;
      }
      if (!b.path.length) {
        return 1;
      }
      // Order: /static, /index, /:dynamic
      // Match exact route before index: /login before /index/_slug
      if (a.path === '/') {
        return (/^\/(:|\*)/.test(b.path) ? -1 : 1
        );
      }
      if (b.path === '/') {
        return (/^\/(:|\*)/.test(a.path) ? 1 : -1
        );
      }
      var i = 0;
      var res = 0;
      var y = 0;
      var z = 0;
      var _a = a.path.split('/');
      var _b = b.path.split('/');
      for (i = 0; i < _a.length; i++) {
        if (res !== 0) {
          break;
        }
        y = _a[i] === '*' ? 2 : _a[i].indexOf(':') > -1 ? 1 : 0;
        z = _b[i] === '*' ? 2 : _b[i].indexOf(':') > -1 ? 1 : 0;
        res = y - z;
        // If a.length >= b.length
        if (i === _b.length - 1 && res === 0) {
          // change order if * found
          res = _a[i] === '*' ? -1 : 1;
        }
      }
      return res === 0 ? _a[i - 1] === '*' && _b[i] ? 1 : -1 : res;
    });
  });
  return cleanChildrenRoutes(routes);
};

var Utils = /*#__PURE__*/Object.freeze({
  encodeHtml: encodeHtml,
  getContext: getContext,
  waitFor: waitFor,
  timeout: timeout,
  urlJoin: urlJoin,
  isUrl: isUrl,
  promisifyRoute: promisifyRoute,
  sequence: sequence,
  parallel: parallel,
  chainFn: chainFn,
  isPureObject: isPureObject,
  isWindows: isWindows,
  wp: wp,
  wChunk: wChunk,
  r: r,
  relativeTo: relativeTo,
  flatRoutes: flatRoutes,
  createRoutes: createRoutes
});

var ModuleContainer = function () {
  function ModuleContainer(nuxt) {
    classCallCheck(this, ModuleContainer);

    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.requiredModules = {};
  }

  createClass(ModuleContainer, [{
    key: 'ready',
    value: function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.nuxt.callHook('modules:before', this, this.options.modules);

              case 2:
                _context.next = 4;
                return sequence(this.options.modules, this.addModule.bind(this));

              case 4:
                _context.next = 6;
                return this.nuxt.callHook('modules:done', this);

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function ready() {
        return _ref.apply(this, arguments);
      }

      return ready;
    }()
  }, {
    key: 'addVendor',
    value: function addVendor(vendor) {
      // Make it silent for backward compability with nuxt 1.x
    }
  }, {
    key: 'addTemplate',
    value: function addTemplate(template) {
      /* istanbul ignore if */
      if (!template) {
        throw new Error('Invalid template:' + JSON.stringify(template));
      }

      // Validate & parse source
      var src = template.src || template;
      var srcPath = path.parse(src);
      /* istanbul ignore if */
      if (!src || typeof src !== 'string' || !fs.existsSync(src)) {
        throw new Error('Template src not found:' + src);
      }

      // Generate unique and human readable dst filename
      var dst = template.fileName || path.basename(srcPath.dir) + ('.' + srcPath.name + '.' + hash(src)) + srcPath.ext;

      // Add to templates list
      var templateObj = {
        src: src,
        dst: dst,
        options: template.options
      };

      this.options.build.templates.push(templateObj);
      return templateObj;
    }
  }, {
    key: 'addPlugin',
    value: function addPlugin(template) {
      var _addTemplate = this.addTemplate(template),
          dst = _addTemplate.dst;

      // Add to nuxt plugins


      this.options.plugins.unshift({
        src: path.join(this.options.buildDir, dst),
        ssr: template.ssr
      });
    }
  }, {
    key: 'addLayout',
    value: function addLayout(template, name) {
      var _addTemplate2 = this.addTemplate(template),
          dst = _addTemplate2.dst,
          src = _addTemplate2.src;

      // Add to nuxt layouts


      this.options.layouts[name || path.parse(src).name] = './' + dst;
    }
  }, {
    key: 'addServerMiddleware',
    value: function addServerMiddleware(middleware) {
      this.options.serverMiddleware.push(middleware);
    }
  }, {
    key: 'extendBuild',
    value: function extendBuild(fn) {
      this.options.build.extend = chainFn(this.options.build.extend, fn);
    }
  }, {
    key: 'extendRoutes',
    value: function extendRoutes(fn) {
      this.options.router.extendRoutes = chainFn(this.options.router.extendRoutes, fn);
    }
  }, {
    key: 'requireModule',
    value: function requireModule(moduleOpts) {
      return this.addModule(moduleOpts, true /* require once */);
    }
  }, {
    key: 'addModule',
    value: function () {
      var _ref2 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(moduleOpts, requireOnce) {
        var _this = this;

        var src, options, handler, key;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                src = void 0;
                options = void 0;
                handler = void 0;

                // Type 1: String

                if (typeof moduleOpts === 'string') {
                  src = moduleOpts;
                } else if (Array.isArray(moduleOpts)) {
                  // Type 2: Babel style array
                  src = moduleOpts[0];
                  options = moduleOpts[1];
                } else if ((typeof moduleOpts === 'undefined' ? 'undefined' : _typeof(moduleOpts)) === 'object') {
                  // Type 3: Pure object
                  src = moduleOpts.src;
                  options = moduleOpts.options;
                  handler = moduleOpts.handler;
                }

                // Resolve handler
                if (!handler) {
                  handler = this.nuxt.requireModule(src, { esm: false });
                }

                // Validate handler
                /* istanbul ignore if */

                if (!(typeof handler !== 'function')) {
                  _context2.next = 7;
                  break;
                }

                throw new Error('Module should export a function: ' + src);

              case 7:

                // Resolve module meta
                key = handler.meta && handler.meta.name || handler.name || src;

                // Update requiredModules

                if (!(typeof key === 'string')) {
                  _context2.next = 12;
                  break;
                }

                if (!(requireOnce && this.requiredModules[key])) {
                  _context2.next = 11;
                  break;
                }

                return _context2.abrupt('return');

              case 11:
                this.requiredModules[key] = { src: src, options: options, handler: handler };

              case 12:

                // Default module options to empty object
                if (options === undefined) {
                  options = {};
                }

                return _context2.abrupt('return', new Promise(function (resolve, reject) {
                  // Call module with `this` context and pass options
                  var result = handler.call(_this, options);

                  // If module send back a promise
                  if (result && result.then) {
                    return resolve(result);
                  }

                  // synchronous
                  return resolve();
                }));

              case 14:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function addModule(_x, _x2) {
        return _ref2.apply(this, arguments);
      }

      return addModule;
    }()
  }]);
  return ModuleContainer;
}();

var modes = {
  universal: {
    build: {
      ssr: true
    },
    render: {
      ssr: true
    }
  },
  spa: {
    build: {
      ssr: false
    },
    render: {
      ssr: false
    }
  }
};

var nuxtDir = fs.existsSync(path.resolve(__dirname, '..', 'package.json')) ? path.resolve(__dirname, '..') // dist
: path.resolve(__dirname, '..', '..'); // src

var defaults$1 = {
  // Information about running environment
  dev: Boolean(env.dev),
  debug: undefined, // = dev

  // Mode
  mode: 'universal',

  // Dirs
  buildDir: '.nuxt',
  nuxtDir: nuxtDir,
  nuxtAppDir: path.resolve(nuxtDir, 'lib', 'app'),
  modulesDir: ['node_modules'], // ~> relative to options.rootDir

  // Ignore
  ignorePrefix: '-',
  ignore: ['**/*.test.*'],

  extensions: [],

  build: {
    analyze: false,
    profile: process.argv.includes('--profile'),
    maxChunkSize: false,
    extractCSS: false,
    cssSourceMap: undefined,
    ssr: undefined,
    parallel: false,
    cache: false,
    publicPath: '/_nuxt/',
    filenames: {
      app: '[name].[contenthash].js',
      chunk: '[name].[contenthash].js',
      css: '[name].[contenthash].css'
    },
    styleResources: {},
    plugins: [],
    optimization: {
      splitChunks: {
        chunks: 'all',
        automaticNameDelimiter: '.',
        name: undefined,
        cacheGroups: {}
      }
    },
    splitChunks: {
      layouts: false,
      pages: true,
      commons: true
    },
    babel: {
      babelrc: false,
      cacheDirectory: undefined
    },
    transpile: [], // Name of NPM packages to be transpiled
    vueLoader: {},
    postcss: {},
    templates: [],
    watch: [],
    devMiddleware: {},
    hotMiddleware: {},
    stats: {
      chunks: false,
      children: false,
      modules: false,
      colors: true,
      warnings: true,
      errors: true,
      excludeAssets: [/.map$/, /index\..+\.html$/, /vue-ssr-client-manifest.json/]
    }
  },
  generate: {
    dir: 'dist',
    routes: [],
    concurrency: 500,
    interval: 0,
    subFolders: true,
    fallback: '200.html',
    minify: {
      collapseBooleanAttributes: true,
      collapseWhitespace: false,
      decodeEntities: true,
      minifyCSS: true,
      minifyJS: true,
      processConditionalComments: true,
      removeAttributeQuotes: false,
      removeComments: false,
      removeEmptyAttributes: true,
      removeOptionalTags: true,
      removeRedundantAttributes: true,
      removeScriptTypeAttributes: false,
      removeStyleLinkTypeAttributes: false,
      removeTagWhitespace: false,
      sortAttributes: true,
      sortClassName: false,
      trimCustomFragments: true,
      useShortDoctype: true
    }
  },
  env: {},
  head: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  plugins: [],
  css: [],
  modules: [],
  layouts: {},
  serverMiddleware: [],
  ErrorPage: null,
  loading: {
    color: 'black',
    failedColor: 'red',
    height: '2px',
    duration: 5000,
    rtl: false
  },
  loadingIndicator: 'default',
  transition: {
    name: 'page',
    mode: 'out-in',
    appear: false,
    appearClass: 'appear',
    appearActiveClass: 'appear-active',
    appearToClass: 'appear-to'
  },
  layoutTransition: {
    name: 'layout',
    mode: 'out-in'
  },
  dir: {
    assets: 'assets',
    layouts: 'layouts',
    middleware: 'middleware',
    pages: 'pages',
    static: 'static',
    store: 'store'
  },
  router: {
    mode: 'history',
    base: '/',
    routes: [],
    middleware: [],
    linkActiveClass: 'nuxt-link-active',
    linkExactActiveClass: 'nuxt-link-exact-active',
    extendRoutes: null,
    scrollBehavior: null,
    parseQuery: false,
    stringifyQuery: false,
    fallback: false
  },
  render: {
    bundleRenderer: {
      shouldPrefetch: function shouldPrefetch() {
        return false;
      }
    },
    resourceHints: true,
    ssr: undefined,
    http2: {
      push: false,
      shouldPush: null
    },
    static: {
      prefix: true
    },
    gzip: {
      threshold: 0
    },
    etag: {
      weak: false
    },
    csp: false
  },
  watchers: {
    webpack: {},
    chokidar: {}
  },
  editor: undefined,
  hooks: null,
  messages: {
    loading: 'Loading...',
    error_404: 'This page could not be found',
    server_error: 'Server error',
    nuxtjs: 'Nuxt.js',
    back_to_home: 'Back to the home page',
    server_error_details: 'An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.',
    client_error: 'Error',
    client_error_details: 'An error occurred while rendering the page. Check developer tools console for details.'
  }
};

var Options = {};

Options.from = function (_options) {
  // Clone options to prevent unwanted side-effects
  var options = Object.assign({}, _options);

  // Normalize options
  if (options.loading === true) {
    delete options.loading;
  }
  if (options.router && options.router.middleware && !Array.isArray(options.router.middleware)) {
    options.router.middleware = [options.router.middleware];
  }
  if (options.router && typeof options.router.base === 'string') {
    options._routerBaseSpecified = true;
  }
  if (typeof options.transition === 'string') {
    options.transition = { name: options.transition };
  }
  if (typeof options.layoutTransition === 'string') {
    options.layoutTransition = { name: options.layoutTransition };
  }
  if (typeof options.extensions === 'string') {
    options.extensions = [options.extensions];
  }

  var hasValue = function hasValue(v) {
    return typeof v === 'string' && v;
  };
  options.rootDir = hasValue(options.rootDir) ? options.rootDir : process.cwd();

  // Apply defaults by ${buildDir}/dist/build.config.js
  // TODO: Unsafe operation.
  // const buildDir = options.buildDir || defaults.buildDir
  // const buildConfig = resolve(options.rootDir, buildDir, 'build.config.js')
  // if (existsSync(buildConfig)) {
  //   _.defaultsDeep(options, require(buildConfig))
  // }

  // Apply defaults
  ___default.defaultsDeep(options, defaults$1);

  // Resolve dirs
  options.srcDir = hasValue(options.srcDir) ? path.resolve(options.rootDir, options.srcDir) : options.rootDir;
  options.buildDir = path.resolve(options.rootDir, options.buildDir);

  // Populate modulesDir
  options.modulesDir = [].concat(options.modulesDir).concat(path.join(options.nuxtDir, 'node_modules')).filter(function (dir) {
    return hasValue(dir);
  }).map(function (dir) {
    return path.resolve(options.rootDir, dir);
  });

  // Sanitize extensions
  if (options.extensions.indexOf('js') === -1) {
    options.extensions.unshift('js');
  }

  if (options.extensions.indexOf('mjs') === -1) {
    options.extensions.unshift('mjs');
  }

  // If app.html is defined, set the template path to the user template
  options.appTemplatePath = path.resolve(options.buildDir, 'views/app.template.html');
  if (fs.existsSync(path.join(options.srcDir, 'app.html'))) {
    options.appTemplatePath = path.join(options.srcDir, 'app.html');
  }

  // Ignore publicPath on dev
  /* istanbul ignore if */
  if (options.dev && isUrl(options.build.publicPath)) {
    options.build.publicPath = defaults$1.build.publicPath;
  }

  // If store defined, update store options to true unless explicitly disabled
  if (options.store !== false && fs.existsSync(path.join(options.srcDir, options.dir.store)) && fs.readdirSync(path.join(options.srcDir, options.dir.store)).find(function (filename) {
    return filename !== 'README.md' && filename[0] !== '.';
  })) {
    options.store = true;
  }

  // SPA loadingIndicator
  if (options.loadingIndicator) {
    // Normalize loadingIndicator
    if (!isPureObject(options.loadingIndicator)) {
      options.loadingIndicator = { name: options.loadingIndicator };
    }

    // Apply defaults
    options.loadingIndicator = Object.assign({
      name: 'default',
      color: options.loading && options.loading.color || '#D3D3D3',
      color2: '#F5F5F5',
      background: options.manifest && options.manifest.theme_color || 'white',
      dev: options.dev,
      loading: options.messages.loading
    }, options.loadingIndicator);
  }

  // Debug errors
  if (options.debug === undefined) {
    options.debug = options.dev;
  }

  // Apply default hash to CSP option
  var csp = options.render.csp;
  var cspDefaults = {
    hashAlgorithm: 'sha256',
    allowedSources: undefined,
    policies: undefined
  };
  if (csp) {
    options.render.csp = ___default.defaults(___default.isObject(csp) ? csp : {}, cspDefaults);
  }

  // cssSourceMap
  if (options.build.cssSourceMap === undefined) {
    options.build.cssSourceMap = options.dev;
  }

  // babel cacheDirectory
  if (options.build.babel.cacheDirectory === undefined) {
    options.build.babel.cacheDirectory = options.dev;
  }

  // Normalize ignore
  options.ignore = options.ignore ? [].concat(options.ignore) : [];

  // Append ignorePrefix glob to ignore
  if (typeof options.ignorePrefix === 'string') {
    options.ignore.push('**/' + options.ignorePrefix + '*.*');
  }

  // Apply mode preset
  var modePreset = modes[options.mode || 'universal'] || modes['universal'];
  ___default.defaultsDeep(options, modePreset);

  // If no server-side rendering, add appear true transition
  /* istanbul ignore if */
  if (options.render.ssr === false && options.transition) {
    options.transition.appear = true;
  }

  // We assume the SPA fallback path is 404.html (for GitHub Pages, Surge, etc.)
  if (options.generate.fallback === true) {
    options.generate.fallback = '404.html';
  }

  // Enable [name] when analyze or dev mode
  if (options.build.optimization.splitChunks.name === undefined && (options.dev || options.build.analyze)) {
    options.build.optimization.splitChunks.name = true;
  }

  if (options.build.stats === 'none') {
    options.build.stats = false;
  }

  // Vendor backward compatibility with nuxt 1.x
  if (typeof options.build.vendor !== 'undefined') {
    delete options.build.vendor;
    consola.warn('vendor has been deprecated due to webpack4 optimization');
  }

  // TODO: remove when mini-css-extract-plugin supports HMR
  if (options.dev) {
    options.build.extractCSS = false;
  }

  // include SFCs in node_modules
  options.build.transpile = [/\.vue\.js/].concat(options.build.transpile || []);

  return options;
};

var name = "nuxt";
var version = "2.0.0";
var description = "A minimalistic framework for server-rendered Vue.js applications (inspired by Next.js)";
var contributors = [{
	name: "Sebastien Chopin (@Atinux)"
}, {
	name: "Alexandre Chopin (@alexchopin)"
}, {
	name: "Pooya Parsa (@pi0)"
}, {
	name: "Clark Du (@clarkdo)"
}];
var main = "index.js";
var module$1 = "./lib/nuxt.js";
var license = "MIT";
var repository = {
	type: "git",
	url: "git+https://github.com/nuxt/nuxt.js"
};
var files = ["bin", "lib", "dist", "index.js"];
var keywords = ["nuxt", "nuxt.js", "nuxtjs", "vue", "vue.js", "vuejs", "vue universal", "vue ssr", "vue isomorphic", "vue versatile"];
var homepage = "https://github.com/nuxt/nuxt.js#readme";
var bin = {
	nuxt: "./bin/nuxt"
};
var scripts = {
	build: "yarn build:nuxt && yarn build:nuxt-start && yarn build:nuxt-legacy",
	"build:nuxt": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt.js",
	"build:nuxt-legacy": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt-legacy.js",
	"build:nuxt-start": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt-start.js",
	"build:make-start": "node scripts/make-start",
	clean: "rimraf dist",
	coverage: "codecov",
	lint: "eslint --ext .js,.mjs,.vue bin lib test examples",
	postinstall: "opencollective postinstall || exit 0",
	prebuild: "yarn clean",
	security: "nsp check || true",
	test: "yarn test:fixtures && yarn test:unit",
	"test:fixtures": "jest --maxWorkers=4 --forceExit --detectOpenHandles --coverage -e test/fixtures",
	"test:e2e": "jest --maxWorkers=1 --forceExit --detectOpenHandles test/e2e",
	"test:lint": "yarn lint && yarn security",
	"test:unit": "jest --maxWorkers=4 --forceExit --detectOpenHandles --coverage -e test/unit"
};
var engines = {
	node: ">=8.0.0",
	npm: ">=5.0.0"
};
var dependencies = {
	"@nuxtjs/friendly-errors-webpack-plugin": "^2.0.2",
	"@nuxtjs/youch": "^4.2.3",
	autoprefixer: "^8.6.4",
	"babel-core": "^6.26.3",
	"babel-loader": "^7.1.4",
	"babel-preset-vue-app": "^2.0.0",
	"cache-loader": "^1.2.2",
	"caniuse-lite": "^1.0.30000862",
	chalk: "^2.4.1",
	chokidar: "^2.0.3",
	compression: "^1.7.1",
	connect: "^3.6.5",
	consola: "^1.4.1",
	"css-loader": "^0.28.11",
	"es6-promise": "^4.2.4",
	esm: "^3.0.62",
	etag: "^1.8.1",
	"file-loader": "^1.1.11",
	fresh: "^0.5.2",
	"fs-extra": "^6.0.1",
	glob: "^7.1.2",
	"hash-sum": "^1.0.2",
	"html-minifier": "^3.5.16",
	"html-webpack-plugin": "^3.2.0",
	"launch-editor-middleware": "^2.2.1",
	lodash: "^4.17.10",
	"lru-cache": "^4.1.3",
	"memory-fs": "^0.4.1",
	"mini-css-extract-plugin": "^0.4.1",
	minimist: "^1.2.0",
	opencollective: "^1.0.3",
	pify: "^3.0.0",
	postcss: "^6.0.22",
	"postcss-import": "^11.1.0",
	"postcss-import-resolver": "^1.1.0",
	"postcss-loader": "^2.1.5",
	"postcss-preset-env": "^5.1.0",
	"postcss-url": "^7.3.2",
	semver: "^5.5.0",
	"serialize-javascript": "^1.5.0",
	"serve-static": "^1.13.2",
	"server-destroy": "^1.0.1",
	"std-env": "^1.3.0",
	"style-resources-loader": "^1.1.0",
	"thread-loader": "^1.1.5",
	"time-fix-plugin": "^2.0.3",
	"uglifyjs-webpack-plugin": "^1.2.7",
	upath: "^1.1.0",
	"url-loader": "^1.0.1",
	vue: "^2.5.16",
	"vue-loader": "^15.2.2",
	"vue-meta": "^1.5.2",
	"vue-router": "^3.0.1",
	"vue-server-renderer": "^2.5.16",
	"vue-template-compiler": "^2.5.16",
	vuex: "^3.0.1",
	webpack: "^4.14.0",
	"webpack-bundle-analyzer": "^2.13.1",
	"webpack-dev-middleware": "^3.1.3",
	"webpack-hot-middleware": "^2.22.2",
	"webpack-node-externals": "^1.7.2",
	webpackbar: "^2.6.1"
};
var devDependencies = {
	"babel-eslint": "^8.2.1",
	"babel-jest": "^23.0.1",
	"babel-plugin-external-helpers": "^6.22.0",
	"babel-polyfill": "^6.26.0",
	"babel-preset-env": "^1.7.0",
	codecov: "^3.0.2",
	"cross-env": "^5.2.0",
	eslint: "^4.19.1",
	"eslint-config-standard": "^11.0.0",
	"eslint-config-standard-jsx": "^5.0.0",
	"eslint-plugin-import": "^2.12.0",
	"eslint-plugin-jest": "^21.17.0",
	"eslint-plugin-node": "^6.0.0",
	"eslint-plugin-promise": "^3.8.0",
	"eslint-plugin-react": "^7.8.2",
	"eslint-plugin-standard": "^3.1.0",
	"eslint-plugin-vue": "^4.5.0",
	express: "^4.16.2",
	finalhandler: "^1.1.1",
	"get-port": "^3.2.0",
	jest: "^23.1.0",
	jsdom: "^11.11.0",
	nsp: "^3.2.1",
	pug: "^2.0.3",
	"pug-plain-loader": "^1.0.0",
	puppeteer: "^1.5.0",
	request: "^2.87.0",
	"request-promise-native": "^1.0.5",
	rimraf: "^2.6.2",
	rollup: "^0.59.4",
	"rollup-plugin-babel": "^3.0.4",
	"rollup-plugin-commonjs": "^9.1.3",
	"rollup-plugin-json": "^3.0.0"
};
var collective = {
	type: "opencollective",
	url: "https://opencollective.com/nuxtjs",
	logo: "https://opencollective.com/nuxtjs/logo.txt?reverse=true&variant=variant2"
};
var packageJSON = {
	name: name,
	version: version,
	description: description,
	contributors: contributors,
	main: main,
	module: module$1,
	license: license,
	repository: repository,
	files: files,
	keywords: keywords,
	homepage: homepage,
	bin: bin,
	scripts: scripts,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	collective: collective
};

var MetaRenderer = function () {
  function MetaRenderer(nuxt, renderer) {
    classCallCheck(this, MetaRenderer);

    this.nuxt = nuxt;
    this.renderer = renderer;
    this.options = nuxt.options;
    this.vueRenderer = vueServerRenderer.createRenderer();
    this.cache = LRU({});

    // Add VueMeta to Vue (this is only for SPA mode)
    // See lib/app/index.js
    Vue.use(VueMeta, {
      keyName: 'head',
      attribute: 'data-n-head',
      ssrAttribute: 'data-n-head-ssr',
      tagIDKeyName: 'hid'
    });
  }

  createClass(MetaRenderer, [{
    key: 'getMeta',
    value: function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url) {
        var vm;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                vm = new Vue({
                  render: function render(h) {
                    return h();
                  }, // Render empty html tag
                  head: this.options.head || {}
                });
                _context.next = 3;
                return this.vueRenderer.renderToString(vm);

              case 3:
                return _context.abrupt('return', vm.$meta().inject());

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getMeta(_x) {
        return _ref.apply(this, arguments);
      }

      return getMeta;
    }()
  }, {
    key: 'render',
    value: function () {
      var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
        var _ref2$url = _ref2.url,
            url = _ref2$url === undefined ? '/' : _ref2$url;
        var meta, m, clientManifest, shouldPreload, shouldPrefetch, publicPath;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                meta = this.cache.get(url);

                if (!meta) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt('return', meta);

              case 3:

                meta = {
                  HTML_ATTRS: '',
                  BODY_ATTRS: '',
                  HEAD: '',
                  BODY_SCRIPTS: ''

                  // Get vue-meta context
                };_context2.next = 6;
                return this.getMeta(url);

              case 6:
                m = _context2.sent;


                // HTML_ATTRS
                meta.HTML_ATTRS = m.htmlAttrs.text();

                // BODY_ATTRS
                meta.BODY_ATTRS = m.bodyAttrs.text();

                // HEAD tags
                meta.HEAD = m.title.text() + m.meta.text() + m.link.text() + m.style.text() + m.script.text() + m.noscript.text();

                // BODY_SCRIPTS
                meta.BODY_SCRIPTS = m.script.text({ body: true }) + m.noscript.text({ body: true });

                // Resources Hints

                meta.resourceHints = '';

                clientManifest = this.renderer.resources.clientManifest;

                shouldPreload = this.options.render.bundleRenderer.shouldPreload || function () {
                  return true;
                };

                shouldPrefetch = this.options.render.bundleRenderer.shouldPrefetch || function () {
                  return true;
                };

                if (this.options.render.resourceHints && clientManifest) {
                  publicPath = clientManifest.publicPath || '/_nuxt/';

                  // Preload initial resources

                  if (Array.isArray(clientManifest.initial)) {
                    meta.resourceHints += clientManifest.initial.filter(function (file) {
                      return shouldPreload(file);
                    }).map(function (r) {
                      return '<link rel="preload" href="' + publicPath + r + '" as="script" />';
                    }).join('');
                  }

                  // Prefetch async resources
                  if (Array.isArray(clientManifest.async)) {
                    meta.resourceHints += clientManifest.async.filter(function (file) {
                      return shouldPrefetch(file);
                    }).map(function (r) {
                      return '<link rel="prefetch" href="' + publicPath + r + '" />';
                    }).join('');
                  }

                  // Add them to HEAD
                  if (meta.resourceHints) {
                    meta.HEAD += meta.resourceHints;
                  }
                }

                // Emulate getPreloadFiles from vue-server-renderer (works for JS chunks only)
                meta.getPreloadFiles = function () {
                  return clientManifest.initial.filter(function (file) {
                    return shouldPreload(file);
                  }).map(function (r) {
                    return {
                      file: r,
                      fileWithoutQuery: r,
                      asType: 'script',
                      extension: 'js'
                    };
                  });
                };

                // Set meta tags inside cache
                this.cache.set(url, meta);

                return _context2.abrupt('return', meta);

              case 19:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function render(_x2) {
        return _ref3.apply(this, arguments);
      }

      return render;
    }()
  }]);
  return MetaRenderer;
}();

var readSource = function () {
  var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(frame) {
    var sanitizeName, searchPath, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, pathDir, fullPath, source;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // Remove webpack:/// & query string from the end
            sanitizeName = function sanitizeName(name) {
              return name ? name.replace('webpack:///', '').split('?')[0] : null;
            };

            frame.fileName = sanitizeName(frame.fileName);

            // Return if fileName is unknown
            /* istanbul ignore if */

            if (frame.fileName) {
              _context.next = 4;
              break;
            }

            return _context.abrupt('return');

          case 4:

            // Possible paths for file
            searchPath = [this.options.srcDir, this.options.rootDir, path.join(this.options.buildDir, 'dist'), this.options.buildDir, process.cwd()];

            // Scan filesystem for real source

            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 8;
            _iterator = searchPath[Symbol.iterator]();

          case 10:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context.next = 24;
              break;
            }

            pathDir = _step.value;
            fullPath = path.resolve(pathDir, frame.fileName);
            _context.next = 15;
            return fsExtra.readFile(fullPath, 'utf-8').catch(function () {
              return null;
            });

          case 15:
            source = _context.sent;

            if (!source) {
              _context.next = 21;
              break;
            }

            frame.contents = source;
            frame.fullPath = fullPath;
            if (path.isAbsolute(frame.fileName)) {
              frame.fileName = path.relative(this.options.rootDir, fullPath);
            }
            return _context.abrupt('return');

          case 21:
            _iteratorNormalCompletion = true;
            _context.next = 10;
            break;

          case 24:
            _context.next = 30;
            break;

          case 26:
            _context.prev = 26;
            _context.t0 = _context['catch'](8);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 30:
            _context.prev = 30;
            _context.prev = 31;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 33:
            _context.prev = 33;

            if (!_didIteratorError) {
              _context.next = 36;
              break;
            }

            throw _iteratorError;

          case 36:
            return _context.finish(33);

          case 37:
            return _context.finish(30);

          case 38:

            // Fallback: use server bundle
            // TODO: restore to if after https://github.com/istanbuljs/nyc/issues/595 fixed
            /* istanbul ignore next */
            if (!frame.contents) {
              frame.contents = this.resources.serverBundle.files[frame.fileName];
            }

          case 39:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[8, 26, 30, 38], [31,, 33, 37]]);
  }));

  return function readSource(_x2) {
    return _ref.apply(this, arguments);
  };
}();

function errorMiddleware(err, req, res, next) {
  // ensure statusCode, message and name fields
  err.statusCode = err.statusCode || 500;
  err.message = err.message || 'Nuxt Server Error';
  err.name = !err.name || err.name === 'Error' ? 'NuxtServerError' : err.name;

  // We hide actual errors from end users, so show them on server logs
  if (err.statusCode !== 404) {
    consola.error(err);
  }

  var sendResponse = function sendResponse(content) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text/html';

    // Set Headers
    res.statusCode = err.statusCode;
    res.statusMessage = err.name;
    res.setHeader('Content-Type', type + '; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(content));

    // Send Response
    res.end(content, 'utf-8');
  };

  // Check if request accepts JSON
  var hasReqHeader = function hasReqHeader(header, includes) {
    return req.headers[header] && req.headers[header].toLowerCase().includes(includes);
  };
  var isJson = hasReqHeader('accept', 'application/json') || hasReqHeader('user-agent', 'curl/');

  // Use basic errors when debug mode is disabled
  if (!this.options.debug) {
    // Json format is compatible with Youch json responses
    var json = {
      status: err.statusCode,
      message: err.message,
      name: err.name
    };
    if (isJson) {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
      return;
    }
    var html = this.resources.errorTemplate(json);
    sendResponse(html);
    return;
  }

  // Show stack trace
  var youch = new Youch(err, req, readSource.bind(this), this.options.router.base, true);
  if (isJson) {
    youch.toJSON().then(function (json) {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
    });
  } else {
    youch.toHTML().then(function (html) {
      sendResponse(html);
    });
  }
}

var nuxtMiddleware = (function () {
  var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(req, res, next) {
    var context, result, html, cspScriptSrcHashes, error, redirected, getPreloadFiles, etag, pushAssets, preloadFiles, shouldPush, publicPath, _options$render$csp, allowedSources, policies, cspStr, cspArr;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // Get context
            context = getContext(req, res);


            res.statusCode = 200;
            _context.prev = 2;
            _context.next = 5;
            return this.renderRoute(req.url, context);

          case 5:
            result = _context.sent;
            _context.next = 8;
            return this.nuxt.callHook('render:route', req.url, result, context);

          case 8:
            html = result.html, cspScriptSrcHashes = result.cspScriptSrcHashes, error = result.error, redirected = result.redirected, getPreloadFiles = result.getPreloadFiles;

            if (!redirected) {
              _context.next = 11;
              break;
            }

            return _context.abrupt('return', html);

          case 11:
            if (error) {
              res.statusCode = context.nuxt.error.statusCode || 500;
            }

            // Add ETag header

            if (!(!error && this.options.render.etag)) {
              _context.next = 19;
              break;
            }

            etag = generateETag(html, this.options.render.etag);

            if (!fresh(req.headers, { etag: etag })) {
              _context.next = 18;
              break;
            }

            res.statusCode = 304;
            res.end();
            return _context.abrupt('return');

          case 18:
            res.setHeader('ETag', etag);

          case 19:

            // HTTP2 push headers for preload assets
            if (!error && this.options.render.http2.push) {
              // Parse resourceHints to extract HTTP.2 prefetch/push headers
              // https://w3c.github.io/preload/#server-push-http-2
              pushAssets = [];
              preloadFiles = getPreloadFiles();
              shouldPush = this.options.render.http2.shouldPush;
              publicPath = this.resources.clientManifest.publicPath;


              preloadFiles.forEach(function (_ref2) {
                var file = _ref2.file,
                    asType = _ref2.asType,
                    fileWithoutQuery = _ref2.fileWithoutQuery,
                    extension = _ref2.extension;

                // By default, we only preload scripts or css
                /* istanbul ignore if */
                if (!shouldPush && asType !== 'script' && asType !== 'style') {
                  return;
                }

                // User wants to explicitly control what to preload
                if (shouldPush && !shouldPush(fileWithoutQuery, asType)) {
                  return;
                }

                pushAssets.push('<' + publicPath + file + '>; rel=preload; as=' + asType);
              });

              // Pass with single Link header
              // https://blog.cloudflare.com/http-2-server-push-with-multiple-assets-per-link-header
              // https://www.w3.org/Protocols/9707-link-header.html
              res.setHeader('Link', pushAssets.join(','));
            }

            if (this.options.render.csp) {
              _options$render$csp = this.options.render.csp, allowedSources = _options$render$csp.allowedSources, policies = _options$render$csp.policies;
              cspStr = 'script-src \'self\'' + (this.options.dev ? " 'unsafe-eval'" : '') + ' ' + cspScriptSrcHashes.join(' ');

              if (Array.isArray(allowedSources)) {
                // For compatible section
                cspStr += ' ' + allowedSources.join(' ');
              } else if ((typeof policies === 'undefined' ? 'undefined' : _typeof(policies)) === 'object' && policies !== null && !Array.isArray(policies)) {
                // Set default policy if necessary
                if (!policies['script-src'] || !Array.isArray(policies['script-src'])) {
                  policies['script-src'] = ['\'self\''].concat(cspScriptSrcHashes);
                } else {
                  policies['script-src'] = cspScriptSrcHashes.concat(policies['script-src']);
                  if (!policies['script-src'].includes('\'self\'')) {
                    policies['script-src'] = ['\'self\''].concat(policies['script-src']);
                  }
                }

                // Make content-security-policy string
                cspArr = [];

                Object.keys(policies).forEach(function (k) {
                  cspArr.push(k + ' ' + policies[k].join(' '));
                });
                cspStr = cspArr.join('; ');
              }
              res.setHeader('Content-Security-Policy', cspStr);
            }

            // Send response
            res.setHeader('Content-Type', 'text/html; charset=utf-8');
            res.setHeader('Content-Length', Buffer.byteLength(html));
            res.end(html, 'utf8');
            return _context.abrupt('return', html);

          case 27:
            _context.prev = 27;
            _context.t0 = _context['catch'](2);

            if (!(context && context.redirected)) {
              _context.next = 32;
              break;
            }

            consola.error(_context.t0);
            return _context.abrupt('return', _context.t0);

          case 32:

            next(_context.t0);

          case 33:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[2, 27]]);
  }));

  function nuxtMiddleware(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  }

  return nuxtMiddleware;
})();

var jsdom = null;

var Renderer = function () {
  function Renderer(nuxt) {
    classCallCheck(this, Renderer);

    this.nuxt = nuxt;
    this.options = nuxt.options;

    // Will be set by createRenderer
    this.bundleRenderer = null;
    this.metaRenderer = null;

    // Will be available on dev
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;

    // Create new connect instance
    this.app = connect();

    // Renderer runtime resources
    this.resources = {
      clientManifest: null,
      serverBundle: null,
      ssrTemplate: null,
      spaTemplate: null,
      errorTemplate: parseTemplate('Nuxt.js Internal Server Error')
    };
  }

  createClass(Renderer, [{
    key: 'ready',
    value: function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.nuxt.callHook('render:before', this, this.options.render);

              case 2:
                _context.next = 4;
                return this.setupMiddleware();

              case 4:
                if (this.options.dev) {
                  _context.next = 7;
                  break;
                }

                _context.next = 7;
                return this.loadResources();

              case 7:
                _context.next = 9;
                return this.nuxt.callHook('render:done', this);

              case 9:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function ready() {
        return _ref.apply(this, arguments);
      }

      return ready;
    }()
  }, {
    key: 'loadResources',
    value: function () {
      var _ref2 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this = this;

        var _fs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : fsExtra;

        var distPath, updated, errorTemplatePath, loadingHTMLPath;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                distPath = path.resolve(this.options.buildDir, 'dist');
                updated = [];


                resourceMap.forEach(function (_ref3) {
                  var key = _ref3.key,
                      fileName = _ref3.fileName,
                      transform = _ref3.transform;

                  var rawKey = '$$' + key;
                  var _path = path.join(distPath, fileName);

                  var rawData = void 0,
                      data = void 0;
                  if (!_fs.existsSync(_path)) {
                    return; // Resource not exists
                  }
                  rawData = _fs.readFileSync(_path, 'utf8');
                  if (!rawData || rawData === _this.resources[rawKey]) {
                    return; // No changes
                  }
                  _this.resources[rawKey] = rawData;
                  data = transform(rawData);
                  /* istanbul ignore if */
                  if (!data) {
                    return; // Invalid data ?
                  }
                  _this.resources[key] = data;
                  updated.push(key);
                });

                // Reload error template
                errorTemplatePath = path.resolve(this.options.buildDir, 'views/error.html');

                if (fsExtra.existsSync(errorTemplatePath)) {
                  this.resources.errorTemplate = parseTemplate(fsExtra.readFileSync(errorTemplatePath, 'utf8'));
                }

                // Load loading template
                loadingHTMLPath = path.resolve(this.options.buildDir, 'loading.html');

                if (fsExtra.existsSync(loadingHTMLPath)) {
                  this.resources.loadingHTML = fsExtra.readFileSync(loadingHTMLPath, 'utf8');
                  this.resources.loadingHTML = this.resources.loadingHTML.replace(/\r|\n|[\t\s]{3,}/g, '');
                } else {
                  this.resources.loadingHTML = '';
                }

                // Call resourcesLoaded plugin
                _context2.next = 9;
                return this.nuxt.callHook('render:resourcesLoaded', this.resources);

              case 9:

                if (updated.length > 0) {
                  this.createRenderer();
                }

              case 10:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function loadResources() {
        return _ref2.apply(this, arguments);
      }

      return loadResources;
    }()
  }, {
    key: 'createRenderer',
    value: function createRenderer() {
      // Ensure resources are available
      if (!this.isResourcesAvailable) {
        return;
      }

      // Create Meta Renderer
      this.metaRenderer = new MetaRenderer(this.nuxt, this);

      // Skip following steps if noSSR mode
      if (this.noSSR) {
        return;
      }

      // Create bundle renderer for SSR
      this.bundleRenderer = vueServerRenderer.createBundleRenderer(this.resources.serverBundle, Object.assign({
        clientManifest: this.resources.clientManifest,
        runInNewContext: false,
        basedir: this.options.rootDir
      }, this.options.render.bundleRenderer));
    }
  }, {
    key: 'useMiddleware',
    value: function useMiddleware(m) {
      // Resolve
      var $m = m;
      if (typeof m === 'string') {
        m = this.nuxt.requireModule(m);
      }
      if (typeof m.handler === 'string') {
        m.handler = this.nuxt.requireModule(m.handler);
      }

      var handler = m.handler || m;
      var path$$1 = ((m.prefix !== false ? this.options.router.base : '') + (typeof m.path === 'string' ? m.path : '')).replace(/\/\//g, '/');
      handler.$m = $m;

      // Use middleware
      this.app.use(path$$1, handler);
    }
  }, {
    key: 'setupMiddleware',
    value: function () {
      var _ref4 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _this2 = this;

        var staticMiddleware, distDir;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.nuxt.callHook('render:setupMiddleware', this.app);

              case 2:

                // Gzip middleware for production
                if (!this.options.dev && this.options.render.gzip) {
                  this.useMiddleware(compression(this.options.render.gzip));
                }

                // Common URL checks
                this.useMiddleware(function (req, res, next) {
                  // Prevent access to SSR resources
                  if (ssrResourceRegex.test(req.url)) {
                    res.statusCode = 404;
                    return res.end();
                  }
                  next();
                });

                // Add webpack middleware only for development
                if (this.options.dev) {
                  this.useMiddleware(function () {
                    var _ref5 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(req, res, next) {
                      return regeneratorRuntime.wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              if (!_this2.webpackDevMiddleware) {
                                _context3.next = 3;
                                break;
                              }

                              _context3.next = 3;
                              return _this2.webpackDevMiddleware(req, res);

                            case 3:
                              if (!_this2.webpackHotMiddleware) {
                                _context3.next = 6;
                                break;
                              }

                              _context3.next = 6;
                              return _this2.webpackHotMiddleware(req, res);

                            case 6:
                              next();

                            case 7:
                            case 'end':
                              return _context3.stop();
                          }
                        }
                      }, _callee3, _this2);
                    }));

                    return function (_x2, _x3, _x4) {
                      return _ref5.apply(this, arguments);
                    };
                  }());
                }

                // open in editor for debug mode only
                if (this.options.debug && this.options.dev) {
                  this.useMiddleware({
                    path: '__open-in-editor',
                    handler: launchMiddleware(this.options.editor)
                  });
                }

                // For serving static/ files to /
                staticMiddleware = serveStatic(path.resolve(this.options.srcDir, this.options.dir.static), this.options.render.static);

                staticMiddleware.prefix = this.options.render.static.prefix;
                this.useMiddleware(staticMiddleware);

                // Serve .nuxt/dist/ files only for production
                // For dev they will be served with devMiddleware
                if (!this.options.dev) {
                  distDir = path.resolve(this.options.buildDir, 'dist');

                  this.useMiddleware({
                    path: this.publicPath,
                    handler: serveStatic(distDir, {
                      index: false, // Don't serve index.html template
                      maxAge: '1y' // 1 year in production
                    })
                  });
                }

                // Add User provided middleware
                this.options.serverMiddleware.forEach(function (m) {
                  _this2.useMiddleware(m);
                });

                // Finally use nuxtMiddleware
                this.useMiddleware(nuxtMiddleware.bind(this));

                // Error middleware for errors that occurred in middleware that declared above
                // Middleware should exactly take 4 arguments
                // https://github.com/senchalabs/connect#error-middleware

                // Apply errorMiddleware from modules first
                _context4.next = 14;
                return this.nuxt.callHook('render:errorMiddleware', this.app);

              case 14:

                // Apply errorMiddleware from Nuxt
                this.useMiddleware(errorMiddleware.bind(this));

              case 15:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setupMiddleware() {
        return _ref4.apply(this, arguments);
      }

      return setupMiddleware;
    }()
  }, {
    key: 'renderTemplate',
    value: function renderTemplate(ssr, opts) {
      // Fix problem with HTMLPlugin's minify option (#3392)
      opts.html_attrs = opts.HTML_ATTRS;
      opts.body_attrs = opts.BODY_ATTRS;

      var fn = ssr ? this.resources.ssrTemplate : this.resources.spaTemplate;

      return fn(opts);
    }
  }, {
    key: 'renderRoute',
    value: function () {
      var _ref6 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(url) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var spa, ENV, _ref7, HTML_ATTRS, BODY_ATTRS, _HEAD, BODY_SCRIPTS, getPreloadFiles, _APP, err, _html, APP, m, HEAD, serializedSession, cspScriptSrcHashes, hashAlgorithm, hash$$1, html;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this.isReady) {
                  _context5.next = 4;
                  break;
                }

                _context5.next = 3;
                return waitFor(1000);

              case 3:
                return _context5.abrupt('return', this.renderRoute(url, context));

              case 4:

                // Log rendered url
                consola.debug('Rendering url ' + url);

                // Add url and isSever to the context
                context.url = url;

                // Basic response if SSR is disabled or spa data provided
                spa = context.spa || context.res && context.res.spa;
                ENV = this.options.env;

                if (!(this.noSSR || spa)) {
                  _context5.next = 23;
                  break;
                }

                _context5.next = 11;
                return this.metaRenderer.render(context);

              case 11:
                _ref7 = _context5.sent;
                HTML_ATTRS = _ref7.HTML_ATTRS;
                BODY_ATTRS = _ref7.BODY_ATTRS;
                _HEAD = _ref7.HEAD;
                BODY_SCRIPTS = _ref7.BODY_SCRIPTS;
                getPreloadFiles = _ref7.getPreloadFiles;
                _APP = '<div id="__nuxt">' + this.resources.loadingHTML + '</div>' + BODY_SCRIPTS;

                // Detect 404 errors

                if (!(url.includes(this.options.build.publicPath) || url.includes('__webpack'))) {
                  _context5.next = 21;
                  break;
                }

                err = {
                  statusCode: 404,
                  message: this.options.messages.error_404,
                  name: 'ResourceNotFound'
                };
                throw err;

              case 21:
                _html = this.renderTemplate(false, {
                  HTML_ATTRS: HTML_ATTRS,
                  BODY_ATTRS: BODY_ATTRS,
                  HEAD: _HEAD,
                  APP: _APP,
                  ENV: ENV
                });
                return _context5.abrupt('return', { html: _html, getPreloadFiles: getPreloadFiles });

              case 23:
                _context5.next = 25;
                return this.bundleRenderer.renderToString(context);

              case 25:
                APP = _context5.sent;


                if (!context.nuxt.serverRendered) {
                  APP = '<div id="__nuxt"></div>';
                }
                m = context.meta.inject();
                HEAD = m.title.text() + m.meta.text() + m.link.text() + m.style.text() + m.script.text() + m.noscript.text();

                if (this.options._routerBaseSpecified) {
                  HEAD += '<base href="' + this.options.router.base + '">';
                }

                if (this.options.render.resourceHints) {
                  HEAD += context.renderResourceHints();
                }

                _context5.next = 33;
                return this.nuxt.callHook('render:context', context.nuxt);

              case 33:
                serializedSession = 'window.__NUXT__=' + serialize(context.nuxt, {
                  isJSON: true
                }) + ';';
                cspScriptSrcHashes = [];

                if (this.options.render.csp) {
                  hashAlgorithm = this.options.render.csp.hashAlgorithm;
                  hash$$1 = crypto.createHash(hashAlgorithm);

                  hash$$1.update(serializedSession);
                  cspScriptSrcHashes.push('\'' + hashAlgorithm + '-' + hash$$1.digest('base64') + '\'');
                }

                APP += '<script>' + serializedSession + '</script>';
                APP += context.renderScripts();
                APP += m.script.text({ body: true });
                APP += m.noscript.text({ body: true });

                HEAD += context.renderStyles();

                html = this.renderTemplate(true, {
                  HTML_ATTRS: 'data-n-head-ssr ' + m.htmlAttrs.text(),
                  BODY_ATTRS: m.bodyAttrs.text(),
                  HEAD: HEAD,
                  APP: APP,
                  ENV: ENV
                });
                return _context5.abrupt('return', {
                  html: html,
                  cspScriptSrcHashes: cspScriptSrcHashes,
                  getPreloadFiles: context.getPreloadFiles,
                  error: context.nuxt.error,
                  redirected: context.redirected
                });

              case 43:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function renderRoute(_x6) {
        return _ref6.apply(this, arguments);
      }

      return renderRoute;
    }()
  }, {
    key: 'renderAndGetWindow',
    value: function () {
      var _ref8 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(url) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var options, jsdomErrHandler, _ref9, window, nuxtExists, error;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (jsdom) {
                  _context6.next = 9;
                  break;
                }

                _context6.prev = 1;

                jsdom = require('jsdom');
                _context6.next = 9;
                break;

              case 5:
                _context6.prev = 5;
                _context6.t0 = _context6['catch'](1);

                consola.error('\n         Fail when calling nuxt.renderAndGetWindow(url)\n         jsdom module is not installed\n         Please install jsdom with: npm install --save-dev jsdom\n        ');
                throw _context6.t0;

              case 9:
                options = {
                  resources: 'usable', // load subresources (https://github.com/tmpvar/jsdom#loading-subresources)
                  runScripts: 'dangerously',
                  beforeParse: function beforeParse(window) {
                    // Mock window.scrollTo
                    window.scrollTo = function () {};
                  }
                };

                jsdomErrHandler = function jsdomErrHandler(err) {
                  throw err;
                };

                if (opts.virtualConsole !== false) {
                  options.virtualConsole = new jsdom.VirtualConsole().sendTo(consola);
                  // throw error when window creation failed
                  options.virtualConsole.on('jsdomError', jsdomErrHandler);
                }
                url = url || 'http://localhost:3000';
                _context6.next = 15;
                return jsdom.JSDOM.fromURL(url, options);

              case 15:
                _ref9 = _context6.sent;
                window = _ref9.window;

                // If Nuxt could not be loaded (error from the server-side)
                nuxtExists = window.document.body.innerHTML.includes(this.options.render.ssr ? 'window.__NUXT__' : '<div id="__nuxt">');
                /* istanbul ignore if */

                if (nuxtExists) {
                  _context6.next = 22;
                  break;
                }

                error = new Error('Could not load the nuxt app');

                error.body = window.document.body.innerHTML;
                throw error;

              case 22:
                _context6.next = 24;
                return timeout(new Promise(function (resolve) {
                  window._onNuxtLoaded = function () {
                    return resolve(window);
                  };
                }), 20000, 'Components loading in renderAndGetWindow was not completed in 20s');

              case 24:
                if (opts.virtualConsole !== false) {
                  // after window initialized successfully
                  options.virtualConsole.removeListener('jsdomError', jsdomErrHandler);
                }
                // Send back window object
                return _context6.abrupt('return', window);

              case 26:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this, [[1, 5]]);
      }));

      function renderAndGetWindow(_x8) {
        return _ref8.apply(this, arguments);
      }

      return renderAndGetWindow;
    }()
  }, {
    key: 'noSSR',
    get: function get$$1() {
      return this.options.render.ssr === false;
    }
  }, {
    key: 'isReady',
    get: function get$$1() {
      if (this.noSSR) {
        return Boolean(this.resources.spaTemplate);
      }

      return Boolean(this.bundleRenderer && this.resources.ssrTemplate);
    }
  }, {
    key: 'isResourcesAvailable',
    get: function get$$1() {
      // Required for both
      /* istanbul ignore if */
      if (!this.resources.clientManifest) {
        return false;
      }

      // Required for SPA rendering
      if (this.noSSR) {
        return Boolean(this.resources.spaTemplate);
      }

      // Required for bundle renderer
      return Boolean(this.resources.ssrTemplate && this.resources.serverBundle);
    }
  }, {
    key: 'publicPath',
    get: function get$$1() {
      return isUrl(this.options.build.publicPath) ? defaults$1.build.publicPath : this.options.build.publicPath;
    }
  }]);
  return Renderer;
}();


var parseTemplate = function parseTemplate(templateStr) {
  return ___default.template(templateStr, {
    interpolate: /{{([\s\S]+?)}}/g
  });
};

var resourceMap = [{
  key: 'clientManifest',
  fileName: 'vue-ssr-client-manifest.json',
  transform: JSON.parse
}, {
  key: 'serverBundle',
  fileName: 'server-bundle.json',
  transform: JSON.parse
}, {
  key: 'ssrTemplate',
  fileName: 'index.ssr.html',
  transform: parseTemplate
}, {
  key: 'spaTemplate',
  fileName: 'index.spa.html',
  transform: parseTemplate
}];

// Protector utility against request to SSR bundle files
var ssrResourceRegex = new RegExp(resourceMap.map(function (resource) {
  return resource.fileName;
}).join('|'), 'i');

var Nuxt = function () {
  function Nuxt() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Nuxt);

    this.options = Options.from(options);

    this.readyMessage = null;
    this.initialized = false;

    // Hooks
    this._hooks = {};
    this.hook = this.hook.bind(this);

    // Create instance of core components
    this.moduleContainer = new ModuleContainer(this);
    this.renderer = new Renderer(this);

    // Backward compatibility
    this.render = this.renderer.app;
    this.renderRoute = this.renderer.renderRoute.bind(this.renderer);
    this.renderAndGetWindow = this.renderer.renderAndGetWindow.bind(this.renderer);

    // ESM Loader
    this.esm = esm(module, {});

    this._ready = this.ready().catch(function (err) {
      consola.fatal(err);
    });
  }

  createClass(Nuxt, [{
    key: 'ready',
    value: function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._ready) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt('return', this._ready);

              case 2:

                // Add hooks
                if (___default.isPlainObject(this.options.hooks)) {
                  this.addObjectHooks(this.options.hooks);
                } else if (typeof this.options.hooks === 'function') {
                  this.options.hooks(this.hook);
                }

                // Await for modules
                _context.next = 5;
                return this.moduleContainer.ready();

              case 5:
                _context.next = 7;
                return this.renderer.ready();

              case 7:

                this.initialized = true;

                // Call ready hook
                _context.next = 10;
                return this.callHook('ready', this);

              case 10:
                return _context.abrupt('return', this);

              case 11:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function ready() {
        return _ref.apply(this, arguments);
      }

      return ready;
    }()
  }, {
    key: 'hook',
    value: function hook(name$$1, fn) {
      if (!name$$1 || typeof fn !== 'function') {
        return;
      }
      this._hooks[name$$1] = this._hooks[name$$1] || [];
      this._hooks[name$$1].push(fn);
    }
  }, {
    key: 'callHook',
    value: function () {
      var _ref2 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(name$$1) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this._hooks[name$$1]) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return');

              case 2:
                consola.debug('Call ' + name$$1 + ' hooks (' + this._hooks[name$$1].length + ')');
                _context2.prev = 3;
                _context2.next = 6;
                return sequence(this._hooks[name$$1], function (fn) {
                  return fn.apply(undefined, toConsumableArray(args));
                });

              case 6:
                _context2.next = 12;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2['catch'](3);

                consola.error(_context2.t0);
                this.callHook('error', _context2.t0);

              case 12:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this, [[3, 8]]);
      }));

      function callHook(_x2) {
        return _ref2.apply(this, arguments);
      }

      return callHook;
    }()
  }, {
    key: 'addObjectHooks',
    value: function addObjectHooks(hooksObj) {
      var _this = this;

      Object.keys(hooksObj).forEach(function (name$$1) {
        var hooks = hooksObj[name$$1];
        hooks = Array.isArray(hooks) ? hooks : [hooks];

        hooks.forEach(function (hook) {
          _this.hook(name$$1, hook);
        });
      });
    }
  }, {
    key: 'showReady',
    value: function showReady() {
      var clear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (!this.readyMessage) {
        return;
      }

      consola.ready({
        message: this.readyMessage,
        badge: true,
        clear: clear
      });
    }
  }, {
    key: 'listen',
    value: function listen() {
      var _this2 = this;

      var port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;
      var host = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'localhost';

      return this.ready().then(function () {
        return new Promise(function (resolve, reject) {
          var server = _this2.renderer.app.listen({ port: port, host: host, exclusive: false }, function (err) {
            /* istanbul ignore if */
            if (err) {
              return reject(err);
            }

            var listenURL = Chalk.underline.blue('http://' + host + ':' + port);
            _this2.readyMessage = 'Listening on ' + listenURL;

            // Close server on nuxt close
            _this2.hook('close', function () {
              return new Promise(function (resolve, reject) {
                // Destroy server by forcing every connection to be closed
                server.destroy(function (err) {
                  consola.debug('server closed');
                  /* istanbul ignore if */
                  if (err) {
                    return reject(err);
                  }
                  resolve();
                });
              });
            });

            _this2.callHook('listen', server, { port: port, host: host }).then(resolve);
          });

          // Add server.destroy(cb) method
          enableDestroy(server);
        });
      });
    }
  }, {
    key: 'resolveAlias',
    value: function resolveAlias(_path) {
      if (_path.indexOf('@@') === 0 || _path.indexOf('~~') === 0) {
        return path.join(this.options.rootDir, _path.substr(2));
      }

      if (_path.indexOf('@') === 0 || _path.indexOf('~') === 0) {
        return path.join(this.options.srcDir, _path.substr(1));
      }

      return path.resolve(this.options.srcDir, _path);
    }
  }, {
    key: 'resolvePath',
    value: function resolvePath(_path) {
      // Try to resolve using NPM resolve path first
      try {
        var resolvedPath = Module._resolveFilename(_path, {
          paths: this.options.modulesDir
        });
        return resolvedPath;
      } catch (error) {
        if (error.code !== 'MODULE_NOT_FOUND') {
          throw error;
        }
      }

      var __path = this.resolveAlias(_path);

      if (fsExtra.existsSync(__path)) {
        return __path;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.options.extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ext = _step.value;

          if (fsExtra.existsSync(__path + '.' + ext)) {
            return __path + '.' + ext;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      throw new Error('Cannot resolve "' + _path + '" from "' + __path + '"');
    }
  }, {
    key: 'requireModule',
    value: function requireModule(_path) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _resovledPath = this.resolvePath(_path);
      var m = opts.esm === false ? require(_resovledPath) : this.esm(_resovledPath);
      return m && m.default || m;
    }
  }, {
    key: 'close',
    value: function () {
      var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(callback) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.callHook('close', this);

              case 2:
                if (!(typeof callback === 'function')) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 5;
                return callback();

              case 5:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function close(_x7) {
        return _ref3.apply(this, arguments);
      }

      return close;
    }()
  }], [{
    key: 'version',
    get: function get$$1() {
      return packageJSON.version;
    }
  }]);
  return Nuxt;
}();

var core = {
  Nuxt: Nuxt,
  Module: ModuleContainer,
  Renderer: Renderer
};

// https://github.com/webpack-contrib/thread-loader
// https://github.com/webpack-contrib/cache-loader

var PerfLoader = function () {
  function PerfLoader(options) {
    classCallCheck(this, PerfLoader);

    this.options = options;
    this.warmup = threadLoader.warmup;
    this.workerPools = {
      js: {
        name: 'js',
        poolTimeout: this.options.dev ? Infinity : 2000
      },
      css: {
        name: 'css',
        poolTimeout: this.options.dev ? Infinity : 2000
      }
    };
  }

  createClass(PerfLoader, [{
    key: 'warmupAll',
    value: function warmupAll() {
      this.warmup(this.workerPools.js, ['babel-loader', 'babel-preset-env']);
      this.warmup(this.workerPools.css, ['css-loader']);
    }
  }, {
    key: 'pool',
    value: function pool(poolName, _loaders) {
      var loaders = [].concat(_loaders);

      if (this.options.build.parallel) {
        var pool = this.workerPools[poolName];
      }

      if (this.options.build.cache) {
        loaders.unshift({
          loader: 'cache-loader',
          options: {
            cacheDirectory: path.resolve('node_modules/.cache/cache-loader')
          }
        });
      }

      return loaders;
    }
  }, {
    key: 'poolOneOf',
    value: function poolOneOf(poolName, oneOfRules) {
      var _this = this;

      // disable css thread pool since vue-style-loader needs options like: target
      if (poolName === 'css' && !this.options.build.extractCSS) {
        return oneOfRules;
      }
      return oneOfRules.map(function (rule) {
        return Object.assign({}, rule, {
          use: _this.pool(poolName, rule.use)
        });
      });
    }
  }]);
  return PerfLoader;
}();

var prefix = '[vue-server-renderer-webpack-plugin]';
var warn = function warn(msg) {
  return console.error(Chalk.red(prefix + ' ' + msg + '\n'));
}; // eslint-disable-line no-console
var tip = function tip(msg) {
  return console.log(Chalk.yellow(prefix + ' ' + msg + '\n'));
}; // eslint-disable-line no-console

var validate = function validate(compiler) {
  if (compiler.options.target !== 'node') {
    warn('webpack config `target` should be "node".');
  }

  if (compiler.options.output && compiler.options.output.libraryTarget !== 'commonjs2') {
    warn('webpack config `output.libraryTarget` should be "commonjs2".');
  }

  if (!compiler.options.externals) {
    tip('It is recommended to externalize dependencies in the server build for ' + 'better build performance.');
  }
};

var onEmit = function onEmit(compiler, name, hook) {
  if (compiler.hooks) {
    // Webpack >= 4.0.0
    compiler.hooks.emit.tapAsync(name, hook);
  } else {
    // Webpack < 4.0.0
    compiler.plugin('emit', hook);
  }
};

var isJS = function isJS(file) {
  return (/\.js(\?[^.]+)?$/.test(file)
  );
};

var isCSS = function isCSS(file) {
  return (/\.css(\?[^.]+)?$/.test(file)
  );
};

var VueSSRClientPlugin = function () {
  function VueSSRClientPlugin() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, VueSSRClientPlugin);

    this.options = Object.assign({
      filename: 'vue-ssr-client-manifest.json'
    }, options);
  }

  createClass(VueSSRClientPlugin, [{
    key: 'apply',
    value: function apply(compiler) {
      var _this = this;

      onEmit(compiler, 'vue-client-plugin', function (compilation, cb) {
        var stats = compilation.getStats().toJson();

        var allFiles = _.uniq(stats.assets.map(function (a) {
          return a.name;
        }));

        var initialFiles = _.uniq(Object.keys(stats.entrypoints).map(function (name) {
          return stats.entrypoints[name].assets;
        }).reduce(function (assets, all) {
          return all.concat(assets);
        }, []).filter(function (file) {
          return isJS(file) || isCSS(file);
        }));

        var asyncFiles = allFiles.filter(function (file) {
          return isJS(file) || isCSS(file);
        }).filter(function (file) {
          return initialFiles.indexOf(file) < 0;
        });

        var manifest = {
          publicPath: stats.publicPath,
          all: allFiles,
          initial: initialFiles,
          async: asyncFiles,
          modules: {/* [identifier: string]: Array<index: number> */}
        };

        var assetModules = stats.modules.filter(function (m) {
          return m.assets.length;
        });
        var fileToIndex = function fileToIndex(file) {
          return manifest.all.indexOf(file);
        };
        stats.modules.forEach(function (m) {
          // ignore modules duplicated in multiple chunks
          if (m.chunks.length === 1) {
            var cid = m.chunks[0];
            var chunk = stats.chunks.find(function (c) {
              return c.id === cid;
            });
            if (!chunk || !chunk.files) {
              return;
            }
            var id = m.identifier.replace(/\s\w+$/, ''); // remove appended hash
            var files = manifest.modules[hash(id)] = chunk.files.map(fileToIndex);
            // find all asset modules associated with the same chunk
            assetModules.forEach(function (m) {
              if (m.chunks.some(function (id) {
                return id === cid;
              })) {
                files.push.apply(files, m.assets.map(fileToIndex));
              }
            });
          }
        });

        // const debug = (file, obj) => {
        //   require('fs').writeFileSync(__dirname + '/' + file, JSON.stringify(obj, null, 2))
        // }
        // debug('stats.json', stats)
        // debug('client-manifest.json', manifest)

        var json = JSON.stringify(manifest, null, 2);
        compilation.assets[_this.options.filename] = {
          source: function source() {
            return json;
          },
          size: function size() {
            return json.length;
          }
        };
        cb();
      });
    }
  }]);
  return VueSSRClientPlugin;
}();

var PostcssConfig = function () {
  function PostcssConfig(options, nuxt) {
    classCallCheck(this, PostcssConfig);

    this.nuxt = nuxt;
    this.postcss = options.build.postcss;
    this.srcDir = options.srcDir;
    this.rootDir = options.rootDir;
    this.cssSourceMap = options.build.cssSourceMap;
    this.modulesDir = options.modulesDir;
  }

  createClass(PostcssConfig, [{
    key: 'configFromFile',
    value: function configFromFile() {
      // Search for postCSS config file and use it if exists
      // https://github.com/michael-ciniawsky/postcss-load-config
      var _arr = [this.srcDir, this.rootDir];
      for (var _i = 0; _i < _arr.length; _i++) {
        var dir = _arr[_i];var _arr2 = ['postcss.config.js', '.postcssrc.js', '.postcssrc', '.postcssrc.json', '.postcssrc.yaml'];

        for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
          var file = _arr2[_i2];
          if (fs.existsSync(path.resolve(dir, file))) {
            var postcssConfigPath = path.resolve(dir, file);
            return {
              sourceMap: this.cssSourceMap,
              config: {
                path: postcssConfigPath
              }
            };
          }
        }
      }
    }
  }, {
    key: 'normalize',
    value: function normalize(config) {
      if (Array.isArray(config)) {
        config = { plugins: config };
      }
      return config;
    }
  }, {
    key: 'loadPlugins',
    value: function loadPlugins(config) {
      var plugins = config.plugins;
      if (isPureObject(plugins)) {
        // Map postcss plugins into instances on object mode once
        config.plugins = Object.keys(plugins).map(function (p) {
          var plugin = require(p);
          var opts = plugins[p];
          if (opts === false) return; // Disabled
          var instance = plugin(opts);
          return instance;
        }).filter(function (e) {
          return e;
        });
      }
    }
  }, {
    key: 'config',
    value: function config() {
      /* istanbul ignore if */
      if (!this.postcss) {
        return false;
      }

      var config = this.configFromFile();
      if (config) {
        return config;
      }

      config = this.normalize(___default.cloneDeep(this.postcss));

      // Apply default plugins
      if (isPureObject(config)) {
        ___default.defaults(config, this.defaultConfig);

        this.loadPlugins(config);
      }

      return config;
    }
  }, {
    key: 'defaultConfig',
    get: function get$$1() {
      return {
        useConfigFile: false,
        sourceMap: this.cssSourceMap,
        plugins: {
          // https://github.com/postcss/postcss-import
          'postcss-import': {
            resolve: createResolver({
              alias: {
                '~': path.join(this.srcDir),
                '~~': path.join(this.rootDir),
                '@': path.join(this.srcDir),
                '@@': path.join(this.rootDir)
              },
              modules: [this.srcDir, this.rootDir].concat(toConsumableArray(this.modulesDir))
            })
          },

          // https://github.com/postcss/postcss-url
          'postcss-url': {},

          // https://github.com/csstools/postcss-preset-env
          'postcss-preset-env': {
            // https://cssdb.org/#staging-process
            stage: 2
          }
        }
      };
    }
  }]);
  return PostcssConfig;
}();

var StyleLoader = function () {
  function StyleLoader(options, nuxt, _ref) {
    var isServer = _ref.isServer;
    classCallCheck(this, StyleLoader);

    this.isServer = isServer;
    this.dev = options.dev;
    this.srcDir = options.srcDir;
    this.assetsDir = options.dir.assets;
    this.staticDir = options.dir.static;
    this.extractCSS = options.build.extractCSS;
    this.resources = options.build.styleResources;
    this.sourceMap = Boolean(options.build.cssSourceMap);

    if (options.build.postcss) {
      this.postcssConfig = new PostcssConfig(options, nuxt);
    }
  }

  createClass(StyleLoader, [{
    key: 'normalize',
    value: function normalize(loaders) {
      var _this = this;

      loaders = Array.isArray(loaders) ? loaders : [loaders];
      return loaders.map(function (loader) {
        return Object.assign({ options: { sourceMap: _this.sourceMap } }, typeof loader === 'string' ? { loader: loader } : loader);
      });
    }
  }, {
    key: 'styleResource',
    value: function styleResource(ext) {
      var extResource = this.resources[ext];
      // style-resources-loader
      // https://github.com/yenshih/style-resources-loader
      if (extResource) {
        var patterns = Array.isArray(extResource) ? extResource : [extResource];

        return {
          loader: 'style-resources-loader',
          options: Object.assign({ patterns: patterns }, this.resources.options || {})
        };
      }
    }
  }, {
    key: 'postcss',
    value: function postcss() {
      // postcss-loader
      // https://github.com/postcss/postcss-loader
      if (this.postcssConfig) {
        var config = this.postcssConfig.config();
        if (config) {
          return {
            loader: 'postcss-loader',
            options: Object.assign({ sourceMap: this.sourceMap }, config)
          };
        }
      }
    }
  }, {
    key: 'css',
    value: function css(importLoaders, options) {
      var _cssLoaderAlias;

      // css-loader
      // https://github.com/webpack-contrib/css-loader
      var cssLoaderAlias = (_cssLoaderAlias = {}, defineProperty(_cssLoaderAlias, '/' + this.assetsDir, path.join(this.srcDir, this.assetsDir)), defineProperty(_cssLoaderAlias, '/' + this.staticDir, path.join(this.srcDir, this.staticDir)), _cssLoaderAlias);

      return {
        loader: this.isServer && this.extractCSS ? 'css-loader/locals' : 'css-loader',
        options: Object.assign({
          sourceMap: this.sourceMap,
          minimize: !this.dev,
          importLoaders: importLoaders,
          alias: cssLoaderAlias
        }, options)
      };
    }
  }, {
    key: 'extract',
    value: function extract() {
      if (this.extractCSS && !this.isServer) {
        return MiniCssExtractPlugin.loader;
      }
    }
  }, {
    key: 'vueStyle',
    value: function vueStyle() {
      // https://github.com/vuejs/vue-style-loader
      return {
        loader: 'vue-style-loader',
        options: { sourceMap: this.sourceMap }
      };
    }
  }, {
    key: 'apply',
    value: function apply(ext) {
      var loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var customLoaders = [].concat(this.postcss(loaders), this.normalize(loaders), this.styleResource(ext)).filter(Boolean);

      var styleLoader = this.extract() || this.vueStyle();

      return [
      // This matches <style module>
      {
        resourceQuery: /module/,
        use: [].concat(styleLoader, this.css(customLoaders.length, {
          modules: true,
          localIdentName: '[local]_[hash:base64:5]'
        }), customLoaders)
      },
      // This matches plain <style> or <style scoped>
      {
        use: [].concat(styleLoader, this.css(customLoaders.length), customLoaders)
      }];
    }
  }]);
  return StyleLoader;
}();

var WarnFixPlugin = function () {
  function WarnFixPlugin() {
    classCallCheck(this, WarnFixPlugin);
  }

  createClass(WarnFixPlugin, [{
    key: 'apply',
    value: function apply(compiler) /* istanbul ignore next */{
      compiler.hooks.done.tap('warnfix-plugin', function (stats) {
        stats.compilation.warnings = stats.compilation.warnings.filter(function (warn) {
          if (warn.name === 'ModuleDependencyWarning' && warn.message.includes('export \'default\'') && warn.message.includes('nuxt_plugin_')) {
            return false;
          }
          return true;
        });
      });
    }
  }]);
  return WarnFixPlugin;
}();

var StatsPlugin = function () {
  function StatsPlugin(statsOptions) {
    classCallCheck(this, StatsPlugin);

    this.statsOptions = statsOptions;
  }

  createClass(StatsPlugin, [{
    key: 'apply',
    value: function apply(compiler) {
      var _this = this;

      compiler.hooks.done.tap('stats-plugin', function (stats) {
        process.stdout.write('\n' + stats.toString(_this.statsOptions) + '\n');
      });
    }
  }]);
  return StatsPlugin;
}();

var WebpackBaseConfig = function () {
  function WebpackBaseConfig(builder, options) {
    classCallCheck(this, WebpackBaseConfig);

    this.name = options.name;
    this.isServer = options.isServer;
    this.builder = builder;
    this.nuxt = this.builder.nuxt;
    this.isStatic = builder.isStatic;
    this.options = builder.options;
    this.spinner = builder.spinner;
  }

  createClass(WebpackBaseConfig, [{
    key: 'getBabelOptions',
    value: function getBabelOptions() {
      var options = ___default.clone(this.options.build.babel);

      if (typeof options.presets === 'function') {
        options.presets = options.presets({ isServer: this.isServer });
      }

      if (!options.babelrc && !options.presets) {
        options.presets = [[require.resolve('babel-preset-vue-app'), {
          targets: this.isServer ? { node: 'current' } : { ie: 9, uglify: true }
        }]];
      }

      return options;
    }
  }, {
    key: 'getFileName',
    value: function getFileName(name) {
      var fileName = this.options.build.filenames[name];

      // Don't use hashes when watching
      // https://github.com/webpack/webpack/issues/1914#issuecomment-174171709
      if (this.options.dev) {
        fileName = fileName.replace(/\[(chunkhash|contenthash|hash)\]\./g, '');
      }

      // Don't use [name] for production assets
      if (!this.options.dev && this.options.build.optimization.splitChunks.name !== true) {
        fileName = fileName.replace(/\[name\]\./g, '');
      }

      return fileName;
    }
  }, {
    key: 'env',
    value: function env$$1() {
      var env$$1 = {
        'process.mode': JSON.stringify(this.options.mode),
        'process.static': this.isStatic
      };
      ___default.each(this.options.env, function (value, key) {
        env$$1['process.env.' + key] = ['boolean', 'number'].indexOf(typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== -1 ? value : JSON.stringify(value);
      });
      return env$$1;
    }
  }, {
    key: 'output',
    value: function output() {
      return {
        path: path.resolve(this.options.buildDir, 'dist'),
        filename: this.getFileName('app'),
        chunkFilename: this.getFileName('chunk'),
        publicPath: isUrl(this.options.build.publicPath) ? this.options.build.publicPath : urlJoin(this.options.router.base, this.options.build.publicPath)
      };
    }
  }, {
    key: 'alias',
    value: function alias() {
      var _ref;

      return _ref = {
        '~': path.join(this.options.srcDir),
        '~~': path.join(this.options.rootDir),
        '@': path.join(this.options.srcDir),
        '@@': path.join(this.options.rootDir)
      }, defineProperty(_ref, this.options.dir.assets, path.join(this.options.srcDir, this.options.dir.assets)), defineProperty(_ref, this.options.dir.static, path.join(this.options.srcDir, this.options.dir.static)), _ref;
    }
  }, {
    key: 'rules',
    value: function rules() {
      var _this = this;

      var styleLoader = new StyleLoader(this.options, this.builder.nuxt, { isServer: this.isServer });

      var perfLoader = this.builder.perfLoader;

      return [{
        test: /\.vue$/,
        loader: 'vue-loader',
        options: Object.assign({
          productionMode: !this.options.dev,
          transformAssetUrls: {
            video: 'src',
            source: 'src',
            object: 'src',
            embed: 'src'
          }
        }, this.options.build.vueLoader)
      }, {
        test: /\.pug$/,
        oneOf: [{
          resourceQuery: /^\?vue/,
          use: ['pug-plain-loader']
        }, {
          use: ['raw-loader', 'pug-plain-loader']
        }]
      }, {
        test: /\.jsx?$/,
        exclude: function exclude(file) {
          // not exclude files outside node_modules
          if (/node_modules/.test(file)) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = _this.options.build.transpile[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var pkg = _step.value;

                // item in transpile can be string or regex object
                if (new RegExp(pkg).test(file)) {
                  return false;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            return true;
          }
        },
        use: perfLoader.pool('js', {
          loader: 'babel-loader',
          options: this.getBabelOptions()
        })
      }, {
        test: /\.css$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('css'))
      }, {
        test: /\.less$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('less', 'less-loader'))
      }, {
        test: /\.sass$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('sass', {
          loader: 'sass-loader',
          options: { indentedSyntax: true }
        }))
      }, {
        test: /\.scss$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('scss', 'sass-loader'))
      }, {
        test: /\.styl(us)?$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('stylus', 'stylus-loader'))
      }, {
        test: /\.(png|jpe?g|gif|svg)$/,
        use: perfLoader.pool('assets', {
          loader: 'url-loader',
          options: {
            limit: 1000, // 1KO
            name: 'img/[name].[hash:7].[ext]'
          }
        })
      }, {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        use: perfLoader.pool('assets', {
          loader: 'url-loader',
          options: {
            limit: 1000, // 1 KO
            name: 'fonts/[name].[hash:7].[ext]'
          }
        })
      }, {
        test: /\.(webm|mp4)$/,
        use: perfLoader.pool('assets', {
          loader: 'file-loader',
          options: {
            name: 'videos/[name].[hash:7].[ext]'
          }
        })
      }];
    }
  }, {
    key: 'plugins',
    value: function plugins() {
      var _this2 = this;

      var plugins = [new VueLoader.VueLoaderPlugin()];

      Array.prototype.push.apply(plugins, this.options.build.plugins || []);

      // Add timefix-plugin before others plugins
      if (this.options.dev) {
        plugins.unshift(new TimeFixPlugin());
      }

      // Hide warnings about plugins without a default export (#1179)
      plugins.push(new WarnFixPlugin());

      // Build progress indicator
      plugins.push(new WebpackBar({
        profile: this.options.build.profile,
        name: this.isServer ? 'server' : 'client',
        color: this.isServer ? 'orange' : 'green',
        compiledIn: false,
        done: function done(states) {
          if (_this2.options.dev) {
            var hasErrors = Object.values(states).some(function (state) {
              return state.stats.hasErrors();
            });

            if (!hasErrors) {
              _this2.nuxt.showReady();
            }
          }
        }
      }));

      // Add stats plugin
      if (!this.options.dev && this.options.build.stats) {
        plugins.push(new StatsPlugin(this.options.build.stats));
      }

      // CSS extraction
      // MiniCssExtractPlugin does not currently supports SSR
      // https://github.com/webpack-contrib/mini-css-extract-plugin/issues/48
      // So we use css-loader/locals as a fallback (utils/style-loader)
      if (this.options.build.extractCSS && !this.isServer) {
        plugins.push(new MiniCssExtractPlugin(Object.assign({
          filename: this.getFileName('css'),
          chunkFilename: this.getFileName('css')
        }, this.options.build.extractCSS)));
      }

      return plugins;
    }
  }, {
    key: 'config',
    value: function config() {
      // Prioritize nested node_modules in webpack search path (#2558)
      var webpackModulesDir = ['node_modules'].concat(this.options.modulesDir);
      var config = {
        name: this.name,
        mode: this.options.dev ? 'development' : 'production',
        optimization: {},
        output: this.output(),
        performance: {
          maxEntrypointSize: 1000 * 1024,
          hints: this.options.dev ? false : 'warning'
        },
        resolve: {
          extensions: ['.wasm', '.mjs', '.js', '.json', '.vue', '.jsx'],
          alias: this.alias(),
          modules: webpackModulesDir
        },
        resolveLoader: {
          modules: webpackModulesDir
        },
        module: {
          noParse: /es6-promise\.js$/, // Avoid webpack shimming process
          rules: this.rules()
        },
        plugins: this.plugins()

        // Clone deep avoid leaking config between Client and Server
      };return ___default.cloneDeep(config);
    }
  }]);
  return WebpackBaseConfig;
}();

var WebpackClientConfig = function (_WebpackBaseConfig) {
  inherits(WebpackClientConfig, _WebpackBaseConfig);

  function WebpackClientConfig(builder) {
    classCallCheck(this, WebpackClientConfig);
    return possibleConstructorReturn(this, (WebpackClientConfig.__proto__ || Object.getPrototypeOf(WebpackClientConfig)).call(this, builder, { name: 'client', isServer: false }));
  }

  createClass(WebpackClientConfig, [{
    key: 'env',
    value: function env$$1() {
      return Object.assign(get(WebpackClientConfig.prototype.__proto__ || Object.getPrototypeOf(WebpackClientConfig.prototype), 'env', this).call(this), {
        'process.env.VUE_ENV': JSON.stringify('client'),
        'process.browser': true,
        'process.client': true,
        'process.server': false
      });
    }
  }, {
    key: 'plugins',
    value: function plugins() {
      var plugins = get(WebpackClientConfig.prototype.__proto__ || Object.getPrototypeOf(WebpackClientConfig.prototype), 'plugins', this).call(this);

      // Generate output HTML for SSR
      if (this.options.build.ssr) {
        plugins.push(new HTMLPlugin({
          filename: 'index.ssr.html',
          template: this.options.appTemplatePath,
          minify: true,
          inject: false // Resources will be injected using bundleRenderer
        }));
      }

      plugins.push(new HTMLPlugin({
        filename: 'index.spa.html',
        template: this.options.appTemplatePath,
        minify: true,
        inject: true,
        chunksSortMode: 'dependency'
      }), new VueSSRClientPlugin({
        filename: 'vue-ssr-client-manifest.json'
      }), new webpack.DefinePlugin(this.env()));

      if (this.options.dev) {
        // TODO: webpackHotUpdate is not defined: https://github.com/webpack/webpack/issues/6693
        plugins.push(new webpack.HotModuleReplacementPlugin());
      }

      // Chunks size limit
      // https://webpack.js.org/plugins/aggressive-splitting-plugin/
      if (!this.options.dev && this.options.build.maxChunkSize) {
        plugins.push(new webpack.optimize.AggressiveSplittingPlugin({
          minSize: this.options.build.maxChunkSize,
          maxSize: this.options.build.maxChunkSize
        }));
      }

      // Webpack Bundle Analyzer
      // https://github.com/webpack-contrib/webpack-bundle-analyzer
      if (!this.options.dev && this.options.build.analyze) {
        var statsDir = path.resolve(this.options.buildDir, 'stats');

        plugins.push(new BundleAnalyzer.BundleAnalyzerPlugin(Object.assign({
          analyzerMode: 'static',
          defaultSizes: 'gzip',
          generateStatsFile: true,
          openAnalyzer: !(this.options.ci || this.options.test),
          reportFilename: path.resolve(statsDir, 'client.html'),
          statsFilename: path.resolve(statsDir, 'client.json')
        }, this.options.build.analyze)));
      }

      return plugins;
    }
  }, {
    key: 'config',
    value: function config() {
      var config = get(WebpackClientConfig.prototype.__proto__ || Object.getPrototypeOf(WebpackClientConfig.prototype), 'config', this).call(this);

      // Entry points
      config.entry = path.resolve(this.options.buildDir, 'client.js');

      // -- Optimization --
      config.optimization = this.options.build.optimization;

      // Small, known and common modules which are usually used project-wise
      // Sum of them may not be more than 244 KiB
      if (this.options.build.splitChunks.commons === true && config.optimization.splitChunks.cacheGroups.commons === undefined) {
        config.optimization.splitChunks.cacheGroups.commons = {
          test: /node_modules[\\/](vue|vue-loader|vue-router|vuex|vue-meta|core-js|babel-runtime|es6-promise|axios|webpack|setimmediate|timers-browserify|process|regenerator-runtime|cookie|js-cookie|is-buffer|dotprop|nuxt\.js)[\\/]/,
          chunks: 'all',
          priority: 10,
          name: 'commons'
        };
      }

      // Make uglifyjs faster
      if (!this.options.dev && !config.optimization.minimizer) {
        // https://github.com/webpack-contrib/uglifyjs-webpack-plugin
        config.optimization.minimizer = [new UglifyJsWebpackPlugin({
          parallel: true,
          cache: this.options.build.cache,
          sourceMap: false,
          extractComments: {
            filename: 'LICENSES'
          },
          uglifyOptions: {
            output: {
              comments: /^\**!|@preserve|@license|@cc_on/
            }
          }
        })];
      }

      // Add HMR support
      if (this.options.dev) {
        config.entry = [
        // https://github.com/glenjamin/webpack-hot-middleware#config
        ('webpack-hot-middleware/client?name=client&reload=true&timeout=30000&path=' + this.options.router.base + '/__webpack_hmr').replace(/\/\//g, '/'), config.entry];
      }

      // Add friendly error plugin
      if (this.options.dev) {
        config.plugins.push(new FriendlyErrorsWebpackPlugin({
          clearConsole: true,
          logLevel: 'WARNING'
        }));
      }

      // Extend config
      if (typeof this.options.build.extend === 'function') {
        var isDev = this.options.dev;
        var extendedConfig = this.options.build.extend.call(this.builder, config, {
          isDev: isDev,
          isClient: true
        });

        // Only overwrite config when something is returned for backwards compatibility
        if (extendedConfig !== undefined) {
          config = extendedConfig;
        }
      }

      return config;
    }
  }]);
  return WebpackClientConfig;
}(WebpackBaseConfig);

var VueSSRServerPlugin = function () {
  function VueSSRServerPlugin() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, VueSSRServerPlugin);

    this.options = Object.assign({
      filename: 'vue-ssr-server-bundle.json'
    }, options);
  }

  createClass(VueSSRServerPlugin, [{
    key: 'apply',
    value: function apply(compiler) {
      var _this = this;

      validate(compiler);

      onEmit(compiler, 'vue-server-plugin', function (compilation, cb) {
        var stats = compilation.getStats().toJson();
        var entryName = Object.keys(stats.entrypoints)[0];
        var entryInfo = stats.entrypoints[entryName];

        if (!entryInfo) {
          // #5553
          return cb();
        }

        var entryAssets = entryInfo.assets.filter(isJS);

        if (entryAssets.length > 1) {
          throw new Error('Server-side bundle should have one single entry file. ' + 'Avoid using CommonsChunkPlugin in the server config.');
        }

        var entry = entryAssets[0];
        if (!entry || typeof entry !== 'string') {
          throw new Error('Entry "' + entryName + '" not found. Did you specify the correct entry option?');
        }

        var bundle = {
          entry: entry,
          files: {},
          maps: {}
        };

        stats.assets.forEach(function (asset) {
          if (asset.name.match(/\.js$/)) {
            bundle.files[asset.name] = compilation.assets[asset.name].source();
          } else if (asset.name.match(/\.js\.map$/)) {
            bundle.maps[asset.name.replace(/\.map$/, '')] = JSON.parse(compilation.assets[asset.name].source());
          }
          // do not emit anything else for server
          delete compilation.assets[asset.name];
        });

        var json = JSON.stringify(bundle, null, 2);
        var filename = _this.options.filename;

        compilation.assets[filename] = {
          source: function source() {
            return json;
          },
          size: function size() {
            return json.length;
          }
        };

        cb();
      });
    }
  }]);
  return VueSSRServerPlugin;
}();

var WebpackServerConfig = function (_BaseConfig) {
  inherits(WebpackServerConfig, _BaseConfig);

  function WebpackServerConfig(builder) {
    classCallCheck(this, WebpackServerConfig);
    return possibleConstructorReturn(this, (WebpackServerConfig.__proto__ || Object.getPrototypeOf(WebpackServerConfig)).call(this, builder, { name: 'server', isServer: true }));
  }

  createClass(WebpackServerConfig, [{
    key: 'env',
    value: function env$$1() {
      return Object.assign(get(WebpackServerConfig.prototype.__proto__ || Object.getPrototypeOf(WebpackServerConfig.prototype), 'env', this).call(this), {
        'process.env.VUE_ENV': JSON.stringify('server'),
        'process.browser': false,
        'process.client': false,
        'process.server': true
      });
    }
  }, {
    key: 'plugins',
    value: function plugins() {
      var plugins = get(WebpackServerConfig.prototype.__proto__ || Object.getPrototypeOf(WebpackServerConfig.prototype), 'plugins', this).call(this);
      plugins.push(new VueSSRServerPlugin({
        filename: 'server-bundle.json'
      }), new webpack.DefinePlugin(this.env()));
      return plugins;
    }
  }, {
    key: 'config',
    value: function config() {
      var config = get(WebpackServerConfig.prototype.__proto__ || Object.getPrototypeOf(WebpackServerConfig.prototype), 'config', this).call(this);

      // Config devtool
      config.devtool = 'cheap-source-map';

      Object.assign(config, {
        target: 'node',
        node: false,
        entry: path.resolve(this.options.buildDir, 'server.js'),
        output: Object.assign({}, config.output, {
          filename: 'server-bundle.js',
          libraryTarget: 'commonjs2'
        }),
        performance: {
          hints: false,
          maxAssetSize: Infinity
        },
        externals: [],
        optimization: {
          splitChunks: false,
          minimizer: []
        }
      });

      // https://webpack.js.org/configuration/externals/#externals
      // https://github.com/liady/webpack-node-externals
      // https://vue-loader.vuejs.org/migrating.html#ssr-externals
      this.options.modulesDir.forEach(function (dir) {
        if (fs.existsSync(dir)) {
          config.externals.push(nodeExternals({
            whitelist: [/es6-promise|\.(?!(?:js|json)$).{1,5}$/i, /\.css$/, /\?vue&type=style/],
            modulesDir: dir
          }));
        }
      });

      // Extend config
      if (typeof this.options.build.extend === 'function') {
        var isDev = this.options.dev;
        var extendedConfig = this.options.build.extend.call(this.builder, config, {
          isDev: isDev,
          isServer: true
        });
        // Only overwrite config when something is returned for backwards compatibility
        if (extendedConfig !== undefined) {
          config = extendedConfig;
        }
      }

      return config;
    }
  }]);
  return WebpackServerConfig;
}(WebpackBaseConfig);

var glob = pify(Glob);

var Builder = function () {
  function Builder(nuxt) {
    var _this = this;

    classCallCheck(this, Builder);

    this.nuxt = nuxt;
    this.isStatic = false; // Flag to know if the build is for a generated app
    this.options = nuxt.options;

    // Fields that set on build
    this.compilers = [];
    this.compilersWatching = [];
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;
    this.filesWatcher = null;
    this.customFilesWatcher = null;
    this.perfLoader = null;

    // Helper to resolve build paths
    this.relativeToBuild = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return relativeTo.apply(undefined, [_this.options.buildDir].concat(args));
    };

    this._buildStatus = STATUS.INITIAL;

    // Stop watching on nuxt.close()
    if (this.options.dev) {
      this.nuxt.hook('close', function () {
        return _this.unwatch();
      });
    }

    // Initialize shared FS and Cache
    if (this.options.dev) {
      this.mfs = new MFS();
    }

    // if(!this.options.dev) {
    // TODO: enable again when unsafe concern resolved.(common/options.js:42)
    // this.nuxt.hook('build:done', () => this.generateConfig())
    // }
  }

  createClass(Builder, [{
    key: 'forGenerate',
    value: function forGenerate() {
      this.isStatic = true;
    }
  }, {
    key: 'build',
    value: function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var dir;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this._buildStatus === STATUS.BUILD_DONE && this.options.dev)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt('return', this);

              case 2:
                if (!(this._buildStatus === STATUS.BUILDING)) {
                  _context.next = 6;
                  break;
                }

                _context.next = 5;
                return waitFor(1000);

              case 5:
                return _context.abrupt('return', this.build());

              case 6:
                this._buildStatus = STATUS.BUILDING;

                consola.info({
                  message: 'Building project',
                  badge: true,
                  clear: true
                });

                // Wait for nuxt ready
                _context.next = 10;
                return this.nuxt.ready();

              case 10:
                _context.next = 12;
                return this.nuxt.callHook('build:before', this, this.options.build);

              case 12:

                // Check if pages dir exists and warn if not
                this._nuxtPages = typeof this.options.build.createRoutes !== 'function';

                if (!this._nuxtPages) {
                  _context.next = 21;
                  break;
                }

                if (fsExtra.existsSync(path.join(this.options.srcDir, this.options.dir.pages))) {
                  _context.next = 21;
                  break;
                }

                dir = this.options.srcDir;

                if (!fsExtra.existsSync(path.join(this.options.srcDir, '..', this.options.dir.pages))) {
                  _context.next = 20;
                  break;
                }

                throw new Error('No `' + this.options.dir.pages + '` directory found in ' + dir + '. Did you mean to run `nuxt` in the parent (`../`) directory?');

              case 20:
                this._defaultPage = true;

              case 21:

                consola.success('Builder initialized');

                consola.debug('App root: ' + this.options.srcDir);

                // Create .nuxt/, .nuxt/components and .nuxt/dist folders
                _context.next = 25;
                return fsExtra.remove(r(this.options.buildDir));

              case 25:
                _context.next = 27;
                return fsExtra.mkdirp(r(this.options.buildDir, 'components'));

              case 27:
                if (this.options.dev) {
                  _context.next = 30;
                  break;
                }

                _context.next = 30;
                return fsExtra.mkdirp(r(this.options.buildDir, 'dist'));

              case 30:
                _context.next = 32;
                return this.generateRoutesAndFiles();

              case 32:
                _context.next = 34;
                return this.webpackBuild();

              case 34:

                // Flag to set that building is done
                this._buildStatus = STATUS.BUILD_DONE;

                // Call done hook
                _context.next = 37;
                return this.nuxt.callHook('build:done', this);

              case 37:
                return _context.abrupt('return', this);

              case 38:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function build() {
        return _ref.apply(this, arguments);
      }

      return build;
    }()
  }, {
    key: 'generateRoutesAndFiles',
    value: function () {
      var _ref2 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;

        var templatesFiles, templateVars, layoutsFiles, hasErrorLayout, files, extendedRoutes, customTemplateFiles, indicatorPath1, indicatorPath2, indicatorPath;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                consola.debug('Generating nuxt files');

                // -- Templates --
                templatesFiles = ['App.js', 'client.js', 'index.js', 'middleware.js', 'router.js', 'server.js', 'utils.js', 'empty.js', 'components/nuxt-error.vue', 'components/nuxt-loading.vue', 'components/nuxt-child.js', 'components/nuxt-link.js', 'components/nuxt.js', 'components/no-ssr.js', 'views/app.template.html', 'views/error.html'];
                templateVars = {
                  options: this.options,
                  extensions: this.options.extensions.map(function (ext) {
                    return ext.replace(/^\./, '');
                  }).join('|'),
                  messages: this.options.messages,
                  splitChunks: this.options.build.splitChunks,
                  uniqBy: ___default.uniqBy,
                  isDev: this.options.dev,
                  debug: this.options.debug,
                  mode: this.options.mode,
                  router: this.options.router,
                  env: this.options.env,
                  head: this.options.head,
                  middleware: fsExtra.existsSync(path.join(this.options.srcDir, this.options.dir.middleware)),
                  store: this.options.store,
                  css: this.options.css,
                  plugins: this.plugins,
                  appPath: './App.js',
                  ignorePrefix: this.options.ignorePrefix,
                  layouts: Object.assign({}, this.options.layouts),
                  loading: typeof this.options.loading === 'string' ? this.relativeToBuild(this.options.srcDir, this.options.loading) : this.options.loading,
                  transition: this.options.transition,
                  layoutTransition: this.options.layoutTransition,
                  dir: this.options.dir,
                  components: {
                    ErrorPage: this.options.ErrorPage ? this.relativeToBuild(this.options.ErrorPage) : null
                  }

                  // -- Layouts --
                };

                if (!fsExtra.existsSync(path.resolve(this.options.srcDir, this.options.dir.layouts))) {
                  _context3.next = 10;
                  break;
                }

                _context3.next = 6;
                return glob(this.options.dir.layouts + '/**/*.{vue,js}', {
                  cwd: this.options.srcDir,
                  ignore: this.options.ignore
                });

              case 6:
                layoutsFiles = _context3.sent;
                hasErrorLayout = false;

                layoutsFiles.forEach(function (file) {
                  var name = file.split('/').slice(1).join('/').replace(/\.(vue|js)$/, '');
                  if (name === 'error') {
                    hasErrorLayout = true;
                    return;
                  }
                  if (!templateVars.layouts[name] || /\.vue$/.test(file)) {
                    templateVars.layouts[name] = _this2.relativeToBuild(_this2.options.srcDir, file);
                  }
                });
                if (!templateVars.components.ErrorPage && hasErrorLayout) {
                  templateVars.components.ErrorPage = this.relativeToBuild(this.options.srcDir, this.options.dir.layouts + '/error.vue');
                }

              case 10:
                if (templateVars.layouts.default) {
                  _context3.next = 15;
                  break;
                }

                _context3.next = 13;
                return fsExtra.mkdirp(r(this.options.buildDir, 'layouts'));

              case 13:
                templatesFiles.push('layouts/default.vue');
                templateVars.layouts.default = './layouts/default.vue';

              case 15:

                // -- Routes --
                consola.debug('Generating routes...');

                if (!this._defaultPage) {
                  _context3.next = 20;
                  break;
                }

                templateVars.router.routes = createRoutes(['index.vue'], this.options.nuxtAppDir + '/pages');
                _context3.next = 30;
                break;

              case 20:
                if (!this._nuxtPages) {
                  _context3.next = 29;
                  break;
                }

                // If user defined a custom method to create routes
                // Use nuxt.js createRoutes bases on pages/
                files = {};
                _context3.next = 24;
                return glob(this.options.dir.pages + '/**/*.{vue,js}', {
                  cwd: this.options.srcDir,
                  ignore: this.options.ignore
                });

              case 24:
                _context3.t0 = function (f) {
                  var key = f.replace(/\.(js|vue)$/, '');
                  if (/\.vue$/.test(f) || !files[key]) {
                    files[key] = f.replace(/(['|"])/g, '\\$1');
                  }
                };

                _context3.sent.forEach(_context3.t0);

                templateVars.router.routes = createRoutes(Object.values(files), this.options.srcDir, this.options.dir.pages);
                _context3.next = 30;
                break;

              case 29:
                templateVars.router.routes = this.options.build.createRoutes(this.options.srcDir);

              case 30:
                _context3.next = 32;
                return this.nuxt.callHook('build:extendRoutes', templateVars.router.routes, r);

              case 32:

                // router.extendRoutes method
                if (typeof this.options.router.extendRoutes === 'function') {
                  // let the user extend the routes
                  extendedRoutes = this.options.router.extendRoutes(templateVars.router.routes, r);
                  // Only overwrite routes when something is returned for backwards compatibility

                  if (extendedRoutes !== undefined) {
                    templateVars.router.routes = extendedRoutes;
                  }
                }

                // Make routes accessible for other modules and webpack configs
                this.routes = templateVars.router.routes;

                // -- Store --
                // Add store if needed
                if (this.options.store) {
                  templatesFiles.push('store.js');
                }

                // Resolve template files
                customTemplateFiles = this.options.build.templates.map(function (t) {
                  return t.dst || path.basename(t.src || t);
                });


                templatesFiles = templatesFiles.map(function (file) {
                  // Skip if custom file was already provided in build.templates[]
                  if (customTemplateFiles.indexOf(file) !== -1) {
                    return;
                  }
                  // Allow override templates using a file with same name in ${srcDir}/app
                  var customPath = r(_this2.options.srcDir, 'app', file);
                  var customFileExists = fsExtra.existsSync(customPath);

                  return {
                    src: customFileExists ? customPath : r(_this2.options.nuxtAppDir, file),
                    dst: file,
                    custom: customFileExists
                  };
                }).filter(function (i) {
                  return !!i;
                });

                // -- Custom templates --
                // Add custom template files
                templatesFiles = templatesFiles.concat(this.options.build.templates.map(function (t) {
                  return Object.assign({
                    src: r(_this2.options.srcDir, t.src || t),
                    dst: t.dst || path.basename(t.src || t),
                    custom: true
                  }, t);
                }));

                // -- Loading indicator --
                if (this.options.loadingIndicator.name) {
                  indicatorPath1 = path.resolve(this.options.nuxtAppDir, 'views/loading', this.options.loadingIndicator.name + '.html');
                  indicatorPath2 = this.nuxt.resolveAlias(this.options.loadingIndicator.name);
                  indicatorPath = fsExtra.existsSync(indicatorPath1) ? indicatorPath1 : fsExtra.existsSync(indicatorPath2) ? indicatorPath2 : null;

                  if (indicatorPath) {
                    templatesFiles.push({
                      src: indicatorPath,
                      dst: 'loading.html',
                      options: this.options.loadingIndicator
                    });
                  } else {
                    /* istanbul ignore next */
                    // eslint-disable-next-line no-console
                    console.error('Could not fetch loading indicator: ' + this.options.loadingIndicator.name);
                  }
                }

                _context3.next = 41;
                return this.nuxt.callHook('build:templates', {
                  templatesFiles: templatesFiles,
                  templateVars: templateVars,
                  resolve: r
                });

              case 41:
                _context3.next = 43;
                return Promise.all(templatesFiles.map(function () {
                  var _ref4 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref3) {
                    var src = _ref3.src,
                        dst = _ref3.dst,
                        options = _ref3.options,
                        custom = _ref3.custom;

                    var fileContent, content, template, _path;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            // Add template to watchers
                            _this2.options.build.watch.push(src);
                            // Render template to dst
                            _context2.next = 3;
                            return fsExtra.readFile(src, 'utf8');

                          case 3:
                            fileContent = _context2.sent;
                            content = void 0;
                            _context2.prev = 5;
                            template = ___default.template(fileContent, {
                              imports: {
                                serialize: serialize,
                                hash: hash,
                                r: r,
                                wp: wp,
                                wChunk: wChunk,
                                resolvePath: _this2.nuxt.resolvePath.bind(_this2.nuxt),
                                resolveAlias: _this2.nuxt.resolveAlias.bind(_this2.nuxt),
                                relativeToBuild: _this2.relativeToBuild
                              }
                            });

                            content = template(Object.assign({}, templateVars, {
                              options: options || {},
                              custom: custom,
                              src: src,
                              dst: dst
                            }));
                            _context2.next = 13;
                            break;

                          case 10:
                            _context2.prev = 10;
                            _context2.t0 = _context2['catch'](5);
                            throw new Error('Could not compile template ' + src + ': ' + _context2.t0.message);

                          case 13:
                            _path = r(_this2.options.buildDir, dst);
                            // Ensure parent dir exits

                            _context2.next = 16;
                            return fsExtra.mkdirp(path.dirname(_path));

                          case 16:
                            _context2.next = 18;
                            return fsExtra.writeFile(_path, content, 'utf8');

                          case 18:
                          case 'end':
                            return _context2.stop();
                        }
                      }
                    }, _callee2, _this2, [[5, 10]]);
                  }));

                  return function (_x) {
                    return _ref4.apply(this, arguments);
                  };
                }()));

              case 43:

                consola.success('Nuxt files generated');

              case 44:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function generateRoutesAndFiles() {
        return _ref2.apply(this, arguments);
      }

      return generateRoutesAndFiles;
    }()
  }, {
    key: 'webpackBuild',
    value: function () {
      var _ref5 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _this3 = this;

        var compilersOptions, clientConfig, serverConfig, runner;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.perfLoader = new PerfLoader(this.options);

                compilersOptions = [];

                // Client

                clientConfig = new WebpackClientConfig(this).config();

                compilersOptions.push(clientConfig);

                // Server
                serverConfig = null;

                if (this.options.build.ssr) {
                  serverConfig = new WebpackServerConfig(this).config();
                  compilersOptions.push(serverConfig);
                }

                // Alias plugins to their real path
                this.plugins.forEach(function (p) {
                  var src = _this3.relativeToBuild(p.src);

                  // Client config
                  if (!clientConfig.resolve.alias[p.name]) {
                    clientConfig.resolve.alias[p.name] = src;
                  }

                  // Server config
                  if (serverConfig && !serverConfig.resolve.alias[p.name]) {
                    // Alias to noop for ssr:false plugins
                    serverConfig.resolve.alias[p.name] = p.ssr ? src : './empty.js';
                  }
                });

                // Configure compilers
                this.compilers = compilersOptions.map(function (compilersOption) {
                  var compiler = webpack(compilersOption);

                  // In dev, write files in memory FS
                  if (_this3.options.dev) {
                    compiler.outputFileSystem = _this3.mfs;
                  }

                  return compiler;
                });

                // Warmup perfLoader before build
                if (this.options.build.parallel) {
                  consola.info('Warming up worker pools');
                  this.perfLoader.warmupAll();
                  consola.success('Worker pools ready');
                }

                // Start Builds
                runner = this.options.dev ? parallel : sequence;
                _context4.next = 12;
                return runner(this.compilers, function (compiler) {
                  return _this3.webpackCompile(compiler);
                });

              case 12:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function webpackBuild() {
        return _ref5.apply(this, arguments);
      }

      return webpackBuild;
    }()
  }, {
    key: 'webpackCompile',
    value: function webpackCompile(compiler) {
      var _this4 = this;

      return new Promise(function () {
        var _ref6 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(resolve, reject) {
          var name;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  name = compiler.options.name;
                  _context6.next = 3;
                  return _this4.nuxt.callHook('build:compile', { name: name, compiler: compiler });

                case 3:

                  // Load renderer resources after build
                  compiler.hooks.done.tap('load-resources', function () {
                    var _ref7 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(stats) {
                      return regeneratorRuntime.wrap(function _callee5$(_context5) {
                        while (1) {
                          switch (_context5.prev = _context5.next) {
                            case 0:
                              _context5.next = 2;
                              return _this4.nuxt.callHook('build:compiled', {
                                name: name,
                                compiler: compiler,
                                stats: stats
                              });

                            case 2:

                              // Reload renderer if available
                              _this4.nuxt.renderer.loadResources(_this4.mfs || fs);

                              // Resolve on next tick
                              process.nextTick(resolve);

                            case 4:
                            case 'end':
                              return _context5.stop();
                          }
                        }
                      }, _callee5, _this4);
                    }));

                    return function (_x4) {
                      return _ref7.apply(this, arguments);
                    };
                  }());

                  if (!_this4.options.dev) {
                    _context6.next = 10;
                    break;
                  }

                  if (!(compiler.options.name === 'client')) {
                    _context6.next = 7;
                    break;
                  }

                  return _context6.abrupt('return', _this4.webpackDev(compiler));

                case 7:
                  // Server, build and watch for changes
                  _this4.compilersWatching.push(compiler.watch(_this4.options.watchers.webpack, function (err) {
                    /* istanbul ignore if */
                    if (err) return reject(err);
                  }));
                  _context6.next = 11;
                  break;

                case 10:
                  // --- Production Build ---
                  compiler.run(function (err, stats) {
                    /* istanbul ignore next */
                    if (err) {
                      return reject(err);
                    } else if (stats.hasErrors()) {
                      if (_this4.options.test) {
                        err = stats.toString(_this4.options.build.stats);
                      }

                      return reject(err);
                    }

                    resolve();
                  });

                case 11:
                case 'end':
                  return _context6.stop();
              }
            }
          }, _callee6, _this4);
        }));

        return function (_x2, _x3) {
          return _ref6.apply(this, arguments);
        };
      }());
    }
  }, {
    key: 'webpackDev',
    value: function webpackDev(compiler) {
      consola.debug('Adding webpack middleware...');

      // Create webpack dev middleware
      this.webpackDevMiddleware = pify(webpackDevMiddleware(compiler, Object.assign({
        publicPath: this.options.build.publicPath,
        stats: false,
        logLevel: 'silent',
        watchOptions: this.options.watchers.webpack
      }, this.options.build.devMiddleware)));

      this.webpackDevMiddleware.close = pify(this.webpackDevMiddleware.close);

      this.webpackHotMiddleware = pify(webpackHotMiddleware(compiler, Object.assign({
        log: false,
        heartbeat: 10000
      }, this.options.build.hotMiddleware)));

      // Inject to renderer instance
      if (this.nuxt.renderer) {
        this.nuxt.renderer.webpackDevMiddleware = this.webpackDevMiddleware;
        this.nuxt.renderer.webpackHotMiddleware = this.webpackHotMiddleware;
      }

      // Start watching files
      this.watchFiles();
    }
  }, {
    key: 'watchFiles',
    value: function watchFiles() {
      var _this5 = this;

      var src = this.options.srcDir;
      var patterns = [r(src, this.options.dir.layouts), r(src, this.options.dir.store), r(src, this.options.dir.middleware), r(src, this.options.dir.layouts + '/*.{vue,js}'), r(src, this.options.dir.layouts + '/**/*.{vue,js}')];
      if (this._nuxtPages) {
        patterns.push(r(src, this.options.dir.pages), r(src, this.options.dir.pages + '/*.{vue,js}'), r(src, this.options.dir.pages + '/**/*.{vue,js}'));
      }
      patterns = ___default.map(patterns, function (p) {
        return upath.normalizeSafe(p);
      });

      var options = Object.assign({}, this.options.watchers.chokidar, {
        ignoreInitial: true
      });
      /* istanbul ignore next */
      var refreshFiles = ___default.debounce(function () {
        return _this5.generateRoutesAndFiles();
      }, 200);

      // Watch for src Files
      this.filesWatcher = chokidar.watch(patterns, options).on('add', refreshFiles).on('unlink', refreshFiles);

      // Watch for custom provided files
      var customPatterns = ___default.concat.apply(___default, [this.options.build.watch].concat(toConsumableArray(___default.values(___default.omit(this.options.build.styleResources, ['options'])))));
      customPatterns = ___default.map(___default.uniq(customPatterns), function (p) {
        return upath.normalizeSafe(p);
      });
      this.customFilesWatcher = chokidar.watch(customPatterns, options).on('change', refreshFiles);
    }
  }, {
    key: 'unwatch',
    value: function () {
      var _ref8 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.filesWatcher) {
                  this.filesWatcher.close();
                }

                if (this.customFilesWatcher) {
                  this.customFilesWatcher.close();
                }

                this.compilersWatching.forEach(function (watching) {
                  return watching.close();
                });

                // Stop webpack middleware

                if (!this.webpackDevMiddleware) {
                  _context7.next = 6;
                  break;
                }

                _context7.next = 6;
                return this.webpackDevMiddleware.close();

              case 6:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function unwatch() {
        return _ref8.apply(this, arguments);
      }

      return unwatch;
    }()

    // TODO: remove ignore when generateConfig enabled again

  }, {
    key: 'generateConfig',
    value: function () {
      var _ref9 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var config, options;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                config = path.resolve(this.options.buildDir, 'build.config.js');
                options = ___default.omit(this.options, Options.unsafeKeys);
                _context8.next = 4;
                return fsExtra.writeFile(config, 'export default ' + JSON.stringify(options, null, '  '), 'utf8');

              case 4:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function generateConfig() {
        return _ref9.apply(this, arguments);
      }

      return generateConfig;
    }()
  }, {
    key: 'plugins',
    get: function get$$1() {
      var _this6 = this;

      return ___default.uniqBy(this.options.plugins.map(function (p, i) {
        if (typeof p === 'string') p = { src: p };
        var pluginBaseName = path.basename(p.src, path.extname(p.src)).replace(/[^a-zA-Z?\d\s:]/g, '');
        return {
          src: _this6.nuxt.resolveAlias(p.src),
          ssr: p.ssr !== false,
          name: 'nuxt_plugin_' + pluginBaseName + '_' + hash(p.src)
        };
      }), function (p) {
        return p.name;
      });
    }
  }]);
  return Builder;
}();


var STATUS = {
  INITIAL: 1,
  BUILD_DONE: 2,
  BUILDING: 3
};

var Generator = function () {
  function Generator(nuxt, builder) {
    classCallCheck(this, Generator);

    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.builder = builder;

    // Set variables
    this.staticRoutes = path.resolve(this.options.srcDir, this.options.dir.static);
    this.srcBuiltPath = path.resolve(this.options.buildDir, 'dist');
    this.distPath = path.resolve(this.options.rootDir, this.options.generate.dir);
    this.distNuxtPath = path.join(this.distPath, isUrl(this.options.build.publicPath) ? '' : this.options.build.publicPath);
  }

  createClass(Generator, [{
    key: 'generate',
    value: function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$build = _ref2.build,
            build = _ref2$build === undefined ? true : _ref2$build,
            _ref2$init = _ref2.init,
            init = _ref2$init === undefined ? true : _ref2$init;

        var routes, errors;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                consola.debug('Initializing generator...');

                _context.next = 3;
                return this.initiate({ build: build, init: init });

              case 3:

                consola.debug('Preparing routes for generate...');

                _context.next = 6;
                return this.initRoutes();

              case 6:
                routes = _context.sent;


                consola.info({
                  message: 'Generating pages',
                  badge: true,
                  clear: true
                });

                _context.next = 10;
                return this.generateRoutes(routes);

              case 10:
                errors = _context.sent;
                _context.next = 13;
                return this.afterGenerate();

              case 13:
                _context.next = 15;
                return this.nuxt.callHook('generate:done', this, errors);

              case 15:
                return _context.abrupt('return', { errors: errors });

              case 16:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function generate() {
        return _ref.apply(this, arguments);
      }

      return generate;
    }()
  }, {
    key: 'initiate',
    value: function () {
      var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref4$build = _ref4.build,
            build = _ref4$build === undefined ? true : _ref4$build,
            _ref4$init = _ref4.init,
            init = _ref4$init === undefined ? true : _ref4$init;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.nuxt.ready();

              case 2:
                _context2.next = 4;
                return this.nuxt.callHook('generate:before', this, this.options.generate);

              case 4:
                if (!build) {
                  _context2.next = 8;
                  break;
                }

                // Add flag to set process.static
                this.builder.forGenerate();

                // Start build process
                _context2.next = 8;
                return this.builder.build();

              case 8:
                if (!init) {
                  _context2.next = 11;
                  break;
                }

                _context2.next = 11;
                return this.initDist();

              case 11:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function initiate() {
        return _ref3.apply(this, arguments);
      }

      return initiate;
    }()
  }, {
    key: 'initRoutes',
    value: function () {
      var _ref5 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var generateRoutes,
            _len,
            args,
            _key,
            routes,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // Resolve config.generate.routes promises before generating the routes
                generateRoutes = [];

                if (!(this.options.router.mode !== 'hash')) {
                  _context3.next = 13;
                  break;
                }

                _context3.prev = 2;

                for (_len = _args3.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = _args3[_key];
                }

                _context3.next = 6;
                return promisifyRoute.apply(undefined, [this.options.generate.routes || []].concat(toConsumableArray(args)));

              case 6:
                generateRoutes = _context3.sent;
                _context3.next = 13;
                break;

              case 9:
                _context3.prev = 9;
                _context3.t0 = _context3['catch'](2);

                consola.error('Could not resolve routes');
                throw _context3.t0;

              case 13:
                // Generate only index.html for router.mode = 'hash'
                routes = this.options.router.mode === 'hash' ? ['/'] : flatRoutes(this.options.router.routes);

                routes = this.decorateWithPayloads(routes, generateRoutes);

                // extendRoutes hook
                _context3.next = 17;
                return this.nuxt.callHook('generate:extendRoutes', routes);

              case 17:
                return _context3.abrupt('return', routes);

              case 18:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 9]]);
      }));

      function initRoutes() {
        return _ref5.apply(this, arguments);
      }

      return initRoutes;
    }()
  }, {
    key: 'generateRoutes',
    value: function () {
      var _ref6 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(routes) {
        var _this = this;

        var errors, _loop;

        return regeneratorRuntime.wrap(function _callee5$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                errors = [];

                // Start generate process

                _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                  var n;
                  return regeneratorRuntime.wrap(function _loop$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          n = 0;
                          _context5.next = 3;
                          return Promise.all(routes.splice(0, _this.options.generate.concurrency).map(function () {
                            var _ref8 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref7) {
                              var route = _ref7.route,
                                  payload = _ref7.payload;
                              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                                while (1) {
                                  switch (_context4.prev = _context4.next) {
                                    case 0:
                                      _context4.next = 2;
                                      return waitFor(n++ * _this.options.generate.interval);

                                    case 2:
                                      _context4.next = 4;
                                      return _this.generateRoute({ route: route, payload: payload, errors: errors });

                                    case 4:
                                    case 'end':
                                      return _context4.stop();
                                  }
                                }
                              }, _callee4, _this);
                            }));

                            return function (_x4) {
                              return _ref8.apply(this, arguments);
                            };
                          }()));

                        case 3:
                        case 'end':
                          return _context5.stop();
                      }
                    }
                  }, _loop, _this);
                });

              case 2:
                if (!routes.length) {
                  _context6.next = 6;
                  break;
                }

                return _context6.delegateYield(_loop(), 't0', 4);

              case 4:
                _context6.next = 2;
                break;

              case 6:

                // Improve string representation for errors
                errors.toString = function () {
                  return _this._formatErrors(errors);
                };

                return _context6.abrupt('return', errors);

              case 8:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee5, this);
      }));

      function generateRoutes(_x3) {
        return _ref6.apply(this, arguments);
      }

      return generateRoutes;
    }()
  }, {
    key: '_formatErrors',
    value: function _formatErrors(errors) {
      return errors.map(function (_ref9) {
        var type = _ref9.type,
            route = _ref9.route,
            error = _ref9.error;

        var isHandled = type === 'handled';
        var bgColor = isHandled ? 'bgYellow' : 'bgRed';
        var color = isHandled ? 'yellow' : 'red';

        var line = Chalk.black[bgColor](' GEN ERR ') + Chalk[color](' ' + route + '\n\n');

        if (isHandled) {
          line += Chalk.grey(JSON.stringify(error, undefined, 2) + '\n');
        } else {
          line += Chalk.grey(error.stack);
        }

        return line;
      }).join('\n');
    }
  }, {
    key: 'afterGenerate',
    value: function () {
      var _ref10 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var fallback, fallbackPath, _ref11, html;

        return regeneratorRuntime.wrap(function _callee6$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                fallback = this.options.generate.fallback;

                // Disable SPA fallback if value isn't true or a string

                if (!(fallback !== true && typeof fallback !== 'string')) {
                  _context7.next = 3;
                  break;
                }

                return _context7.abrupt('return');

              case 3:
                fallbackPath = path.join(this.distPath, fallback);

                // Prevent conflicts

                if (!fsExtra.existsSync(fallbackPath)) {
                  _context7.next = 7;
                  break;
                }

                consola.warn('SPA fallback was configured, but the configured path (' + fallbackPath + ') already exists.');
                return _context7.abrupt('return');

              case 7:
                _context7.next = 9;
                return this.nuxt.renderRoute('/', { spa: true });

              case 9:
                _ref11 = _context7.sent;
                html = _ref11.html;
                _context7.next = 13;
                return fsExtra.writeFile(fallbackPath, html, 'utf8');

              case 13:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee6, this);
      }));

      function afterGenerate() {
        return _ref10.apply(this, arguments);
      }

      return afterGenerate;
    }()
  }, {
    key: 'initDist',
    value: function () {
      var _ref12 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var _this2 = this;

        var nojekyllPath, extraFiles;
        return regeneratorRuntime.wrap(function _callee7$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return fsExtra.remove(this.distPath);

              case 2:
                _context8.next = 4;
                return this.nuxt.callHook('generate:distRemoved', this);

              case 4:
                if (!fsExtra.existsSync(this.staticRoutes)) {
                  _context8.next = 7;
                  break;
                }

                _context8.next = 7;
                return fsExtra.copy(this.staticRoutes, this.distPath);

              case 7:
                _context8.next = 9;
                return fsExtra.copy(this.srcBuiltPath, this.distNuxtPath);

              case 9:

                // Add .nojekyll file to let Github Pages add the _nuxt/ folder
                // https://help.github.com/articles/files-that-start-with-an-underscore-are-missing/
                nojekyllPath = path.resolve(this.distPath, '.nojekyll');

                fsExtra.writeFile(nojekyllPath, '');

                // Cleanup SSR related files
                extraFiles = ['index.spa.html', 'index.ssr.html', 'server-bundle.json', 'vue-ssr-client-manifest.json'].map(function (file) {
                  return path.resolve(_this2.distNuxtPath, file);
                });


                extraFiles.forEach(function (file) {
                  if (fsExtra.existsSync(file)) {
                    fsExtra.removeSync(file);
                  }
                });

                _context8.next = 15;
                return this.nuxt.callHook('generate:distCopied', this);

              case 15:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee7, this);
      }));

      function initDist() {
        return _ref12.apply(this, arguments);
      }

      return initDist;
    }()
  }, {
    key: 'decorateWithPayloads',
    value: function decorateWithPayloads(routes, generateRoutes) {
      var routeMap = {};
      // Fill routeMap for known routes
      routes.forEach(function (route) {
        routeMap[route] = {
          route: route,
          payload: null
        };
      });
      // Fill routeMap with given generate.routes
      generateRoutes.forEach(function (route) {
        // route is either a string or like { route : '/my_route/1', payload: {} }
        var path$$1 = ___default.isString(route) ? route : route.route;
        routeMap[path$$1] = {
          route: path$$1,
          payload: route.payload || null
        };
      });
      return ___default.values(routeMap);
    }
  }, {
    key: 'generateRoute',
    value: function () {
      var _ref14 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref13) {
        var route = _ref13.route,
            _ref13$payload = _ref13.payload,
            payload = _ref13$payload === undefined ? {} : _ref13$payload,
            _ref13$errors = _ref13.errors,
            errors = _ref13$errors === undefined ? [] : _ref13$errors;

        var html, pageErrors, res, minifyErr, _path, page;

        return regeneratorRuntime.wrap(function _callee8$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                html = void 0;
                pageErrors = [];
                _context9.prev = 2;
                _context9.next = 5;
                return this.nuxt.renderer.renderRoute(route, {
                  _generate: true,
                  payload: payload
                });

              case 5:
                res = _context9.sent;

                html = res.html;
                if (res.error) {
                  pageErrors.push({ type: 'handled', route: route, error: res.error });
                }
                _context9.next = 17;
                break;

              case 10:
                _context9.prev = 10;
                _context9.t0 = _context9['catch'](2);

                /* istanbul ignore next */
                pageErrors.push({ type: 'unhandled', route: route, error: _context9.t0 });
                Array.prototype.push.apply(errors, pageErrors);

                _context9.next = 16;
                return this.nuxt.callHook('generate:routeFailed', {
                  route: route,
                  errors: pageErrors
                });

              case 16:
                return _context9.abrupt('return', false);

              case 17:

                if (this.options.generate.minify) {
                  try {
                    html = htmlMinifier.minify(html, this.options.generate.minify);
                  } catch (err) /* istanbul ignore next */{
                    minifyErr = new Error('HTML minification failed. Make sure the route generates valid HTML. Failed HTML:\n ' + html);

                    pageErrors.push({ type: 'unhandled', route: route, error: minifyErr });
                  }
                }

                _path = void 0;


                if (this.options.generate.subFolders) {
                  _path = path.join(route, path.sep, 'index.html'); // /about -> /about/index.html
                  _path = _path === '/404/index.html' ? '/404.html' : _path; // /404 -> /404.html
                } else {
                  _path = route.length > 1 ? path.join(path.sep, route + '.html') : path.join(path.sep, 'index.html');
                }

                // Call hook to let user update the path & html
                page = { route: route, path: _path, html: html };
                _context9.next = 23;
                return this.nuxt.callHook('generate:page', page);

              case 23:

                page.path = path.join(this.distPath, page.path);

                // Make sure the sub folders are created
                _context9.next = 26;
                return fsExtra.mkdirp(path.dirname(page.path));

              case 26:
                _context9.next = 28;
                return fsExtra.writeFile(page.path, page.html, 'utf8');

              case 28:
                _context9.next = 30;
                return this.nuxt.callHook('generate:routeCreated', {
                  route: route,
                  path: page.path,
                  errors: pageErrors
                });

              case 30:

                if (pageErrors.length) {
                  consola.error('Error generating ' + route);
                  Array.prototype.push.apply(errors, pageErrors);
                } else {
                  consola.success('Generated ' + route);
                }

                return _context9.abrupt('return', true);

              case 32:
              case 'end':
                return _context9.stop();
            }
          }
        }, _callee8, this, [[2, 10]]);
      }));

      function generateRoute(_x5) {
        return _ref14.apply(this, arguments);
      }

      return generateRoute;
    }()
  }]);
  return Generator;
}();

var builder = {
  Builder: Builder,
  Generator: Generator
};

consola.warn('You are using legacy build of Nuxt. Please consider upgrading your Node.js version to 8.x or later.');

var nuxtLegacy = Object.assign({ Utils: Utils }, core, builder);

module.exports = nuxtLegacy;
//# sourceMappingURL=nuxt-legacy.js.map
