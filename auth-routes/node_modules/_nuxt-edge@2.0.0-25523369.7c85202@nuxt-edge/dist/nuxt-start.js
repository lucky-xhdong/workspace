'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var _ = _interopDefault(require('lodash'));
var fs = _interopDefault(require('fs'));
var hash = _interopDefault(require('hash-sum'));
var env = _interopDefault(require('std-env'));
var consola = _interopDefault(require('consola'));
var Vue = _interopDefault(require('vue'));
var VueMeta = _interopDefault(require('vue-meta'));
var vueServerRenderer = require('vue-server-renderer');
var LRU = _interopDefault(require('lru-cache'));
var Youch = _interopDefault(require('@nuxtjs/youch'));
var fs$1 = _interopDefault(require('fs-extra'));
var generateETag = _interopDefault(require('etag'));
var fresh = _interopDefault(require('fresh'));
var crypto = _interopDefault(require('crypto'));
var serialize = _interopDefault(require('serialize-javascript'));
var serveStatic = _interopDefault(require('serve-static'));
var compression = _interopDefault(require('compression'));
var connect = _interopDefault(require('connect'));
var launchMiddleware = _interopDefault(require('launch-editor-middleware'));
var Module = _interopDefault(require('module'));
var enableDestroy = _interopDefault(require('server-destroy'));
var chalk = _interopDefault(require('chalk'));
var esm = _interopDefault(require('esm'));

const encodeHtml = function encodeHtml(str) {
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;')
};

const getContext = function getContext(req, res) {
  return { req, res }
};

const waitFor = function waitFor(ms) {
  return new Promise(resolve => setTimeout(resolve, ms || 0))
};

async function promiseFinally(fn, finalFn) {
  let result;
  try {
    if (typeof fn === 'function') {
      result = await fn();
    } else {
      result = await fn;
    }
  } finally {
    finalFn();
  }
  return result
}

const timeout = function timeout(fn, ms, msg) {
  let timerId;
  const warpPromise = promiseFinally(fn, () => clearTimeout(timerId));
  const timerPromise = new Promise((resolve, reject) => {
    timerId = setTimeout(() => reject(new Error(msg)), ms);
  });
  return Promise.race([warpPromise, timerPromise])
};

const urlJoin = function urlJoin() {
  return [].slice
    .call(arguments)
    .join('/')
    .replace(/\/+/g, '/')
    .replace(':/', '://')
};

const isUrl = function isUrl(url) {
  return url.indexOf('http') === 0 || url.indexOf('//') === 0
};

const promisifyRoute = function promisifyRoute(fn, ...args) {
  // If routes is an array
  if (Array.isArray(fn)) {
    return Promise.resolve(fn)
  }
  // If routes is a function expecting a callback
  if (fn.length === arguments.length) {
    return new Promise((resolve, reject) => {
      fn((err, routeParams) => {
        if (err) {
          reject(err);
        }
        resolve(routeParams);
      }, ...args);
    })
  }
  let promise = fn(...args);
  if (
    !promise ||
    (!(promise instanceof Promise) && typeof promise.then !== 'function')
  ) {
    promise = Promise.resolve(promise);
  }
  return promise
};

const sequence = function sequence(tasks, fn) {
  return tasks.reduce(
    (promise, task) => promise.then(() => fn(task)),
    Promise.resolve()
  )
};

const parallel = function parallel(tasks, fn) {
  return Promise.all(tasks.map(task => fn(task)))
};

const chainFn = function chainFn(base, fn) {
  /* istanbul ignore if */
  if (typeof fn !== 'function') {
    return base
  }
  return function () {
    if (typeof base !== 'function') {
      return fn.apply(this, arguments)
    }
    let baseResult = base.apply(this, arguments);
    // Allow function to mutate the first argument instead of returning the result
    if (baseResult === undefined) {
      baseResult = arguments[0];
    }
    let fnResult = fn.call(
      this,
      baseResult,
      ...Array.prototype.slice.call(arguments, 1)
    );
    // Return mutated argument if no result was returned
    if (fnResult === undefined) {
      return baseResult
    }
    return fnResult
  }
};

const isPureObject = function isPureObject(o) {
  return !Array.isArray(o) && typeof o === 'object'
};

const isWindows = /^win/.test(process.platform);

const wp = function wp(p = '') {
  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\\/g, '\\\\')
  }
  return p
};

const wChunk = function wChunk(p = '') {
  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\//g, '_')
  }
  return p
};

const reqSep = /\//g;
const sysSep = _.escapeRegExp(path.sep);
const normalize = string => string.replace(reqSep, sysSep);

const r = function r() {
  let args = Array.prototype.slice.apply(arguments);
  let lastArg = _.last(args);

  if (lastArg.indexOf('@') === 0 || lastArg.indexOf('~') === 0) {
    return wp(lastArg)
  }

  return wp(path.resolve(...args.map(normalize)))
};

const relativeTo = function relativeTo() {
  let args = Array.prototype.slice.apply(arguments);
  let dir = args.shift();

  // Keep webpack inline loader intact
  if (args[0].indexOf('!') !== -1) {
    const loaders = args.shift().split('!');

    return loaders.concat(relativeTo(dir, loaders.pop(), ...args)).join('!')
  }

  // Resolve path
  let _path = r(...args);

  // Check if path is an alias
  if (_path.indexOf('@') === 0 || _path.indexOf('~') === 0) {
    return _path
  }

  // Make correct relative path
  let rp = path.relative(dir, _path);
  if (rp[0] !== '.') {
    rp = './' + rp;
  }

  return wp(rp)
};

const flatRoutes = function flatRoutes(router, _path = '', routes = []) {
  router.forEach(r => {
    if (!r.path.includes(':') && !r.path.includes('*')) {
      /* istanbul ignore if */
      if (r.children) {
        if (_path === '' && r.path === '/') {
          routes.push('/');
        }
        flatRoutes(r.children, _path + r.path + '/', routes);
      } else {
        _path = _path.replace(/^\/+$/, '/');
        routes.push(
          (r.path === '' && _path[_path.length - 1] === '/'
            ? _path.slice(0, -1)
            : _path) + r.path
        );
      }
    }
  });
  return routes
};

function cleanChildrenRoutes(routes, isChild = false) {
  let start = -1;
  let routesIndex = [];
  routes.forEach(route => {
    if (/-index$/.test(route.name) || route.name === 'index') {
      // Save indexOf 'index' key in name
      let res = route.name.split('-');
      let s = res.indexOf('index');
      start = start === -1 || s < start ? s : start;
      routesIndex.push(res);
    }
  });
  routes.forEach(route => {
    route.path = isChild ? route.path.replace('/', '') : route.path;
    if (route.path.indexOf('?') > -1) {
      let names = route.name.split('-');
      let paths = route.path.split('/');
      if (!isChild) {
        paths.shift();
      } // clean first / for parents
      routesIndex.forEach(r => {
        let i = r.indexOf('index') - start; //  children names
        if (i < paths.length) {
          for (let a = 0; a <= i; a++) {
            if (a === i) {
              paths[a] = paths[a].replace('?', '');
            }
            if (a < i && names[a] !== r[a]) {
              break
            }
          }
        }
      });
      route.path = (isChild ? '' : '/') + paths.join('/');
    }
    route.name = route.name.replace(/-index$/, '');
    if (route.children) {
      if (route.children.find(child => child.path === '')) {
        delete route.name;
      }
      route.children = cleanChildrenRoutes(route.children, true);
    }
  });
  return routes
}

const createRoutes = function createRoutes(files, srcDir, pagesDir) {
  let routes = [];
  files.forEach(file => {
    let keys = file
      .replace(RegExp(`^${pagesDir}`), '')
      .replace(/\.(vue|js)$/, '')
      .replace(/\/{2,}/g, '/')
      .split('/')
      .slice(1);
    let route = { name: '', path: '', component: r(srcDir, file) };
    let parent = routes;
    keys.forEach((key, i) => {
      // remove underscore only, if its the prefix
      const sanatizedKey = key.indexOf('_') === 0
        ? key.replace('_', '')
        : key;
      route.name = route.name
        ? route.name + '-' + sanatizedKey
        : sanatizedKey;
      route.name += key === '_' ? 'all' : '';
      route.chunkName = file.replace(/\.(vue|js)$/, '');
      let child = _.find(parent, { name: route.name });
      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = '';
      } else {
        if (key === 'index' && i + 1 === keys.length) {
          route.path += i > 0 ? '' : '/';
        } else {
          route.path += '/' +
            (key === '_'
              ? '*'
              : key.indexOf('_') === 0
                ? key.replace('_', ':')
                : key);
          if (key !== '_' && key.indexOf('_') === 0) {
            route.path += '?';
          }
        }
      }
    });
    // Order Routes path
    parent.push(route);
    parent.sort((a, b) => {
      if (!a.path.length) {
        return -1
      }
      if (!b.path.length) {
        return 1
      }
      // Order: /static, /index, /:dynamic
      // Match exact route before index: /login before /index/_slug
      if (a.path === '/') {
        return /^\/(:|\*)/.test(b.path) ? -1 : 1
      }
      if (b.path === '/') {
        return /^\/(:|\*)/.test(a.path) ? 1 : -1
      }
      let i = 0;
      let res = 0;
      let y = 0;
      let z = 0;
      const _a = a.path.split('/');
      const _b = b.path.split('/');
      for (i = 0; i < _a.length; i++) {
        if (res !== 0) {
          break
        }
        y = _a[i] === '*' ? 2 : _a[i].indexOf(':') > -1 ? 1 : 0;
        z = _b[i] === '*' ? 2 : _b[i].indexOf(':') > -1 ? 1 : 0;
        res = y - z;
        // If a.length >= b.length
        if (i === _b.length - 1 && res === 0) {
          // change order if * found
          res = _a[i] === '*' ? -1 : 1;
        }
      }
      return res === 0 ? (_a[i - 1] === '*' && _b[i] ? 1 : -1) : res
    });
  });
  return cleanChildrenRoutes(routes)
};

var Utils = /*#__PURE__*/Object.freeze({
  encodeHtml: encodeHtml,
  getContext: getContext,
  waitFor: waitFor,
  timeout: timeout,
  urlJoin: urlJoin,
  isUrl: isUrl,
  promisifyRoute: promisifyRoute,
  sequence: sequence,
  parallel: parallel,
  chainFn: chainFn,
  isPureObject: isPureObject,
  isWindows: isWindows,
  wp: wp,
  wChunk: wChunk,
  r: r,
  relativeTo: relativeTo,
  flatRoutes: flatRoutes,
  createRoutes: createRoutes
});

class ModuleContainer {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.requiredModules = {};
  }

  async ready() {
    // Call before hook
    await this.nuxt.callHook('modules:before', this, this.options.modules);

    // Load every module in sequence
    await sequence(this.options.modules, this.addModule.bind(this));

    // Call done hook
    await this.nuxt.callHook('modules:done', this);
  }

  addVendor(vendor) {
    // Make it silent for backward compability with nuxt 1.x
  }

  addTemplate(template) {
    /* istanbul ignore if */
    if (!template) {
      throw new Error('Invalid template:' + JSON.stringify(template))
    }

    // Validate & parse source
    const src = template.src || template;
    const srcPath = path.parse(src);
    /* istanbul ignore if */
    if (!src || typeof src !== 'string' || !fs.existsSync(src)) {
      throw new Error('Template src not found:' + src)
    }

    // Generate unique and human readable dst filename
    const dst =
      template.fileName ||
      path.basename(srcPath.dir) + `.${srcPath.name}.${hash(src)}` + srcPath.ext;

    // Add to templates list
    const templateObj = {
      src,
      dst,
      options: template.options
    };

    this.options.build.templates.push(templateObj);
    return templateObj
  }

  addPlugin(template) {
    const { dst } = this.addTemplate(template);

    // Add to nuxt plugins
    this.options.plugins.unshift({
      src: path.join(this.options.buildDir, dst),
      ssr: template.ssr
    });
  }

  addLayout(template, name) {
    const { dst, src } = this.addTemplate(template);

    // Add to nuxt layouts
    this.options.layouts[name || path.parse(src).name] = `./${dst}`;
  }

  addServerMiddleware(middleware) {
    this.options.serverMiddleware.push(middleware);
  }

  extendBuild(fn) {
    this.options.build.extend = chainFn(this.options.build.extend, fn);
  }

  extendRoutes(fn) {
    this.options.router.extendRoutes = chainFn(
      this.options.router.extendRoutes,
      fn
    );
  }

  requireModule(moduleOpts) {
    return this.addModule(moduleOpts, true /* require once */)
  }

  async addModule(moduleOpts, requireOnce) {
    let src;
    let options;
    let handler;

    // Type 1: String
    if (typeof moduleOpts === 'string') {
      src = moduleOpts;
    } else if (Array.isArray(moduleOpts)) {
      // Type 2: Babel style array
      src = moduleOpts[0];
      options = moduleOpts[1];
    } else if (typeof moduleOpts === 'object') {
      // Type 3: Pure object
      src = moduleOpts.src;
      options = moduleOpts.options;
      handler = moduleOpts.handler;
    }

    // Resolve handler
    if (!handler) {
      handler = this.nuxt.requireModule(src, { esm: false });
    }

    // Validate handler
    /* istanbul ignore if */
    if (typeof handler !== 'function') {
      throw new Error('Module should export a function: ' + src)
    }

    // Resolve module meta
    const key = (handler.meta && handler.meta.name) || handler.name || src;

    // Update requiredModules
    if (typeof key === 'string') {
      if (requireOnce && this.requiredModules[key]) {
        return
      }
      this.requiredModules[key] = { src, options, handler };
    }

    // Default module options to empty object
    if (options === undefined) {
      options = {};
    }

    return new Promise((resolve, reject) => {
      // Call module with `this` context and pass options
      const result = handler.call(this, options);

      // If module send back a promise
      if (result && result.then) {
        return resolve(result)
      }

      // synchronous
      return resolve()
    })
  }
}

var modes = {
  universal: {
    build: {
      ssr: true
    },
    render: {
      ssr: true
    }
  },
  spa: {
    build: {
      ssr: false
    },
    render: {
      ssr: false
    }
  }
}

const nuxtDir = fs.existsSync(path.resolve(__dirname, '..', 'package.json'))
  ? path.resolve(__dirname, '..') // dist
  : path.resolve(__dirname, '..', '..'); // src

var defaults = {
  // Information about running environment
  dev: Boolean(env.dev),
  debug: undefined, // = dev

  // Mode
  mode: 'universal',

  // Dirs
  buildDir: '.nuxt',
  nuxtDir,
  nuxtAppDir: path.resolve(nuxtDir, 'lib', 'app'),
  modulesDir: ['node_modules'], // ~> relative to options.rootDir

  // Ignore
  ignorePrefix: '-',
  ignore: [
    '**/*.test.*'
  ],

  extensions: [],

  build: {
    analyze: false,
    profile: process.argv.includes('--profile'),
    maxChunkSize: false,
    extractCSS: false,
    cssSourceMap: undefined,
    ssr: undefined,
    parallel: false,
    cache: false,
    publicPath: '/_nuxt/',
    filenames: {
      app: '[name].[contenthash].js',
      chunk: '[name].[contenthash].js',
      css: '[name].[contenthash].css'
    },
    styleResources: {},
    plugins: [],
    optimization: {
      splitChunks: {
        chunks: 'all',
        automaticNameDelimiter: '.',
        name: undefined,
        cacheGroups: {}
      }
    },
    splitChunks: {
      layouts: false,
      pages: true,
      commons: true
    },
    babel: {
      babelrc: false,
      cacheDirectory: undefined
    },
    transpile: [], // Name of NPM packages to be transpiled
    vueLoader: {},
    postcss: {},
    templates: [],
    watch: [],
    devMiddleware: {},
    hotMiddleware: {},
    stats: {
      chunks: false,
      children: false,
      modules: false,
      colors: true,
      warnings: true,
      errors: true,
      excludeAssets: [
        /.map$/,
        /index\..+\.html$/,
        /vue-ssr-client-manifest.json/
      ]
    }
  },
  generate: {
    dir: 'dist',
    routes: [],
    concurrency: 500,
    interval: 0,
    subFolders: true,
    fallback: '200.html',
    minify: {
      collapseBooleanAttributes: true,
      collapseWhitespace: false,
      decodeEntities: true,
      minifyCSS: true,
      minifyJS: true,
      processConditionalComments: true,
      removeAttributeQuotes: false,
      removeComments: false,
      removeEmptyAttributes: true,
      removeOptionalTags: true,
      removeRedundantAttributes: true,
      removeScriptTypeAttributes: false,
      removeStyleLinkTypeAttributes: false,
      removeTagWhitespace: false,
      sortAttributes: true,
      sortClassName: false,
      trimCustomFragments: true,
      useShortDoctype: true
    }
  },
  env: {},
  head: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  plugins: [],
  css: [],
  modules: [],
  layouts: {},
  serverMiddleware: [],
  ErrorPage: null,
  loading: {
    color: 'black',
    failedColor: 'red',
    height: '2px',
    duration: 5000,
    rtl: false
  },
  loadingIndicator: 'default',
  transition: {
    name: 'page',
    mode: 'out-in',
    appear: false,
    appearClass: 'appear',
    appearActiveClass: 'appear-active',
    appearToClass: 'appear-to'
  },
  layoutTransition: {
    name: 'layout',
    mode: 'out-in'
  },
  dir: {
    assets: 'assets',
    layouts: 'layouts',
    middleware: 'middleware',
    pages: 'pages',
    static: 'static',
    store: 'store'
  },
  router: {
    mode: 'history',
    base: '/',
    routes: [],
    middleware: [],
    linkActiveClass: 'nuxt-link-active',
    linkExactActiveClass: 'nuxt-link-exact-active',
    extendRoutes: null,
    scrollBehavior: null,
    parseQuery: false,
    stringifyQuery: false,
    fallback: false
  },
  render: {
    bundleRenderer: {
      shouldPrefetch: () => false
    },
    resourceHints: true,
    ssr: undefined,
    http2: {
      push: false,
      shouldPush: null
    },
    static: {
      prefix: true
    },
    gzip: {
      threshold: 0
    },
    etag: {
      weak: false
    },
    csp: false
  },
  watchers: {
    webpack: {},
    chokidar: {}
  },
  editor: undefined,
  hooks: null,
  messages: {
    loading: 'Loading...',
    error_404: 'This page could not be found',
    server_error: 'Server error',
    nuxtjs: 'Nuxt.js',
    back_to_home: 'Back to the home page',
    server_error_details:
      'An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.',
    client_error: 'Error',
    client_error_details:
      'An error occurred while rendering the page. Check developer tools console for details.'
  }
}

const Options = {};

Options.from = function (_options) {
  // Clone options to prevent unwanted side-effects
  const options = Object.assign({}, _options);

  // Normalize options
  if (options.loading === true) {
    delete options.loading;
  }
  if (
    options.router &&
    options.router.middleware &&
    !Array.isArray(options.router.middleware)
  ) {
    options.router.middleware = [options.router.middleware];
  }
  if (options.router && typeof options.router.base === 'string') {
    options._routerBaseSpecified = true;
  }
  if (typeof options.transition === 'string') {
    options.transition = { name: options.transition };
  }
  if (typeof options.layoutTransition === 'string') {
    options.layoutTransition = { name: options.layoutTransition };
  }
  if (typeof options.extensions === 'string') {
    options.extensions = [options.extensions];
  }

  const hasValue = v => typeof v === 'string' && v;
  options.rootDir = hasValue(options.rootDir) ? options.rootDir : process.cwd();

  // Apply defaults by ${buildDir}/dist/build.config.js
  // TODO: Unsafe operation.
  // const buildDir = options.buildDir || defaults.buildDir
  // const buildConfig = resolve(options.rootDir, buildDir, 'build.config.js')
  // if (existsSync(buildConfig)) {
  //   _.defaultsDeep(options, require(buildConfig))
  // }

  // Apply defaults
  _.defaultsDeep(options, defaults);

  // Resolve dirs
  options.srcDir = hasValue(options.srcDir)
    ? path.resolve(options.rootDir, options.srcDir)
    : options.rootDir;
  options.buildDir = path.resolve(options.rootDir, options.buildDir);

  // Populate modulesDir
  options.modulesDir = []
    .concat(options.modulesDir)
    .concat(path.join(options.nuxtDir, 'node_modules'))
    .filter(dir => hasValue(dir))
    .map(dir => path.resolve(options.rootDir, dir));

  // Sanitize extensions
  if (options.extensions.indexOf('js') === -1) {
    options.extensions.unshift('js');
  }

  if (options.extensions.indexOf('mjs') === -1) {
    options.extensions.unshift('mjs');
  }

  // If app.html is defined, set the template path to the user template
  options.appTemplatePath = path.resolve(options.buildDir, 'views/app.template.html');
  if (fs.existsSync(path.join(options.srcDir, 'app.html'))) {
    options.appTemplatePath = path.join(options.srcDir, 'app.html');
  }

  // Ignore publicPath on dev
  /* istanbul ignore if */
  if (options.dev && isUrl(options.build.publicPath)) {
    options.build.publicPath = defaults.build.publicPath;
  }

  // If store defined, update store options to true unless explicitly disabled
  if (
    options.store !== false &&
    fs.existsSync(path.join(options.srcDir, options.dir.store)) &&
    fs.readdirSync(path.join(options.srcDir, options.dir.store))
      .find(filename => filename !== 'README.md' && filename[0] !== '.')
  ) {
    options.store = true;
  }

  // SPA loadingIndicator
  if (options.loadingIndicator) {
    // Normalize loadingIndicator
    if (!isPureObject(options.loadingIndicator)) {
      options.loadingIndicator = { name: options.loadingIndicator };
    }

    // Apply defaults
    options.loadingIndicator = Object.assign(
      {
        name: 'default',
        color: (options.loading && options.loading.color) || '#D3D3D3',
        color2: '#F5F5F5',
        background: (options.manifest && options.manifest.theme_color) || 'white',
        dev: options.dev,
        loading: options.messages.loading
      },
      options.loadingIndicator
    );
  }

  // Debug errors
  if (options.debug === undefined) {
    options.debug = options.dev;
  }

  // Apply default hash to CSP option
  const csp = options.render.csp;
  const cspDefaults = {
    hashAlgorithm: 'sha256',
    allowedSources: undefined,
    policies: undefined
  };
  if (csp) {
    options.render.csp = _.defaults(_.isObject(csp) ? csp : {}, cspDefaults);
  }

  // cssSourceMap
  if (options.build.cssSourceMap === undefined) {
    options.build.cssSourceMap = options.dev;
  }

  // babel cacheDirectory
  if (options.build.babel.cacheDirectory === undefined) {
    options.build.babel.cacheDirectory = options.dev;
  }

  // Normalize ignore
  options.ignore = options.ignore ? [].concat(options.ignore) : [];

  // Append ignorePrefix glob to ignore
  if (typeof options.ignorePrefix === 'string') {
    options.ignore.push(`**/${options.ignorePrefix}*.*`);
  }

  // Apply mode preset
  const modePreset = modes[options.mode || 'universal'] || modes['universal'];
  _.defaultsDeep(options, modePreset);

  // If no server-side rendering, add appear true transition
  /* istanbul ignore if */
  if (options.render.ssr === false && options.transition) {
    options.transition.appear = true;
  }

  // We assume the SPA fallback path is 404.html (for GitHub Pages, Surge, etc.)
  if (options.generate.fallback === true) {
    options.generate.fallback = '404.html';
  }

  // Enable [name] when analyze or dev mode
  if (options.build.optimization.splitChunks.name === undefined &&
    (options.dev || options.build.analyze)) {
    options.build.optimization.splitChunks.name = true;
  }

  if (options.build.stats === 'none') {
    options.build.stats = false;
  }

  // Vendor backward compatibility with nuxt 1.x
  if (typeof options.build.vendor !== 'undefined') {
    delete options.build.vendor;
    consola.warn('vendor has been deprecated due to webpack4 optimization');
  }

  // TODO: remove when mini-css-extract-plugin supports HMR
  if (options.dev) {
    options.build.extractCSS = false;
  }

  // include SFCs in node_modules
  options.build.transpile = [/\.vue\.js/].concat(options.build.transpile || []);

  return options
};

var name = "nuxt";
var version = "2.0.0";
var description = "A minimalistic framework for server-rendered Vue.js applications (inspired by Next.js)";
var contributors = [
	{
		name: "Sebastien Chopin (@Atinux)"
	},
	{
		name: "Alexandre Chopin (@alexchopin)"
	},
	{
		name: "Pooya Parsa (@pi0)"
	},
	{
		name: "Clark Du (@clarkdo)"
	}
];
var main = "index.js";
var module$1 = "./lib/nuxt.js";
var license = "MIT";
var repository = {
	type: "git",
	url: "git+https://github.com/nuxt/nuxt.js"
};
var files = [
	"bin",
	"lib",
	"dist",
	"index.js"
];
var keywords = [
	"nuxt",
	"nuxt.js",
	"nuxtjs",
	"vue",
	"vue.js",
	"vuejs",
	"vue universal",
	"vue ssr",
	"vue isomorphic",
	"vue versatile"
];
var homepage = "https://github.com/nuxt/nuxt.js#readme";
var bin = {
	nuxt: "./bin/nuxt"
};
var scripts = {
	build: "yarn build:nuxt && yarn build:nuxt-start && yarn build:nuxt-legacy",
	"build:nuxt": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt.js",
	"build:nuxt-legacy": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt-legacy.js",
	"build:nuxt-start": "cross-env NODE_ENV=production rollup -c scripts/rollup/nuxt-start.js",
	"build:make-start": "node scripts/make-start",
	clean: "rimraf dist",
	coverage: "codecov",
	lint: "eslint --ext .js,.mjs,.vue bin lib test examples",
	postinstall: "opencollective postinstall || exit 0",
	prebuild: "yarn clean",
	security: "nsp check || true",
	test: "yarn test:fixtures && yarn test:unit",
	"test:fixtures": "jest --maxWorkers=4 --forceExit --detectOpenHandles --coverage -e test/fixtures",
	"test:e2e": "jest --maxWorkers=1 --forceExit --detectOpenHandles test/e2e",
	"test:lint": "yarn lint && yarn security",
	"test:unit": "jest --maxWorkers=4 --forceExit --detectOpenHandles --coverage -e test/unit"
};
var engines = {
	node: ">=8.0.0",
	npm: ">=5.0.0"
};
var dependencies = {
	"@nuxtjs/friendly-errors-webpack-plugin": "^2.0.2",
	"@nuxtjs/youch": "^4.2.3",
	autoprefixer: "^8.6.4",
	"babel-core": "^6.26.3",
	"babel-loader": "^7.1.4",
	"babel-preset-vue-app": "^2.0.0",
	"cache-loader": "^1.2.2",
	"caniuse-lite": "^1.0.30000862",
	chalk: "^2.4.1",
	chokidar: "^2.0.3",
	compression: "^1.7.1",
	connect: "^3.6.5",
	consola: "^1.4.1",
	"css-loader": "^0.28.11",
	"es6-promise": "^4.2.4",
	esm: "^3.0.62",
	etag: "^1.8.1",
	"file-loader": "^1.1.11",
	fresh: "^0.5.2",
	"fs-extra": "^6.0.1",
	glob: "^7.1.2",
	"hash-sum": "^1.0.2",
	"html-minifier": "^3.5.16",
	"html-webpack-plugin": "^3.2.0",
	"launch-editor-middleware": "^2.2.1",
	lodash: "^4.17.10",
	"lru-cache": "^4.1.3",
	"memory-fs": "^0.4.1",
	"mini-css-extract-plugin": "^0.4.1",
	minimist: "^1.2.0",
	opencollective: "^1.0.3",
	pify: "^3.0.0",
	postcss: "^6.0.22",
	"postcss-import": "^11.1.0",
	"postcss-import-resolver": "^1.1.0",
	"postcss-loader": "^2.1.5",
	"postcss-preset-env": "^5.1.0",
	"postcss-url": "^7.3.2",
	semver: "^5.5.0",
	"serialize-javascript": "^1.5.0",
	"serve-static": "^1.13.2",
	"server-destroy": "^1.0.1",
	"std-env": "^1.3.0",
	"style-resources-loader": "^1.1.0",
	"thread-loader": "^1.1.5",
	"time-fix-plugin": "^2.0.3",
	"uglifyjs-webpack-plugin": "^1.2.7",
	upath: "^1.1.0",
	"url-loader": "^1.0.1",
	vue: "^2.5.16",
	"vue-loader": "^15.2.2",
	"vue-meta": "^1.5.2",
	"vue-router": "^3.0.1",
	"vue-server-renderer": "^2.5.16",
	"vue-template-compiler": "^2.5.16",
	vuex: "^3.0.1",
	webpack: "^4.14.0",
	"webpack-bundle-analyzer": "^2.13.1",
	"webpack-dev-middleware": "^3.1.3",
	"webpack-hot-middleware": "^2.22.2",
	"webpack-node-externals": "^1.7.2",
	webpackbar: "^2.6.1"
};
var devDependencies = {
	"babel-eslint": "^8.2.1",
	"babel-jest": "^23.0.1",
	"babel-plugin-external-helpers": "^6.22.0",
	"babel-polyfill": "^6.26.0",
	"babel-preset-env": "^1.7.0",
	codecov: "^3.0.2",
	"cross-env": "^5.2.0",
	eslint: "^4.19.1",
	"eslint-config-standard": "^11.0.0",
	"eslint-config-standard-jsx": "^5.0.0",
	"eslint-plugin-import": "^2.12.0",
	"eslint-plugin-jest": "^21.17.0",
	"eslint-plugin-node": "^6.0.0",
	"eslint-plugin-promise": "^3.8.0",
	"eslint-plugin-react": "^7.8.2",
	"eslint-plugin-standard": "^3.1.0",
	"eslint-plugin-vue": "^4.5.0",
	express: "^4.16.2",
	finalhandler: "^1.1.1",
	"get-port": "^3.2.0",
	jest: "^23.1.0",
	jsdom: "^11.11.0",
	nsp: "^3.2.1",
	pug: "^2.0.3",
	"pug-plain-loader": "^1.0.0",
	puppeteer: "^1.5.0",
	request: "^2.87.0",
	"request-promise-native": "^1.0.5",
	rimraf: "^2.6.2",
	rollup: "^0.59.4",
	"rollup-plugin-babel": "^3.0.4",
	"rollup-plugin-commonjs": "^9.1.3",
	"rollup-plugin-json": "^3.0.0"
};
var collective = {
	type: "opencollective",
	url: "https://opencollective.com/nuxtjs",
	logo: "https://opencollective.com/nuxtjs/logo.txt?reverse=true&variant=variant2"
};
var packageJSON = {
	name: name,
	version: version,
	description: description,
	contributors: contributors,
	main: main,
	module: module$1,
	license: license,
	repository: repository,
	files: files,
	keywords: keywords,
	homepage: homepage,
	bin: bin,
	scripts: scripts,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	collective: collective
};

class MetaRenderer {
  constructor(nuxt, renderer) {
    this.nuxt = nuxt;
    this.renderer = renderer;
    this.options = nuxt.options;
    this.vueRenderer = vueServerRenderer.createRenderer();
    this.cache = LRU({});

    // Add VueMeta to Vue (this is only for SPA mode)
    // See lib/app/index.js
    Vue.use(VueMeta, {
      keyName: 'head',
      attribute: 'data-n-head',
      ssrAttribute: 'data-n-head-ssr',
      tagIDKeyName: 'hid'
    });
  }

  async getMeta(url) {
    const vm = new Vue({
      render: h => h(), // Render empty html tag
      head: this.options.head || {}
    });
    await this.vueRenderer.renderToString(vm);
    return vm.$meta().inject()
  }

  async render({ url = '/' }) {
    let meta = this.cache.get(url);

    if (meta) {
      return meta
    }

    meta = {
      HTML_ATTRS: '',
      BODY_ATTRS: '',
      HEAD: '',
      BODY_SCRIPTS: ''
    };

    // Get vue-meta context
    const m = await this.getMeta(url);

    // HTML_ATTRS
    meta.HTML_ATTRS = m.htmlAttrs.text();

    // BODY_ATTRS
    meta.BODY_ATTRS = m.bodyAttrs.text();

    // HEAD tags
    meta.HEAD =
      m.title.text() +
      m.meta.text() +
      m.link.text() +
      m.style.text() +
      m.script.text() +
      m.noscript.text();

    // BODY_SCRIPTS
    meta.BODY_SCRIPTS = m.script.text({ body: true }) + m.noscript.text({ body: true });

    // Resources Hints

    meta.resourceHints = '';

    const clientManifest = this.renderer.resources.clientManifest;

    const shouldPreload = this.options.render.bundleRenderer.shouldPreload || (() => true);
    const shouldPrefetch = this.options.render.bundleRenderer.shouldPrefetch || (() => true);

    if (this.options.render.resourceHints && clientManifest) {
      const publicPath = clientManifest.publicPath || '/_nuxt/';

      // Preload initial resources
      if (Array.isArray(clientManifest.initial)) {
        meta.resourceHints += clientManifest.initial
          .filter(file => shouldPreload(file))
          .map(
            r => `<link rel="preload" href="${publicPath}${r}" as="script" />`
          )
          .join('');
      }

      // Prefetch async resources
      if (Array.isArray(clientManifest.async)) {
        meta.resourceHints += clientManifest.async
          .filter(file => shouldPrefetch(file))
          .map(r => `<link rel="prefetch" href="${publicPath}${r}" />`)
          .join('');
      }

      // Add them to HEAD
      if (meta.resourceHints) {
        meta.HEAD += meta.resourceHints;
      }
    }

    // Emulate getPreloadFiles from vue-server-renderer (works for JS chunks only)
    meta.getPreloadFiles = () =>
      clientManifest.initial
        .filter(file => shouldPreload(file))
        .map(r => ({
          file: r,
          fileWithoutQuery: r,
          asType: 'script',
          extension: 'js'
        }));

    // Set meta tags inside cache
    this.cache.set(url, meta);

    return meta
  }
}

function errorMiddleware(err, req, res, next) {
  // ensure statusCode, message and name fields
  err.statusCode = err.statusCode || 500;
  err.message = err.message || 'Nuxt Server Error';
  err.name = !err.name || err.name === 'Error' ? 'NuxtServerError' : err.name;

  // We hide actual errors from end users, so show them on server logs
  if (err.statusCode !== 404) {
    consola.error(err);
  }

  const sendResponse = (content, type = 'text/html') => {
    // Set Headers
    res.statusCode = err.statusCode;
    res.statusMessage = err.name;
    res.setHeader('Content-Type', type + '; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(content));

    // Send Response
    res.end(content, 'utf-8');
  };

  // Check if request accepts JSON
  const hasReqHeader = (header, includes) =>
    req.headers[header] && req.headers[header].toLowerCase().includes(includes);
  const isJson =
    hasReqHeader('accept', 'application/json') ||
    hasReqHeader('user-agent', 'curl/');

  // Use basic errors when debug mode is disabled
  if (!this.options.debug) {
    // Json format is compatible with Youch json responses
    const json = {
      status: err.statusCode,
      message: err.message,
      name: err.name
    };
    if (isJson) {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
      return
    }
    const html = this.resources.errorTemplate(json);
    sendResponse(html);
    return
  }

  // Show stack trace
  const youch = new Youch(
    err,
    req,
    readSource.bind(this),
    this.options.router.base,
    true
  );
  if (isJson) {
    youch.toJSON().then(json => {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
    });
  } else {
    youch.toHTML().then(html => {
      sendResponse(html);
    });
  }
}

async function readSource(frame) {
  // Remove webpack:/// & query string from the end
  const sanitizeName = name =>
    name ? name.replace('webpack:///', '').split('?')[0] : null;
  frame.fileName = sanitizeName(frame.fileName);

  // Return if fileName is unknown
  /* istanbul ignore if */
  if (!frame.fileName) {
    return
  }

  // Possible paths for file
  const searchPath = [
    this.options.srcDir,
    this.options.rootDir,
    path.join(this.options.buildDir, 'dist'),
    this.options.buildDir,
    process.cwd()
  ];

  // Scan filesystem for real source
  for (let pathDir of searchPath) {
    let fullPath = path.resolve(pathDir, frame.fileName);
    let source = await fs$1.readFile(fullPath, 'utf-8').catch(() => null);
    if (source) {
      frame.contents = source;
      frame.fullPath = fullPath;
      if (path.isAbsolute(frame.fileName)) {
        frame.fileName = path.relative(this.options.rootDir, fullPath);
      }
      return
    }
  }

  // Fallback: use server bundle
  // TODO: restore to if after https://github.com/istanbuljs/nyc/issues/595 fixed
  /* istanbul ignore next */
  if (!frame.contents) {
    frame.contents = this.resources.serverBundle.files[frame.fileName];
  }
}

async function nuxtMiddleware(req, res, next) {
  // Get context
  const context = getContext(req, res);

  res.statusCode = 200;
  try {
    const result = await this.renderRoute(req.url, context);
    await this.nuxt.callHook('render:route', req.url, result, context);
    const {
      html,
      cspScriptSrcHashes,
      error,
      redirected,
      getPreloadFiles
    } = result;

    if (redirected) {
      return html
    }
    if (error) {
      res.statusCode = context.nuxt.error.statusCode || 500;
    }

    // Add ETag header
    if (!error && this.options.render.etag) {
      const etag = generateETag(html, this.options.render.etag);
      if (fresh(req.headers, { etag })) {
        res.statusCode = 304;
        res.end();
        return
      }
      res.setHeader('ETag', etag);
    }

    // HTTP2 push headers for preload assets
    if (!error && this.options.render.http2.push) {
      // Parse resourceHints to extract HTTP.2 prefetch/push headers
      // https://w3c.github.io/preload/#server-push-http-2
      const pushAssets = [];
      const preloadFiles = getPreloadFiles();
      const { shouldPush } = this.options.render.http2;
      const { publicPath } = this.resources.clientManifest;

      preloadFiles.forEach(({ file, asType, fileWithoutQuery, extension }) => {
        // By default, we only preload scripts or css
        /* istanbul ignore if */
        if (!shouldPush && asType !== 'script' && asType !== 'style') {
          return
        }

        // User wants to explicitly control what to preload
        if (shouldPush && !shouldPush(fileWithoutQuery, asType)) {
          return
        }

        pushAssets.push(`<${publicPath}${file}>; rel=preload; as=${asType}`);
      });

      // Pass with single Link header
      // https://blog.cloudflare.com/http-2-server-push-with-multiple-assets-per-link-header
      // https://www.w3.org/Protocols/9707-link-header.html
      res.setHeader('Link', pushAssets.join(','));
    }

    if (this.options.render.csp) {
      const { allowedSources, policies } = this.options.render.csp;
      let cspStr = `script-src 'self'${this.options.dev ? " 'unsafe-eval'" : ''} ${(cspScriptSrcHashes).join(' ')}`;
      if (Array.isArray(allowedSources)) {
        // For compatible section
        cspStr += ' ' + allowedSources.join(' ');
      } else if (typeof policies === 'object' && policies !== null && !Array.isArray(policies)) {
        // Set default policy if necessary
        if (!policies['script-src'] || !Array.isArray(policies['script-src'])) {
          policies['script-src'] = [`'self'`].concat(cspScriptSrcHashes);
        } else {
          policies['script-src'] = cspScriptSrcHashes.concat(policies['script-src']);
          if (!policies['script-src'].includes(`'self'`)) {
            policies['script-src'] = [`'self'`].concat(policies['script-src']);
          }
        }

        // Make content-security-policy string
        let cspArr = [];
        Object.keys(policies).forEach((k) => {
          cspArr.push(`${k} ${policies[k].join(' ')}`);
        });
        cspStr = cspArr.join('; ');
      }
      res.setHeader('Content-Security-Policy', cspStr);
    }

    // Send response
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(html));
    res.end(html, 'utf8');
    return html
  } catch (err) {
    /* istanbul ignore if */
    if (context && context.redirected) {
      consola.error(err);
      return err
    }

    next(err);
  }
}

let jsdom = null;

class Renderer {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;

    // Will be set by createRenderer
    this.bundleRenderer = null;
    this.metaRenderer = null;

    // Will be available on dev
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;

    // Create new connect instance
    this.app = connect();

    // Renderer runtime resources
    this.resources = {
      clientManifest: null,
      serverBundle: null,
      ssrTemplate: null,
      spaTemplate: null,
      errorTemplate: parseTemplate('Nuxt.js Internal Server Error')
    };
  }

  async ready() {
    await this.nuxt.callHook('render:before', this, this.options.render);
    // Setup nuxt middleware
    await this.setupMiddleware();

    // Production: Load SSR resources from fs
    if (!this.options.dev) {
      await this.loadResources();
    }

    // Call done hook
    await this.nuxt.callHook('render:done', this);
  }

  async loadResources(_fs = fs$1) {
    let distPath = path.resolve(this.options.buildDir, 'dist');
    let updated = [];

    resourceMap.forEach(({ key, fileName, transform }) => {
      let rawKey = '$$' + key;
      const _path = path.join(distPath, fileName);

      let rawData, data;
      if (!_fs.existsSync(_path)) {
        return // Resource not exists
      }
      rawData = _fs.readFileSync(_path, 'utf8');
      if (!rawData || rawData === this.resources[rawKey]) {
        return // No changes
      }
      this.resources[rawKey] = rawData;
      data = transform(rawData);
      /* istanbul ignore if */
      if (!data) {
        return // Invalid data ?
      }
      this.resources[key] = data;
      updated.push(key);
    });

    // Reload error template
    const errorTemplatePath = path.resolve(this.options.buildDir, 'views/error.html');
    if (fs$1.existsSync(errorTemplatePath)) {
      this.resources.errorTemplate = parseTemplate(
        fs$1.readFileSync(errorTemplatePath, 'utf8')
      );
    }

    // Load loading template
    const loadingHTMLPath = path.resolve(this.options.buildDir, 'loading.html');
    if (fs$1.existsSync(loadingHTMLPath)) {
      this.resources.loadingHTML = fs$1.readFileSync(loadingHTMLPath, 'utf8');
      this.resources.loadingHTML = this.resources.loadingHTML
        .replace(/\r|\n|[\t\s]{3,}/g, '');
    } else {
      this.resources.loadingHTML = '';
    }

    // Call resourcesLoaded plugin
    await this.nuxt.callHook('render:resourcesLoaded', this.resources);

    if (updated.length > 0) {
      this.createRenderer();
    }
  }

  get noSSR() {
    return this.options.render.ssr === false
  }

  get isReady() {
    if (this.noSSR) {
      return Boolean(this.resources.spaTemplate)
    }

    return Boolean(this.bundleRenderer && this.resources.ssrTemplate)
  }

  get isResourcesAvailable() {
    // Required for both
    /* istanbul ignore if */
    if (!this.resources.clientManifest) {
      return false
    }

    // Required for SPA rendering
    if (this.noSSR) {
      return Boolean(this.resources.spaTemplate)
    }

    // Required for bundle renderer
    return Boolean(this.resources.ssrTemplate && this.resources.serverBundle)
  }

  createRenderer() {
    // Ensure resources are available
    if (!this.isResourcesAvailable) {
      return
    }

    // Create Meta Renderer
    this.metaRenderer = new MetaRenderer(this.nuxt, this);

    // Skip following steps if noSSR mode
    if (this.noSSR) {
      return
    }

    // Create bundle renderer for SSR
    this.bundleRenderer = vueServerRenderer.createBundleRenderer(
      this.resources.serverBundle,
      Object.assign(
        {
          clientManifest: this.resources.clientManifest,
          runInNewContext: false,
          basedir: this.options.rootDir
        },
        this.options.render.bundleRenderer
      )
    );
  }

  useMiddleware(m) {
    // Resolve
    const $m = m;
    let src;
    if (typeof m === 'string') {
      m = this.nuxt.requireModule(m);
    }
    if (typeof m.handler === 'string') {
      m.handler = this.nuxt.requireModule(m.handler);
    }

    const handler = m.handler || m;
    const path$$1 = (
      (m.prefix !== false ? this.options.router.base : '') +
      (typeof m.path === 'string' ? m.path : '')
    ).replace(/\/\//g, '/');

    // Inject $src and $m to final handler
    if (src) handler.$src = src;
    handler.$m = $m;

    // Use middleware
    this.app.use(path$$1, handler);
  }

  get publicPath() {
    return isUrl(this.options.build.publicPath)
      ? defaults.build.publicPath
      : this.options.build.publicPath
  }

  async setupMiddleware() {
    // Apply setupMiddleware from modules first
    await this.nuxt.callHook('render:setupMiddleware', this.app);

    // Gzip middleware for production
    if (!this.options.dev && this.options.render.gzip) {
      this.useMiddleware(compression(this.options.render.gzip));
    }

    // Common URL checks
    this.useMiddleware((req, res, next) => {
      // Prevent access to SSR resources
      if (ssrResourceRegex.test(req.url)) {
        res.statusCode = 404;
        return res.end()
      }
      next();
    });

    // Add webpack middleware only for development
    if (this.options.dev) {
      this.useMiddleware(async (req, res, next) => {
        if (this.webpackDevMiddleware) {
          await this.webpackDevMiddleware(req, res);
        }
        if (this.webpackHotMiddleware) {
          await this.webpackHotMiddleware(req, res);
        }
        next();
      });
    }

    // open in editor for debug mode only
    if (this.options.debug && this.options.dev) {
      this.useMiddleware({
        path: '__open-in-editor',
        handler: launchMiddleware(this.options.editor)
      });
    }

    // For serving static/ files to /
    const staticMiddleware = serveStatic(
      path.resolve(this.options.srcDir, this.options.dir.static),
      this.options.render.static
    );
    staticMiddleware.prefix = this.options.render.static.prefix;
    this.useMiddleware(staticMiddleware);

    // Serve .nuxt/dist/ files only for production
    // For dev they will be served with devMiddleware
    if (!this.options.dev) {
      const distDir = path.resolve(this.options.buildDir, 'dist');
      this.useMiddleware({
        path: this.publicPath,
        handler: serveStatic(distDir, {
          index: false, // Don't serve index.html template
          maxAge: '1y' // 1 year in production
        })
      });
    }

    // Add User provided middleware
    this.options.serverMiddleware.forEach(m => {
      this.useMiddleware(m);
    });

    // Finally use nuxtMiddleware
    this.useMiddleware(nuxtMiddleware.bind(this));

    // Error middleware for errors that occurred in middleware that declared above
    // Middleware should exactly take 4 arguments
    // https://github.com/senchalabs/connect#error-middleware

    // Apply errorMiddleware from modules first
    await this.nuxt.callHook('render:errorMiddleware', this.app);

    // Apply errorMiddleware from Nuxt
    this.useMiddleware(errorMiddleware.bind(this));
  }

  renderTemplate(ssr, opts) {
    // Fix problem with HTMLPlugin's minify option (#3392)
    opts.html_attrs = opts.HTML_ATTRS;
    opts.body_attrs = opts.BODY_ATTRS;

    const fn = ssr ? this.resources.ssrTemplate : this.resources.spaTemplate;

    return fn(opts)
  }

  async renderRoute(url, context = {}) {
    /* istanbul ignore if */
    if (!this.isReady) {
      await waitFor(1000);
      return this.renderRoute(url, context)
    }

    // Log rendered url
    consola.debug(`Rendering url ${url}`);

    // Add url and isSever to the context
    context.url = url;

    // Basic response if SSR is disabled or spa data provided
    const spa = context.spa || (context.res && context.res.spa);
    const ENV = this.options.env;

    if (this.noSSR || spa) {
      const {
        HTML_ATTRS,
        BODY_ATTRS,
        HEAD,
        BODY_SCRIPTS,
        getPreloadFiles
      } = await this.metaRenderer.render(context);
      const APP =
        `<div id="__nuxt">${this.resources.loadingHTML}</div>` + BODY_SCRIPTS;

      // Detect 404 errors
      if (
        url.includes(this.options.build.publicPath) ||
        url.includes('__webpack')
      ) {
        const err = {
          statusCode: 404,
          message: this.options.messages.error_404,
          name: 'ResourceNotFound'
        };
        throw err
      }

      const html = this.renderTemplate(false, {
        HTML_ATTRS,
        BODY_ATTRS,
        HEAD,
        APP,
        ENV
      });

      return { html, getPreloadFiles }
    }

    // Call renderToString from the bundleRenderer and generate the HTML (will update the context as well)
    let APP = await this.bundleRenderer.renderToString(context);

    if (!context.nuxt.serverRendered) {
      APP = '<div id="__nuxt"></div>';
    }
    const m = context.meta.inject();
    let HEAD =
      m.title.text() +
      m.meta.text() +
      m.link.text() +
      m.style.text() +
      m.script.text() +
      m.noscript.text();
    if (this.options._routerBaseSpecified) {
      HEAD += `<base href="${this.options.router.base}">`;
    }

    if (this.options.render.resourceHints) {
      HEAD += context.renderResourceHints();
    }

    await this.nuxt.callHook('render:context', context.nuxt);

    const serializedSession = `window.__NUXT__=${serialize(context.nuxt, {
      isJSON: true
    })};`;

    const cspScriptSrcHashes = [];
    if (this.options.render.csp) {
      const { hashAlgorithm } = this.options.render.csp;
      let hash$$1 = crypto.createHash(hashAlgorithm);
      hash$$1.update(serializedSession);
      cspScriptSrcHashes.push(
        `'${hashAlgorithm}-${hash$$1.digest('base64')}'`
      );
    }

    APP += `<script>${serializedSession}</script>`;
    APP += context.renderScripts();
    APP += m.script.text({ body: true });
    APP += m.noscript.text({ body: true });

    HEAD += context.renderStyles();

    const html = this.renderTemplate(true, {
      HTML_ATTRS: 'data-n-head-ssr ' + m.htmlAttrs.text(),
      BODY_ATTRS: m.bodyAttrs.text(),
      HEAD,
      APP,
      ENV
    });

    return {
      html,
      cspScriptSrcHashes,
      getPreloadFiles: context.getPreloadFiles,
      error: context.nuxt.error,
      redirected: context.redirected
    }
  }

  async renderAndGetWindow(url, opts = {}) {
    /* istanbul ignore if */
    if (!jsdom) {
      try {
        jsdom = require('jsdom');
      } catch (e) /* istanbul ignore next */ {
        consola.error(`
         Fail when calling nuxt.renderAndGetWindow(url)
         jsdom module is not installed
         Please install jsdom with: npm install --save-dev jsdom
        `);
        throw e
      }
    }
    let options = {
      resources: 'usable', // load subresources (https://github.com/tmpvar/jsdom#loading-subresources)
      runScripts: 'dangerously',
      beforeParse(window) {
        // Mock window.scrollTo
        window.scrollTo = () => {};
      }
    };
    const jsdomErrHandler = err => { throw err };
    if (opts.virtualConsole !== false) {
      options.virtualConsole = new jsdom.VirtualConsole().sendTo(consola);
      // throw error when window creation failed
      options.virtualConsole.on('jsdomError', jsdomErrHandler);
    }
    url = url || 'http://localhost:3000';
    const { window } = await jsdom.JSDOM.fromURL(url, options);
    // If Nuxt could not be loaded (error from the server-side)
    const nuxtExists = window.document.body.innerHTML.includes(
      this.options.render.ssr ? 'window.__NUXT__' : '<div id="__nuxt">'
    );
    /* istanbul ignore if */
    if (!nuxtExists) {
      let error = new Error('Could not load the nuxt app');
      error.body = window.document.body.innerHTML;
      throw error
    }
    // Used by nuxt.js to say when the components are loaded and the app ready
    await timeout(new Promise(resolve => {
      window._onNuxtLoaded = () => resolve(window);
    }), 20000, 'Components loading in renderAndGetWindow was not completed in 20s');
    if (opts.virtualConsole !== false) {
      // after window initialized successfully
      options.virtualConsole.removeListener('jsdomError', jsdomErrHandler);
    }
    // Send back window object
    return window
  }
}

const parseTemplate = templateStr =>
  _.template(templateStr, {
    interpolate: /{{([\s\S]+?)}}/g
  });

const resourceMap = [
  {
    key: 'clientManifest',
    fileName: 'vue-ssr-client-manifest.json',
    transform: JSON.parse
  },
  {
    key: 'serverBundle',
    fileName: 'server-bundle.json',
    transform: JSON.parse
  },
  {
    key: 'ssrTemplate',
    fileName: 'index.ssr.html',
    transform: parseTemplate
  },
  {
    key: 'spaTemplate',
    fileName: 'index.spa.html',
    transform: parseTemplate
  }
];

// Protector utility against request to SSR bundle files
const ssrResourceRegex = new RegExp(
  resourceMap.map(resource => resource.fileName).join('|'),
  'i'
);

class Nuxt {
  constructor(options = {}) {
    this.options = Options.from(options);

    this.readyMessage = null;
    this.initialized = false;

    // Hooks
    this._hooks = {};
    this.hook = this.hook.bind(this);

    // Create instance of core components
    this.moduleContainer = new ModuleContainer(this);
    this.renderer = new Renderer(this);

    // Backward compatibility
    this.render = this.renderer.app;
    this.renderRoute = this.renderer.renderRoute.bind(this.renderer);
    this.renderAndGetWindow = this.renderer.renderAndGetWindow.bind(
      this.renderer
    );

    // ESM Loader
    this.esm = esm(module, {});

    this._ready = this.ready().catch(err => {
      consola.fatal(err);
    });
  }

  static get version() {
    return packageJSON.version
  }

  async ready() {
    if (this._ready) {
      return this._ready
    }

    // Add hooks
    if (_.isPlainObject(this.options.hooks)) {
      this.addObjectHooks(this.options.hooks);
    } else if (typeof this.options.hooks === 'function') {
      this.options.hooks(this.hook);
    }

    // Await for modules
    await this.moduleContainer.ready();

    // Await for renderer to be ready
    await this.renderer.ready();

    this.initialized = true;

    // Call ready hook
    await this.callHook('ready', this);

    return this
  }

  hook(name$$1, fn) {
    if (!name$$1 || typeof fn !== 'function') {
      return
    }
    this._hooks[name$$1] = this._hooks[name$$1] || [];
    this._hooks[name$$1].push(fn);
  }

  async callHook(name$$1, ...args) {
    if (!this._hooks[name$$1]) {
      return
    }
    consola.debug(`Call ${name$$1} hooks (${this._hooks[name$$1].length})`);
    try {
      await sequence(this._hooks[name$$1], fn => fn(...args));
    } catch (err) {
      consola.error(err);
      this.callHook('error', err);
    }
  }

  addObjectHooks(hooksObj) {
    Object.keys(hooksObj).forEach(name$$1 => {
      let hooks = hooksObj[name$$1];
      hooks = Array.isArray(hooks) ? hooks : [hooks];

      hooks.forEach(hook => {
        this.hook(name$$1, hook);
      });
    });
  }

  showReady(clear = true) {
    if (!this.readyMessage) {
      return
    }

    consola.ready({
      message: this.readyMessage,
      badge: true,
      clear
    });
  }

  listen(port = 3000, host = 'localhost') {
    return this.ready().then(() => new Promise((resolve, reject) => {
      const server = this.renderer.app.listen(
        { port, host, exclusive: false },
        err => {
          /* istanbul ignore if */
          if (err) {
            return reject(err)
          }

          const listenURL = chalk.underline.blue(`http://${host}:${port}`);
          this.readyMessage = `Listening on ${listenURL}`;

          // Close server on nuxt close
          this.hook(
            'close',
            () =>
              new Promise((resolve, reject) => {
                // Destroy server by forcing every connection to be closed
                server.destroy(err => {
                  consola.debug('server closed');
                  /* istanbul ignore if */
                  if (err) {
                    return reject(err)
                  }
                  resolve();
                });
              })
          );

          this.callHook('listen', server, { port, host }).then(resolve);
        }
      );

      // Add server.destroy(cb) method
      enableDestroy(server);
    }))
  }

  resolveAlias(_path) {
    if (_path.indexOf('@@') === 0 || _path.indexOf('~~') === 0) {
      return path.join(this.options.rootDir, _path.substr(2))
    }

    if (_path.indexOf('@') === 0 || _path.indexOf('~') === 0) {
      return path.join(this.options.srcDir, _path.substr(1))
    }

    return path.resolve(this.options.srcDir, _path)
  }

  resolvePath(_path) {
    // Try to resolve using NPM resolve path first
    try {
      const resolvedPath = Module._resolveFilename(_path, {
        paths: this.options.modulesDir
      });
      return resolvedPath
    } catch (error) {
      if (error.code !== 'MODULE_NOT_FOUND') {
        throw error
      }
    }

    let __path = this.resolveAlias(_path);

    if (fs$1.existsSync(__path)) {
      return __path
    }

    for (let ext of this.options.extensions) {
      if (fs$1.existsSync(__path + '.' + ext)) {
        return __path + '.' + ext
      }
    }

    throw new Error(`Cannot resolve "${_path}" from "${__path}"`)
  }

  requireModule(_path, opts = {}) {
    const _resovledPath = this.resolvePath(_path);
    const m = opts.esm === false ? require(_resovledPath) : this.esm(_resovledPath);
    return (m && m.default) || m
  }

  async close(callback) {
    await this.callHook('close', this);

    /* istanbul ignore if */
    if (typeof callback === 'function') {
      await callback();
    }
  }
}

var core = {
  Nuxt,
  Module: ModuleContainer,
  Renderer
}

var nuxtStart = Object.assign({ Utils }, core)

module.exports = nuxtStart;
//# sourceMappingURL=nuxt-start.js.map
