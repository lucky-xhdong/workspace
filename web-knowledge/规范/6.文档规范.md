文档对于项目开发和维护、学习、重构、以及知识管理非常重要。和写测试用例一样、大部分开发人员会觉得写文档是一件痛苦的事情，不过只有时间能够证明它的价值。比如对于人员流动比较大的公司，如果有规范的文档体系，转交工作就会变动非常轻松.

广义的文档不单指‘说明文件’本身，它有很多形式、来源和载体，可以描述一个知识、以及知识形成和迭代的过程。例如版本库代码提交记录、代码注释、决策和讨论记录、CHANGELOG、示例代码、规范、传统文档等等

6.1 文档中心

每个团队都会有自己的文档输出(比如需求文档、原型设计、API文档、配置文档等等)，如果这些文档不在一个版本库里就比较分散，所以一个统一的文档中心是很有必要。下面的项目组织结构是否可以参考？

    规范/
    A应用/
      产品/
      设计/
      API文档/
      测试/
      其他/
    B应用/
    

6.2 文档格式

对于开发者来说，Markdown是最适合的、最通用的文档格式。支持版本库在线预览和变更历史跟踪，下面这些工具可以提高Markdown的开发效率:

    可视化编辑器
        Visual Code: 大部分代码编辑都支持Markdown编辑和预览
        Mou: Mac下的老牌编辑器
        typora: 跨平台的Markdown编辑器，推荐
    markdownlint: 编码检查器


6.3 文档模板

关于如何写好文档，很难通过标准或规范来进行约束，因为它的主观性比较强, 好的文档取决于编辑者的逻辑总结能力、表达能力、以及有没有站在读者的角度去思考问题。所以大部分情况下，我们可以为不同类型的文档提供一个模板，通过模板来说明一个文档需要包含哪些内容, 对文档的编写者进行引导.


6.4 讨论即文档

一般情况下，对于一个开源项目来说除了官方文档，Issues也是一个很重要的信息来源。在Issue中我们可以获取其他开发者遇到的问题和解决方案、给官方反馈/投票、关注官方的最新动态、和其他开发者头脑风暴唇枪舌战等等。Issue适合做有意义的、目的明确的讨论。关于Issue有很多妙用，推荐阅读这篇文章<如何使用 Issue 管理软件项目？> http://www.ruanyifeng.com/blog/2017/08/issue.html

那对于企业应用开发, Issue有用吗?

当然有用, 比如我们可以将这类话题从IM转移到Issue:

    设计方案
    决策/建议
        新功能、新技术引入
        重构
        性能优化
        规范
    问题讨论
    重大事件
    计划或进度跟踪
    ...


另外Issue通常通过标签来进行分类，方便组织和检索:

6.5 注释即文档

必要和适量的注释对阅读源代码的人来说就是一个路牌, 可以少走很多弯路.

6.6 代码即文档

现在有很多种工具支持从代码中解析和生成文档, 这可以给开发者简化很多文档维护的工作。

举个例子，我们经常会遇到修改了代码，但是文档忘记同步的情况。通过‘代码即文档’的方式至少可以保持文档和代码同步更新；另外很多工具会分析代码的数据类型，自动帮我们生成参数和返回值定义，这也可以减少很多文档编写工作以及出错率。

比如可以通过下面注释方式来生成组件文档:

    import * as React from 'react';
    import { Component } from 'react';
    
    /**
     * Props注释
     */
    export interface ColumnProps extends React.HTMLAttributes<any> {
      /** prop1 description */
      prop1?: string;
      /** prop2 description */
      prop2: number;
      /**
       * prop3 description
       */
      prop3: () => void;
      /** prop4 description */
      prop4: 'option1' | 'option2' | 'option3';
    }
    
    /**
     * 对组件进行注释
     */
    export class Column extends Component<ColumnProps, {}> {
      render() {
        return <div>Column</div>;
      }
    }

